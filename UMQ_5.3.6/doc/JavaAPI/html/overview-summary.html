<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_03-p4) on Thu Mar 06 13:15:39 CST 2014 -->
<TITLE>
Overview (UM Java API Specification)
</TITLE>

<META NAME="date" CONTENT="2014-03-06">

<LINK REL ="stylesheet" TYPE="text/css" HREF="stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Overview (UM Java API Specification)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

	<script type="text/javascript" src="../../Search/highlight.js"></script>
</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Overview</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Package</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="index.html?overview-summary.html" target="doccontent"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="overview-summary.html" target="doccontent"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
Provides classes and interfaces for implementing an UM source and/or receiver application.
<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#overview_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Packages</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="20%"><B><A HREF="com/latencybusters/auxapi/package-summary.html">com.latencybusters.auxapi</A></B></TD>
<TD>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="20%"><B><A HREF="com/latencybusters/lbm/package-summary.html">com.latencybusters.lbm</A></B></TD>
<TD>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="20%"><B><A HREF="com/latencybusters/lbm/sdm/package-summary.html">com.latencybusters.lbm.sdm</A></B></TD>
<TD>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="20%"><B><A HREF="com/latencybusters/pdm/package-summary.html">com.latencybusters.pdm</A></B></TD>
<TD>&nbsp;</TD>
</TR>
</TABLE>

<P>
&nbsp;<A NAME="overview_description"><!-- --></A>
<P>
<p>Provides classes and interfaces for implementing an UM source and/or receiver application.</p>

<div class="SECTION">
<h1 class="SECTION"><a id="JAVA-GUIDELINES" name="JAVA-GUIDELINES">IMPORTANT: Java
Guidelines</a></h1>

<p>For the most part, the best practices for the C API also apply to the Java
API. The following topics discuss the differences in C API vs. Java API best practices.</p>

<div class="TOC">
<dl>
<dt><b>Table of Contents</b></dt>

<dt>1. <a href="#JAVA-NATIVE-INTERFACE">Effects of Java Native Interface (JNI)</a></dt>

<dt>2. <a href="#JAVA-GARBAGE-COLLECTION">Effects of Java Garbage Collection</a></dt>

<dt>3. <a href="#JAVA-ZOD">Zero Object Delivery (ZOD)</a></dt>

<dt>4. <a href="#JAVA-PERFORMANCE-MESSAGE-SIZE">Message Size</a></dt>

<dt>5. <a href="#JAVA-PERFORMANCE-NOTES">Java Performance Notes</a></dt>

</dl>
</div>

<div class="SECTION">
<h2 class="SECTION"><a id="JAVA-NATIVE-INTERFACE"
name="JAVA-NATIVE-INTERFACE">1. Effects of Java Native Interface (JNI)</a></h2>

<p>The <b class="APPLICATION">UM</b> Java API makes use of the Java Native Interface
(JNI) to bridge between the native Java code and the <b class="APPLICATION">UM</b>
library (written in C). This interface provides for two different types of calls:
"downcalls" from Java into C, and "upcalls" from C into Java.</p>

<p>While still more expensive (in terms of CPU time) than a call from one Java method to
another Java method, downcalls are relatively inexpensive. Upcalls, on the other hand,
are significantly more expensive. Our experience (as well as anecdotal evidence from the
Internet) indicates that upcalls are 10 to 20 times more expensive than downcalls. This
expense translates directly to increased CPU time. In terms of <b
class="APPLICATION">UM</b>, this translates to higher latency and lower throughput.</p>

<p>In addition, an upcall must attach to a Java thread object in the JVM in order to
obtain an environment in which to run. Attaching to a new Java thread object is
significantly more expensive than re-attaching to an extant Java thread object.</p>

<p>This discussion applies only to receivers. Sending in 
<b class="APPLICATION">UM</b> requires mostly downcalls. In fact, performance measurements
show that the throughput from a Java sender is generally within a few percentage points
of the throughput for a C sender.</p>

<p>Receivers, on the other hand, receive data via callbacks from the 
<b class="APPLICATION">UM</b> library into the application code. Callbacks directly equate
to JNI upcalls, which (as noted above) are significantly more expensive than JNI
downcalls.</p>
</div>

<div class="SECTION">
<h2 class="SECTION"><a id="JAVA-GARBAGE-COLLECTION"
name="JAVA-GARBAGE-COLLECTION">2. Effects of Java Garbage Collection</a></h2>

<p>One significant problem with Java performance is garbage collection. 
While this makes the programmer's life easier,
having your application periodically stop doing application-specific useful work to
perform its housekeeping duties significantly degrades the overall performance of the
application. This is not to imply that garbage collection is not useful work: in the
context of Java, it certainly is. But it does nothing to further the goal of the
application itself, namely to receive and process data.</p>

<p>Thus, Java performance is inherently unpredictable and can vary significantly from one
instant to the next. As an example, consider the lbmrcv example program supplied with <b
class="APPLICATION">UM</b>. Running the C version will show a fairly steady data rate
for each sample printed. Running the Java version will show wildly varying data rates for
each sample printed. This is due in large part to the periodic interruption of the
application to do garbage collection. See 
<a href="#JAVA-ZOD">Zero Object Delivery (ZOD)</a> below for a UM Java feature that 
reduces the need for garbage collection.</p>

<div class="SECTION">
<h2 class="SECTION"><a id="JAVA-ZOD"
name="JAVA-ZOD">3. Zero Object Delivery (ZOD)</a></h2>

<p>UM's Zero Object Delivery (ZOD) feature for Java allows receivers to deliver messages, and sources/receivers deliver
events, to an application with no per-message object creation. This lets you write Java sending/receiving applications
that require little to no garbage collection at runtime, resulting in lower and more consistent message latencies and
hence, better performance.</p>

<div class="SECTION">
<h3 class="SECTION"><a id="USING-ZOD"
name="USING-ZOD">3.1 Using ZOD</a></h3>

<p>To benefit from this feature, you must call .dispose() on a message to mark it as available for reuse. To access
data from the message when using ZOD, use the following two methods in the LBMMessage class:</p>
<ul>
<li> LBMMessage.dataBuffer()
<li> LBMMessage.dataLength()
</ul>

<p>The .dataBuffer() method returns a reference to a thread-local direct ByteBuffer containing the message data. The
ByteBuffer's capacity is probably larger than the message data length, so you must call .dataLength() for the actual
data length. Discard/ignore the excess data in the ByteBuffer.</p>

<p>See the lbmrcv.java and lbmrcv.cs sample applications for examples using these methods.</p>

<div class="SECTION">
<h3 class="SECTION"><a id="RETAINING-MESSAGES"
name="RETAINING-MESSAGES">3.2 Retaining Messages</a></h3>

<p>Note that calling LBMMessage.data() is another, valid way to access message data, but this method does create a new
byte[] array object. JVM creates the byte[] array object returned by LBMMessage.data() once, on demand, the first time
you call .data(), and returns a reference to the same byte[] array object on subsequent calls to .data().</p>

<p>This method is a useful way to keep an LBMMessage object for processing outside of a receiver's callback. The byte[]
array object returned by LBMMessage.data() is persistent, that is, the data it contains and any array references remain
valid after the receiver's callback returns and until garbage collection. If you need only the message data for further
processing, save the return from LBMMessage.data() within the receiver's callback.</p>

<p>If instead you need to promote an entire LBMMessage to a full-fledged independent object for use outside of a receiver's
callback, use the LBMMessage.promote() method. This can be beneficial to an application receiving a mix of message
types; some requiring additional processing, and others not. receiver callback code can look similar to the
following:</p>

<PRE>
if (msg.dataBuffer().getInt() == number_indicating_lots_of_work) {
        /* Promote this message to an object for handoff to a worker thread,
         * so it remains valid after the receiver callback returns. */
        msg.promote();
        workerThread.msgQueue.enqueue(msg);
}
else {
        /* Use ZOD and just read out of msg.dataBuffer(),
         * entirely within the receiver callback. */
        ...
}
</PRE>

<p>LBMMessages promoted to full objects also return their own independent ByteBuffer objects from a call to
LBMMessage.dataBuffer(). This means that the ByteBuffer returned from a promoted LBMMessage's.dataBuffer() method is
persistent in the same way as the byte[] array object returned from a call to .data() on any LBMMessage object.</p>

<p>See the lbmresp.java sample application for another example of using LBMMessage.promote() to keep a message.</p>

<div class="SECTION">
<h2 class="SECTION"><a id="JAVA-PERFORMANCE-MESSAGE-SIZE"
name="JAVA-PERFORMANCE-MESSAGE-SIZE">4. Message Size</a></h2>

<p>Message size has a significant effect on performance. Smaller messages mean more
upcalls are required to receive and process a given amount of data. Larger messages
result in fewer upcalls, resulting in better performance. Our tests have shown that
smaller messages (64 bytes or smaller) yield approximately 25% of the performance of an
equivalent C application, while larger messages (512 bytes and up) can yield 67% of the
performance of an equivalent C application.</p>

<p>Granted, the size
of the message is beyond the control of the receiving application. But the sender <span
class="emphasis"><i class="EMPHASIS">can</i></span> control the message size. If you can 
modify the sender, consider using larger (500 bytes or more) messages. If
this is not possible, consider blocking multiple "logical" messages together into a
single "physical" message. The receiver would then be responsible for deblocking into the
constituent messages. Note that this is <span class="emphasis"><i
class="EMPHASIS">not</i></span> the same as <b class="APPLICATION">UM</b> batching.</p>

<p>Larger messages also have the advantage of making better use of the network bandwidth.
For example, consider a TCP packet. A minimum of 54 bytes (14 for the Ethernet frame, 20
bytes for the IP header, 20 bytes for the TCP header) of overhead are required to send a
one-byte message. A 512-byte message requires those same 54 bytes of overhead. On a 100
Mbps Ethernet network, at most 227,272 one-byte messages can be sent each second,
resulting in 227,272 bytes of application data. With a 512-byte message, at most 22,084
message can be sent each second, resulting in 11,307,008 bytes of application data.</p>
</div>

<div class="SECTION">
<h2 class="SECTION"><a id="JAVA-PERFORMANCE-NOTES"
name="JAVA-PERFORMANCE-MESSAGE-SIZE">5. Java Performance Notes</a></h2>

<div class="SECTION">
<h3 class="SECTION"><a id="JAVA-PERFORMANCE-CPU-SPEED"
name="JAVA-PERFORMANCE-CPU-SPEED">5.1 CPU Speed</a></h3>

<p>Our experience shows that Java applications are much more sensitive to CPU speed than
C applications. In other words, increasing the CPU speed will have more benefit for a
Java application than for a C application.</p>
</div>

<div class="SECTION">
<h3 class="SECTION"><a id="JAVA-PERFORMANCE-JVM-VERSION"
name="JAVA-PERFORMANCE-JVM-VERSION">5.2 JVM Version</a></h3>

<p>There is some improvement between the 1.4.2 and 1.5.0 JVMs with regard to overall
latency. However, in at least one case (Linux 64-bit x86), using the IBM JVM resulted in
double the performance (in terms of throughput) of the Sun JVM. However, we have heard
that the IBM JVM is much slower than Suns in straightforward computation. It is difficult
to predict the overall performance differences between IBM and SUN for a particular
application without experimentation.</p>
</div>

<div class="SECTION">
<h3 class="SECTION"><a id="JAVA-PERFORMANCE-KERNEL-FREQ"
name="JAVA-PERFORMANCE-KERNEL-FREQ">5.3 Linux Kernel Version and Timer
Frequency</a></h3>

<p>Surprisingly, no difference was seen between the 2.4 and 2.6 Linux kernels. In
addition, later 2.6 kernels allow the timer frequency to be set to 100 (default), 250, or
1000 Hz. No measurable difference was seen by changing the timer frequency.</p>
</div>

<div class="SECTION">
<h3 class="SECTION"><a id="JAVA-PERFORMANCE-UP-MP" name="JAVA-PERFORMANCE-UP-MP">6.4
Multiprocessor vs. Uniprocessor</a></h3>

<p>Multiple CPUs have a negligible effect in embedded and sequential modes. Using an
event queue yields a modest performance increase of approximately 15% over a single
CPU.</p>
</div>
</div>

</div>
<P>

<P>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Overview</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Package</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="index.html?overview-summary.html" target="doccontent"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="overview-summary.html" target="doccontent"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size=-1>  All of the documentation and software included in this and any      other Informatica Inc "Ultra Messaging" Release is             Copyright (C) 2004-2014, Informatica Corporation. All rights reserved.          Redistribution and use in source and binary forms, with or without  modification, are permitted only as covered by the terms of a       valid software license agreement with 29West Inc.                   Copyright &copy; 2004-2014, Informatica, Inc. All Rights Reserved.          </font>
</BODY>
<script type="text/javascript">highlight();</script>
</HTML>
