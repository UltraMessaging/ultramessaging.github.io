<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>LBM API: Source code for lbmmontrlbmsnmp.c</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
	<script type="text/javascript" src="../Search/highlight.js"></script>
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="lbmmon_examples.html">LBMMON Example source code</a>&nbsp;&raquo&nbsp;<a class="el" href="lbmmon_lbmsnmp_transport.html">LBMMON LBMSNMP transport module</a></div>
<h1><a class="anchor" name="lbmmontrlbmsnmp_c_page">Source code for lbmmontrlbmsnmp.c</a></h1><div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment">  All of the documentation and software included in this and any</span>
<span class="comment">  other Informatica Corporation Ultra Messaging Releases</span>
<span class="comment">  Copyright (C) Informatica Corporation. All rights reserved.</span>
<span class="comment">  </span>
<span class="comment">  Redistribution and use in source and binary forms, with or without</span>
<span class="comment">  modification, are permitted only as covered by the terms of a</span>
<span class="comment">  valid software license agreement with Informatica Corporation.</span>
<span class="comment"></span>
<span class="comment">  Copyright (C) 2004-2014, Informatica Corporation. All Rights Reserved.</span>
<span class="comment"></span>
<span class="comment">  THE SOFTWARE IS PROVIDED "AS IS" AND INFORMATICA DISCLAIMS ALL WARRANTIES </span>
<span class="comment">  EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY IMPLIED WARRANTIES OF </span>
<span class="comment">  NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR </span>
<span class="comment">  PURPOSE.  INFORMATICA DOES NOT WARRANT THAT USE OF THE SOFTWARE WILL BE </span>
<span class="comment">  UNINTERRUPTED OR ERROR-FREE.  INFORMATICA SHALL NOT, UNDER ANY CIRCUMSTANCES, BE </span>
<span class="comment">  LIABLE TO LICENSEE FOR LOST PROFITS, CONSEQUENTIAL, INCIDENTAL, SPECIAL OR </span>
<span class="comment">  INDIRECT DAMAGES ARISING OUT OF OR RELATED TO THIS AGREEMENT OR THE </span>
<span class="comment">  TRANSACTIONS CONTEMPLATED HEREUNDER, EVEN IF INFORMATICA HAS BEEN APPRISED OF </span>
<span class="comment">  THE LIKELIHOOD OF SUCH DAMAGES.</span>
<span class="comment">  </span>
<span class="comment">*/</span>

<span class="preprocessor">#ifdef __VOS__</span>
<span class="preprocessor"></span><span class="preprocessor">#define _POSIX_C_SOURCE 200112L</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/time.h&gt;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;time.h&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>
<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span><span class="preprocessor">        #define strcasecmp stricmp</span>
<span class="preprocessor"></span><span class="preprocessor">        #define snprintf _snprintf</span>
<span class="preprocessor"></span><span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">        #include "config.h"</span>
<span class="preprocessor">        #include &lt;unistd.h&gt;</span>
<span class="preprocessor">        #if defined(__TANDEM)</span>
<span class="preprocessor"></span><span class="preprocessor">                #if defined(HAVE_TANDEM_SPT)</span>
<span class="preprocessor"></span><span class="preprocessor">                        #include &lt;ktdmtyp.h&gt;</span>
<span class="preprocessor">                        #include &lt;spthread.h&gt;</span>
<span class="preprocessor">                #else</span>
<span class="preprocessor"></span><span class="preprocessor">                        #include &lt;pthread.h&gt;</span>
<span class="preprocessor">                #endif</span>
<span class="preprocessor"></span><span class="preprocessor">        #else</span>
<span class="preprocessor"></span><span class="preprocessor">                #include &lt;pthread.h&gt;</span>
<span class="preprocessor">        #endif</span>
<span class="preprocessor"></span><span class="preprocessor">        #include &lt;strings.h&gt;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;lbm/lbmmon.h&gt;</span>
<span class="preprocessor">#include &lt;lbm/lbmmontrlbmsnmp.h&gt;</span>
<span class="preprocessor">#include &lt;lbm/lbmaux.h&gt;</span>

<span class="comment">/*                                                                              </span>
<span class="comment">        Package all of the needed function pointers for this module into a</span>
<span class="comment">        lbmmon_transport_func_t structure.                                                                                                                                                              </span>
<span class="comment">*/</span>
<span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="structlbmmon__transport__func__t__stct.html" title="Transport module function pointer container.">lbmmon_transport_func_t</a> LBMMON_TRANSPORT_LBMSNMP =
{
        lbmmon_transport_lbmsnmp_initsrc,
        lbmmon_transport_lbmsnmp_initrcv,
        lbmmon_transport_lbmsnmp_send,
        lbmmon_transport_lbmsnmp_receive,
        lbmmon_transport_lbmsnmp_src_finish,
        lbmmon_transport_lbmsnmp_rcv_finish,
        lbmmon_transport_lbmsnmp_errmsg
};

<span class="comment">/*                                                                              </span>
<span class="comment">        For a statistics source, one of these gets returned as the TransportClientData.                                                                                                                                                         </span>
<span class="comment">*/</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span>
{
        <span class="comment">/* LBM context attributes */</span>
        lbm_context_attr_t * mContextAttributes;
        <span class="comment">/* LBM context created to send a statistics packet */</span>
        lbm_context_t * mContext;
        <span class="comment">/* LBM topic attributes */</span>
        lbm_src_topic_attr_t * mTopicAttributes;
        <span class="comment">/* LBM source created to send a statistics packet */</span>
        lbm_src_t * mSource;
        <span class="comment">/* LBM topic */</span>
        lbm_topic_t * mTopic;
} lbmmon_transport_lbmsnmp_src_t;

<span class="comment">/*</span>
<span class="comment">        A queue of incoming statistics packets is maintained. This describes each </span>
<span class="comment">        entry in the queue.</span>
<span class="comment">*/</span>
<span class="keyword">struct </span>lbmmon_transport_lbmsnmp_rcv_node_t_stct
{
        <span class="comment">/* Pointer to the LBM message */</span>
        <a class="code" href="structlbm__msg__t__stct.html" title="Structure that stores information about a received message.">lbm_msg_t</a> * mMessage;
        <span class="comment">/* Number of bytes of the message returned to caller */</span>
        <span class="keywordtype">size_t</span> mUsedBytes;
        <span class="comment">/* Next entry in the queue */</span>
        <span class="keyword">struct </span>lbmmon_transport_lbmsnmp_rcv_node_t_stct * mNext;
};
<span class="keyword">typedef</span> <span class="keyword">struct </span>lbmmon_transport_lbmsnmp_rcv_node_t_stct lbmmon_transport_lbmsnmp_rcv_node_t;

<span class="comment">/*                                                                              </span>
<span class="comment">        For a statistics receiver, one of these gets returned as the TransportClientData.                                                                                                                                                               </span>
<span class="comment">*/</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span>
{
        <span class="comment">/* Flag to indicate lock has been created */</span>
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mLockCreated;
        <span class="comment">/* Lock to prevent access by multiple threads */</span>
<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>        CRITICAL_SECTION mLock;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        pthread_mutex_t mLock;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>        <span class="comment">/* LBM context attributes */</span>
        lbm_context_attr_t * mContextAttributes;
        <span class="comment">/* LBM context used to receive packets */</span>
        lbm_context_t * mContext;
        <span class="comment">/* LBM receiver used to receive packets */</span>
        lbm_rcv_t * mReceiver;
        <span class="comment">/* Topic attributes */</span>
        lbm_rcv_topic_attr_t * mTopicAttributes;
        <span class="comment">/* Topic */</span>
        lbm_topic_t * mTopic;
        <span class="comment">/* Wildcard receiver attributes */</span>
        lbm_wildcard_rcv_attr_t * mWildcardReceiverAttributes;
        <span class="comment">/* If we're using a wildcard receiver... */</span>
        lbm_wildcard_rcv_t * mWildcardReceiver;
        <span class="comment">/* Head of the message queue */</span>
        lbmmon_transport_lbmsnmp_rcv_node_t * mHead;
        <span class="comment">/* Tail of the message queue */</span>
        lbmmon_transport_lbmsnmp_rcv_node_t * mTail;
} lbmmon_transport_lbmsnmp_rcv_t;

<span class="keyword">static</span> <span class="keywordtype">void</span>     src_cleanup(lbmmon_transport_lbmsnmp_src_t * Data);
<span class="keyword">static</span> <span class="keywordtype">void</span>     rcv_cleanup(lbmmon_transport_lbmsnmp_rcv_t * Data);
<span class="keyword">static</span> <span class="keywordtype">int</span> receive_callback(lbm_rcv_t * Receiver, <a class="code" href="structlbm__msg__t__stct.html" title="Structure that stores information about a received message.">lbm_msg_t</a> * Message, <span class="keywordtype">void</span> * ClientData);
<span class="keyword">static</span> <span class="keywordtype">void</span> lock_receiver(lbmmon_transport_lbmsnmp_rcv_t * Receiver);
<span class="keyword">static</span> <span class="keywordtype">void</span> unlock_receiver(lbmmon_transport_lbmsnmp_rcv_t * Receiver);
<span class="keyword">static</span> <span class="keywordtype">int</span> scope_is_valid(<span class="keyword">const</span> <span class="keywordtype">char</span> * Scope);

<span class="preprocessor">#define DEFAULT_CONTEXT_NAME "29west_statistics_context"</span>
<span class="preprocessor"></span><span class="preprocessor">#define DEFAULT_TOPIC "/29west/statistics"</span>
<span class="preprocessor"></span><span class="preprocessor">#define DEFAULT_MULTICAST_TTL "0"</span>
<span class="preprocessor"></span><span class="preprocessor">#define DEFAULT_TOPIC_RESOLUTION_ADDRESS "225.200.200.200"</span>
<span class="preprocessor"></span><span class="preprocessor">#define DEFAULT_LBTRM_ADDRESS "225.200.200.201"</span>
<span class="preprocessor"></span>
<span class="keyword">static</span> <span class="keywordtype">char</span> ErrorString[1024];

<span class="keyword">typedef</span> <span class="keyword">struct</span>
{
        <span class="keyword">const</span> <span class="keywordtype">char</span> * option;
        <span class="keyword">const</span> <span class="keywordtype">char</span> * value;
} option_entry_t;

<span class="keyword">static</span> option_entry_t SourceContextOption[] =
{
        <span class="comment">/* Force embedded mode for simplicity. */</span>
        { <span class="stringliteral">"operational_mode"</span>, <span class="stringliteral">"embedded"</span> },
        <span class="comment">/* Disable monitoring for this context. */</span>
        { <span class="stringliteral">"monitor_interval"</span>, <span class="stringliteral">"0"</span> },
        <span class="comment">/* We don't need request/response, so don't use up ports. */</span>
        { <span class="stringliteral">"request_tcp_bind_request_port"</span>, <span class="stringliteral">"0"</span> },
        <span class="comment">/* We don't need MIM, so disable MIM receiver. */</span>
        { <span class="stringliteral">"mim_incoming_address"</span>, <span class="stringliteral">"0.0.0.0"</span> },
        <span class="comment">/* No need to cache topics. */</span>
        { <span class="stringliteral">"resolver_cache"</span>, <span class="stringliteral">"0"</span> },
        <span class="comment">/* Force TTL=0 to keep stats and advertisements on the local machine. */</span>
        { <span class="stringliteral">"resolver_multicast_ttl"</span>, DEFAULT_MULTICAST_TTL },
        <span class="comment">/* Use a specific topic resolution address. */</span>
        { <span class="stringliteral">"resolver_multicast_address"</span>, DEFAULT_TOPIC_RESOLUTION_ADDRESS },
        <span class="comment">/* End of list. */</span>
        { NULL, NULL }
};

<span class="keyword">static</span> option_entry_t SourceContextOptionFixed[] =
{
        <span class="comment">/* Force embedded mode for simplicity. */</span>
        { <span class="stringliteral">"operational_mode"</span>, <span class="stringliteral">"embedded"</span> },
        <span class="comment">/* Disable monitoring for this context. */</span>
        { <span class="stringliteral">"monitor_interval"</span>, <span class="stringliteral">"0"</span> },
        <span class="comment">/* We don't need request/response, so don't use up ports. */</span>
        { <span class="stringliteral">"request_tcp_bind_request_port"</span>, <span class="stringliteral">"0"</span> },
        <span class="comment">/* We don't need MIM, so disable MIM receiver. */</span>
        { <span class="stringliteral">"mim_incoming_address"</span>, <span class="stringliteral">"0.0.0.0"</span> },
        <span class="comment">/* No need to cache topics. */</span>
        { <span class="stringliteral">"resolver_cache"</span>, <span class="stringliteral">"0"</span> },
        <span class="comment">/* End of list. */</span>
        { NULL, NULL }
};

<span class="keyword">static</span> option_entry_t ReceiverContextOption[] =
{
        <span class="comment">/* Force embedded mode for simplicity. */</span>
        { <span class="stringliteral">"operational_mode"</span>, <span class="stringliteral">"embedded"</span> },
        <span class="comment">/* Disable monitoring for this context. */</span>
        { <span class="stringliteral">"monitor_interval"</span>, <span class="stringliteral">"0"</span> },
        <span class="comment">/* We don't need request/response, so don't use up ports. */</span>
        { <span class="stringliteral">"request_tcp_bind_request_port"</span>, <span class="stringliteral">"0"</span> },
        <span class="comment">/* We don't need MIM, so disable MIM receiver. */</span>
        { <span class="stringliteral">"mim_incoming_address"</span>, <span class="stringliteral">"0.0.0.0"</span> },
        <span class="comment">/* No need to cache topics. */</span>
        { <span class="stringliteral">"resolver_cache"</span>, <span class="stringliteral">"0"</span> },
        <span class="comment">/* Force TTL=0. */</span>
        { <span class="stringliteral">"resolver_multicast_ttl"</span>, DEFAULT_MULTICAST_TTL },
        <span class="comment">/* Use a specific topic resolution address. */</span>
        { <span class="stringliteral">"resolver_multicast_address"</span>, DEFAULT_TOPIC_RESOLUTION_ADDRESS },
        <span class="comment">/* End of list. */</span>
        { NULL, NULL }
};

<span class="keyword">static</span> option_entry_t ReceiverContextOptionFixed[] =
{
        <span class="comment">/* Force embedded mode for simplicity. */</span>
        { <span class="stringliteral">"operational_mode"</span>, <span class="stringliteral">"embedded"</span> },
        <span class="comment">/* Disable monitoring for this context. */</span>
        { <span class="stringliteral">"monitor_interval"</span>, <span class="stringliteral">"0"</span> },
        <span class="comment">/* We don't need request/response, so don't use up ports. */</span>
        { <span class="stringliteral">"request_tcp_bind_request_port"</span>, <span class="stringliteral">"0"</span> },
        <span class="comment">/* We don't need MIM, so disable MIM receiver. */</span>
        { <span class="stringliteral">"mim_incoming_address"</span>, <span class="stringliteral">"0.0.0.0"</span> },
        <span class="comment">/* No need to cache topics. */</span>
        { <span class="stringliteral">"resolver_cache"</span>, <span class="stringliteral">"0"</span> },
        <span class="comment">/* End of list. */</span>
        { NULL, NULL }
};

<span class="keyword">static</span> option_entry_t SourceTopicOption[] =
{
        <span class="comment">/* Minimize memory used for LBT-RU retransmissions. */</span>
        { <span class="stringliteral">"transport_lbtru_transmission_window_size"</span>, <span class="stringliteral">"500000"</span> },
        <span class="comment">/* Minimize memory used for LBT-RM retransmissions. */</span>
        { <span class="stringliteral">"transport_lbtrm_transmission_window_size"</span>, <span class="stringliteral">"500000"</span> },
        <span class="comment">/* Force LBT-RM. */</span>
        { <span class="stringliteral">"transport"</span>, <span class="stringliteral">"lbtrm"</span> },
        <span class="comment">/* Force the LBT-RM address. */</span>
        { <span class="stringliteral">"transport_lbtrm_multicast_address"</span>, DEFAULT_LBTRM_ADDRESS },
        <span class="comment">/* End of list. */</span>
        { NULL, NULL }
};

<span class="keyword">static</span> option_entry_t ReceiverTopicOption[] =
{
        <span class="comment">/* End of list. */</span>
        { NULL, NULL }
};

<span class="keyword">static</span> option_entry_t WildcardReceiverOption[] =
{
        <span class="comment">/* End of list. */</span>
        { NULL, NULL }
};

<span class="keyword">const</span> <a class="code" href="structlbmmon__transport__func__t__stct.html" title="Transport module function pointer container.">lbmmon_transport_func_t</a> *
lbmmon_transport_lbmsnmp_module(<span class="keywordtype">void</span>)
{
        <span class="keywordflow">return</span> (&amp;LBMMON_TRANSPORT_LBMSNMP);
}

<span class="keywordtype">int</span>
lbmmon_transport_lbmsnmp_initsrc(<span class="keywordtype">void</span> * * TransportClientData, <span class="keyword">const</span> <span class="keywordtype">void</span> * TransportOptions)
{
        lbmmon_transport_lbmsnmp_src_t * data;
        <span class="keywordtype">int</span> rc;
        <span class="keyword">const</span> <span class="keywordtype">char</span> * ptr = (<span class="keyword">const</span> <span class="keywordtype">char</span> *) TransportOptions;
        <span class="keywordtype">char</span> key[512];
        <span class="keywordtype">char</span> value[512];
        <span class="keywordtype">char</span> config_file[512];
        <span class="keywordtype">char</span> topic[512];
        <span class="keywordtype">char</span> scope[512];
        <span class="keywordtype">char</span> option[512];
        option_entry_t * entry;

        memset(ErrorString, 0, <span class="keyword">sizeof</span>(ErrorString));
        data = malloc(<span class="keyword">sizeof</span>(lbmmon_transport_lbmsnmp_src_t));
        data-&gt;mContextAttributes = NULL;
        data-&gt;mContext = NULL;
        data-&gt;mTopicAttributes = NULL;
        data-&gt;mSource = NULL;
        data-&gt;mTopic = NULL;

        <span class="comment">/* Process any options */</span>
        memset(config_file, 0, <span class="keyword">sizeof</span>(config_file));
        strncpy(topic, DEFAULT_TOPIC, <span class="keyword">sizeof</span>(topic));
        <span class="keywordflow">while</span> ((ptr = <a class="code" href="lbmmon_8h.html#d10ac6fdaa7ba17b8efceca176c36070" title="Retrieve the next key/value pair from a semicolon-separated list.">lbmmon_next_key_value_pair</a>(ptr, key, <span class="keyword">sizeof</span>(key), value, <span class="keyword">sizeof</span>(value))) != NULL)
        {
                <span class="keywordflow">if</span> (strcasecmp(key, <span class="stringliteral">"config"</span>) == 0)
                {
                        strncpy(config_file, value, <span class="keyword">sizeof</span>(config_file));
                }
                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp(key, <span class="stringliteral">"topic"</span>) == 0)
                {
                        strncpy(topic, value, <span class="keyword">sizeof</span>(topic));
                }
        }

        <span class="comment">/* Initialize the context attributes */</span>
        rc = <a class="code" href="lbm_8h.html#04c6b79859bc07f4cc6c9008242e77f7" title="Create and fill a UM context attribute object with the initial default values.">lbm_context_attr_create_default</a>(&amp;(data-&gt;mContextAttributes));
        <span class="keywordflow">if</span> (rc == LBM_FAILURE)
        {
                snprintf(ErrorString,
                                 <span class="keyword">sizeof</span>(ErrorString),
                                 <span class="stringliteral">"lbm_context_attr_init() failed, %s"</span>,
                                 <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                <span class="keywordflow">return</span> (rc);
        }
        <span class="comment">/* Set the default context name */</span>
        rc = <a class="code" href="lbm_8h.html#f45c2cec5557da4057a0c96f305d6a40" title="Set an option for the given UM context attribute using a string.">lbm_context_attr_str_setopt</a>(data-&gt;mContextAttributes, <span class="stringliteral">"context_name"</span>, DEFAULT_CONTEXT_NAME);
        <span class="keywordflow">if</span> (rc == LBM_FAILURE)
        {
                snprintf(ErrorString,
                                 <span class="keyword">sizeof</span>(ErrorString),
                                 <span class="stringliteral">"lbm_context_attr_str_setopt() failed, %s"</span>,
                                 <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                <span class="keywordflow">return</span> (rc);
        }
        entry = &amp;SourceContextOption[0];
        <span class="keywordflow">while</span> (entry-&gt;option != NULL)
        {
                rc = <a class="code" href="lbm_8h.html#f45c2cec5557da4057a0c96f305d6a40" title="Set an option for the given UM context attribute using a string.">lbm_context_attr_str_setopt</a>(data-&gt;mContextAttributes, entry-&gt;option, entry-&gt;value);
                <span class="keywordflow">if</span> (rc == LBM_FAILURE)
                {
                        snprintf(ErrorString,
                                         <span class="keyword">sizeof</span>(ErrorString),
                                         <span class="stringliteral">"error setting option [context %s %s], %s"</span>,
                                         entry-&gt;option,
                                         entry-&gt;value,
                                         <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                        src_cleanup(data);
                        <span class="keywordflow">return</span> (rc);
                }
                entry++;
        }

        <span class="comment">/* Create the context */</span>
        <span class="keywordflow">if</span> (config_file[0] != <span class="charliteral">'\0'</span>)
        {
                <span class="comment">/* A config file was passed as an option. Use it to populate the context attributes. */</span>
                rc = <a class="code" href="lbmaux_8h.html#e7d92b1afb5b581a6b71a154448f89a7" title="Set attributes values in an lbm_context_attr_t object from a configuration file.">lbmaux_context_attr_setopt_from_file</a>(data-&gt;mContextAttributes, config_file);
                <span class="keywordflow">if</span> (rc != 0)
                {
                        snprintf(ErrorString,
                                         <span class="keyword">sizeof</span>(ErrorString),
                                         <span class="stringliteral">"lbmaux_context_attr_setopt_from_file() failed, %s"</span>,
                                         <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                        src_cleanup(data);
                        <span class="keywordflow">return</span> (-1);
                }
        }
        <span class="comment">/* Go back through the options, looking for any specific context options. */</span>
        ptr = (<span class="keyword">const</span> <span class="keywordtype">char</span> *) TransportOptions;
        <span class="keywordflow">while</span> ((ptr = <a class="code" href="lbmmon_8h.html#d10ac6fdaa7ba17b8efceca176c36070" title="Retrieve the next key/value pair from a semicolon-separated list.">lbmmon_next_key_value_pair</a>(ptr, key, <span class="keyword">sizeof</span>(key), value, <span class="keyword">sizeof</span>(value))) != NULL)
        {
                <span class="keywordflow">if</span> (sscanf(key, <span class="stringliteral">"%[a-zA-Z_]|%[a-zA-Z_]"</span>, scope, option) != 2)
                {
                        <span class="keywordflow">continue</span>;
                }
                <span class="keywordflow">if</span> (scope_is_valid(scope) == -1)
                {
                        snprintf(ErrorString,
                                         <span class="keyword">sizeof</span>(ErrorString),
                                         <span class="stringliteral">"invalid option scope [%s]"</span>,
                                         scope);
                        src_cleanup(data);
                        <span class="keywordflow">return</span> (-1);
                }
                <span class="keywordflow">if</span> (strcasecmp(scope, <span class="stringliteral">"context"</span>) == 0)
                {
                        rc = <a class="code" href="lbm_8h.html#f45c2cec5557da4057a0c96f305d6a40" title="Set an option for the given UM context attribute using a string.">lbm_context_attr_str_setopt</a>(data-&gt;mContextAttributes, option, value);
                        <span class="keywordflow">if</span> (rc == LBM_FAILURE)
                        {
                                snprintf(ErrorString,
                                                 <span class="keyword">sizeof</span>(ErrorString),
                                                 <span class="stringliteral">"invalid option [context %s %s], %s"</span>,
                                                 option,
                                                 value,
                                                 <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                                src_cleanup(data);
                                <span class="keywordflow">return</span> (rc);
                        }
                }
        }

        entry = &amp;SourceContextOptionFixed[0];
        <span class="keywordflow">while</span> (entry-&gt;option != NULL)
        {
                rc = <a class="code" href="lbm_8h.html#f45c2cec5557da4057a0c96f305d6a40" title="Set an option for the given UM context attribute using a string.">lbm_context_attr_str_setopt</a>(data-&gt;mContextAttributes, entry-&gt;option, entry-&gt;value);
                <span class="keywordflow">if</span> (rc == LBM_FAILURE)
                {
                        snprintf(ErrorString,
                                         <span class="keyword">sizeof</span>(ErrorString),
                                         <span class="stringliteral">"error setting option [context %s %s], %s"</span>,
                                         entry-&gt;option,
                                         entry-&gt;value,
                                         <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                        src_cleanup(data);
                        <span class="keywordflow">return</span> (rc);
                }
                entry++;
        }

        <span class="comment">/* Create the context */</span>
        rc = <a class="code" href="lbm_8h.html#8058947690bd0995bc2c59d4a61b462f" title="Create and initialize an lbm_context_t object.">lbm_context_create</a>(&amp;(data-&gt;mContext), data-&gt;mContextAttributes, NULL, NULL);
        <span class="keywordflow">if</span> (rc == LBM_FAILURE)
        {
                snprintf(ErrorString,
                                 <span class="keyword">sizeof</span>(ErrorString),
                                 <span class="stringliteral">"lbm_context_create() failed, %s"</span>,
                                 <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                src_cleanup(data);
                <span class="keywordflow">return</span> (rc);
        }

        <span class="comment">/* Initialize the source topic attributes */</span>
        rc = <a class="code" href="lbm_8h.html#c299cf26605e18261b812a43012b1c24" title="Create and fill a UM source topic attribute object with the initial default values...">lbm_src_topic_attr_create_default</a>(&amp;(data-&gt;mTopicAttributes));
        <span class="keywordflow">if</span> (rc == LBM_FAILURE)
        {
                snprintf(ErrorString,
                                 <span class="keyword">sizeof</span>(ErrorString),
                                 <span class="stringliteral">"lbm_src_topic_attr_create_default() failed, %s"</span>,
                                 <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                src_cleanup(data);
                <span class="keywordflow">return</span> (rc);
        }
        <span class="comment">/* Apply the default options first */</span>
        entry = &amp;SourceTopicOption[0];
        <span class="keywordflow">while</span> (entry-&gt;option != NULL)
        {
                rc = <a class="code" href="lbm_8h.html#422f330bf7ef3efdd7a9f17caabccb24" title="Set an option value within the given source topic attribute.">lbm_src_topic_attr_str_setopt</a>(data-&gt;mTopicAttributes, entry-&gt;option, entry-&gt;value);
                <span class="keywordflow">if</span> (rc == LBM_FAILURE)
                {
                        snprintf(ErrorString,
                                         <span class="keyword">sizeof</span>(ErrorString),
                                         <span class="stringliteral">"error setting option [source %s %s], %s"</span>,
                                         entry-&gt;option,
                                         entry-&gt;value,
                                         <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                        src_cleanup(data);
                        <span class="keywordflow">return</span> (rc);
                }
                entry++;
        }
        <span class="comment">/* Overwrite the transport options if they are Part of config file */</span>
        <span class="keywordflow">if</span> (config_file[0] != <span class="charliteral">'\0'</span>)
        {
                <span class="comment">/* A config file was passed as an option. Use it to populate the source topic attributes. */</span>
                rc = <a class="code" href="lbmaux_8h.html#7edbb9615d48f272bd1754e66d480a0b" title="Set attributes values in an lbm_src_topic_attr_t object from a configuration file...">lbmaux_src_topic_attr_setopt_from_file</a>(data-&gt;mTopicAttributes, config_file);
                <span class="keywordflow">if</span> (rc != 0)
                {
                        snprintf(ErrorString,
                                         <span class="keyword">sizeof</span>(ErrorString),
                                         <span class="stringliteral">"lbmaux_src_topic_attr_setopt_from_file() failed, %s"</span>,
                                         <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                        src_cleanup(data);
                        <span class="keywordflow">return</span> (-1);
                }
        }
        <span class="comment">/* Go back through the options, looking for any specific source options. */</span>
        ptr = (<span class="keyword">const</span> <span class="keywordtype">char</span> *) TransportOptions;
        <span class="keywordflow">while</span> ((ptr = <a class="code" href="lbmmon_8h.html#d10ac6fdaa7ba17b8efceca176c36070" title="Retrieve the next key/value pair from a semicolon-separated list.">lbmmon_next_key_value_pair</a>(ptr, key, <span class="keyword">sizeof</span>(key), value, <span class="keyword">sizeof</span>(value))) != NULL)
        {
                <span class="keywordflow">if</span> (sscanf(key, <span class="stringliteral">"%[a-zA-Z_]|%[a-zA-Z_]"</span>, scope, option) != 2)
                {
                        <span class="keywordflow">continue</span>;
                }
                <span class="keywordflow">if</span> (strcasecmp(scope, <span class="stringliteral">"source"</span>) == 0)
                {
                        rc = <a class="code" href="lbm_8h.html#422f330bf7ef3efdd7a9f17caabccb24" title="Set an option value within the given source topic attribute.">lbm_src_topic_attr_str_setopt</a>(data-&gt;mTopicAttributes, option, value);
                        <span class="keywordflow">if</span> (rc == LBM_FAILURE)
                        {
                                snprintf(ErrorString,
                                                 <span class="keyword">sizeof</span>(ErrorString),
                                                 <span class="stringliteral">"invalid option [source %s %s], %s"</span>,
                                                 option,
                                                 value,
                                                 <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                                src_cleanup(data);
                                <span class="keywordflow">return</span> (rc);
                        }
                }
        }
        <span class="comment">/* Create the topic */</span>
        rc = <a class="code" href="lbm_8h.html#1ba60407fa2bde0997aab6d5a5d2da1a" title="Turn a Topic string into a UM topic object usable by sources.">lbm_src_topic_alloc</a>(&amp;(data-&gt;mTopic), data-&gt;mContext, topic, data-&gt;mTopicAttributes);
        <span class="keywordflow">if</span> (rc == LBM_FAILURE)
        {
                snprintf(ErrorString,
                                 <span class="keyword">sizeof</span>(ErrorString),
                                 <span class="stringliteral">"lbm_src_topic_alloc() failed, %s"</span>,
                                 <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                src_cleanup(data);
                <span class="keywordflow">return</span> (rc);
        }

        <span class="comment">/* Create the source */</span>
        rc = <a class="code" href="lbm_8h.html#b8dd76271bf9df7a5f88476d431f523e" title="Create a UM source that will send messages to the given topic.">lbm_src_create</a>(&amp;(data-&gt;mSource), data-&gt;mContext, data-&gt;mTopic, NULL, NULL, NULL);
        <span class="keywordflow">if</span> (rc == LBM_FAILURE)
        {
                snprintf(ErrorString,
                                 <span class="keyword">sizeof</span>(ErrorString),
                                 <span class="stringliteral">"lbm_src_create() failed, %s"</span>,
                                 <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                src_cleanup(data);
                <span class="keywordflow">return</span> (rc);
        }

        <span class="comment">/* Pass back the lbmmon_transport_lbmsnmp_src_t created */</span>
        *TransportClientData = data;
        <span class="keywordflow">return</span> (0);
}

<span class="comment">/*                                                                              </span>
<span class="comment">        This function is called upon receipt of an LBM message (when operating as</span>
<span class="comment">        a statistics receiver).                                                                                                                                                         </span>
<span class="comment">*/</span>
<span class="keywordtype">int</span>
receive_callback(lbm_rcv_t * Receiver, <a class="code" href="structlbm__msg__t__stct.html" title="Structure that stores information about a received message.">lbm_msg_t</a> * Message, <span class="keywordtype">void</span> * ClientData)
{
        lbmmon_transport_lbmsnmp_rcv_t * rcv = (lbmmon_transport_lbmsnmp_rcv_t *) ClientData;
        lbmmon_transport_lbmsnmp_rcv_node_t * node;

        <span class="keywordflow">if</span> (Message-&gt;<a class="code" href="structlbm__msg__t__stct.html#b25327dc4b4ebf527106f6e708dbc05f">type</a> == <a class="code" href="lbm_8h.html#a47eb604db7dc9fd53f9650ed940e058">LBM_MSG_DATA</a>)
        {
                <span class="comment">/* A data message. We want to enqueue it for processing. */</span>
                lock_receiver(rcv);
                node = malloc(<span class="keyword">sizeof</span>(lbmmon_transport_lbmsnmp_rcv_node_t));
                <span class="comment">/*</span>
<span class="comment">                        Since we hold onto the message until it is actually processed,</span>
<span class="comment">                        let LBM know about it.</span>
<span class="comment">                */</span>
                <a class="code" href="lbm_8h.html#2b7788ff58f9e78bc89ea890dad0cccf" title="Instruct UM that the API is going to retain ownership of a UM message object.">lbm_msg_retain</a>(Message);
                node-&gt;mMessage = Message;
                node-&gt;mUsedBytes = 0;   <span class="comment">/* No data returned as yet */</span>

                <span class="comment">/* Link the message onto the queue */</span>
                node-&gt;mNext = NULL;
                <span class="keywordflow">if</span> (rcv-&gt;mTail != NULL)
                {
                        rcv-&gt;mTail-&gt;mNext = node;
                }
                <span class="keywordflow">else</span>
                {
                        rcv-&gt;mHead = node;
                }
                rcv-&gt;mTail = node;
                unlock_receiver(rcv);
        }
        <span class="keywordflow">return</span> (0);
}

<span class="keywordtype">int</span>
lbmmon_transport_lbmsnmp_initrcv(<span class="keywordtype">void</span> * * TransportClientData, <span class="keyword">const</span> <span class="keywordtype">void</span> * TransportOptions)
{
        lbmmon_transport_lbmsnmp_rcv_t * data;
        <span class="keywordtype">int</span> rc;
        <span class="keyword">const</span> <span class="keywordtype">char</span> * ptr = (<span class="keyword">const</span> <span class="keywordtype">char</span> *) TransportOptions;
        <span class="keywordtype">char</span> key[512];
        <span class="keywordtype">char</span> value[512];
        <span class="keywordtype">char</span> config_file[512];
        <span class="keywordtype">char</span> topic[512];
        <span class="keywordtype">char</span> wildcard_topic[512];
        <span class="keywordtype">char</span> scope[512];
        <span class="keywordtype">char</span> option[512];
        option_entry_t * entry;

        memset(ErrorString, 0, <span class="keyword">sizeof</span>(ErrorString));
        data = malloc(<span class="keyword">sizeof</span>(lbmmon_transport_lbmsnmp_rcv_t));

        data-&gt;mLockCreated = 0;
        data-&gt;mContextAttributes = NULL;
        data-&gt;mContext = NULL;
        data-&gt;mReceiver = NULL;
        data-&gt;mTopicAttributes = NULL;
        data-&gt;mTopic = NULL;
        data-&gt;mWildcardReceiverAttributes = NULL;
        data-&gt;mWildcardReceiver = NULL;
        data-&gt;mHead = NULL;
        data-&gt;mTail = NULL;

        <span class="comment">/* Process any options */</span>
        memset(config_file, 0, <span class="keyword">sizeof</span>(config_file));
        strncpy(topic, DEFAULT_TOPIC, <span class="keyword">sizeof</span>(topic));
        memset(wildcard_topic, 0, <span class="keyword">sizeof</span>(wildcard_topic));
        <span class="keywordflow">while</span> ((ptr = <a class="code" href="lbmmon_8h.html#d10ac6fdaa7ba17b8efceca176c36070" title="Retrieve the next key/value pair from a semicolon-separated list.">lbmmon_next_key_value_pair</a>(ptr, key, <span class="keyword">sizeof</span>(key), value, <span class="keyword">sizeof</span>(value))) != NULL)
        {
                <span class="keywordflow">if</span> (strcasecmp(key, <span class="stringliteral">"config"</span>) == 0)
                {
                        strncpy(config_file, value, <span class="keyword">sizeof</span>(config_file));
                }
                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp(key, <span class="stringliteral">"topic"</span>) == 0)
                {
                        strncpy(topic, value, <span class="keyword">sizeof</span>(topic));
                }
                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp(key, <span class="stringliteral">"wctopic"</span>) == 0)
                {
                        strncpy(wildcard_topic, value, <span class="keyword">sizeof</span>(wildcard_topic));
                }
        }

        <span class="comment">/* Initialize the context attributes */</span>
        rc = <a class="code" href="lbm_8h.html#04c6b79859bc07f4cc6c9008242e77f7" title="Create and fill a UM context attribute object with the initial default values.">lbm_context_attr_create_default</a>(&amp;(data-&gt;mContextAttributes));
        <span class="keywordflow">if</span> (rc == LBM_FAILURE)
        {
                snprintf(ErrorString,
                                 <span class="keyword">sizeof</span>(ErrorString),
                                 <span class="stringliteral">"lbm_context_attr_init() failed, %s"</span>,
                                 <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                rcv_cleanup(data);
                <span class="keywordflow">return</span> (rc);
        }
        <span class="comment">/* Set the default context name */</span>
        rc = <a class="code" href="lbm_8h.html#f45c2cec5557da4057a0c96f305d6a40" title="Set an option for the given UM context attribute using a string.">lbm_context_attr_str_setopt</a>(data-&gt;mContextAttributes, <span class="stringliteral">"context_name"</span>, DEFAULT_CONTEXT_NAME);
        <span class="keywordflow">if</span> (rc == LBM_FAILURE)
        {
                snprintf(ErrorString,
                                 <span class="keyword">sizeof</span>(ErrorString),
                                 <span class="stringliteral">"lbm_context_attr_str_setopt() failed, %s"</span>,
                                 <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                <span class="keywordflow">return</span> (rc);
        }
        <span class="comment">/* Populate with Default Values */</span>
        entry = &amp;ReceiverContextOption[0];
        <span class="keywordflow">while</span> (entry-&gt;option != NULL)
        {
                rc = <a class="code" href="lbm_8h.html#f45c2cec5557da4057a0c96f305d6a40" title="Set an option for the given UM context attribute using a string.">lbm_context_attr_str_setopt</a>(data-&gt;mContextAttributes, entry-&gt;option, entry-&gt;value);
                <span class="keywordflow">if</span> (rc == LBM_FAILURE)
                {
                        snprintf(ErrorString,
                                         <span class="keyword">sizeof</span>(ErrorString),
                                         <span class="stringliteral">"error setting option [context %s %s], %s"</span>,
                                         entry-&gt;option,
                                         entry-&gt;value,
                                         <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                        rcv_cleanup(data);
                        <span class="keywordflow">return</span> (rc);
                }
                entry++;
        }

        <span class="comment">/* Create the context */</span>
        <span class="keywordflow">if</span> (config_file[0] != <span class="charliteral">'\0'</span>)
        {
                <span class="comment">/* A config file was passed as an option. Use it to populate the context attributes. */</span>
                rc = <a class="code" href="lbmaux_8h.html#e7d92b1afb5b581a6b71a154448f89a7" title="Set attributes values in an lbm_context_attr_t object from a configuration file.">lbmaux_context_attr_setopt_from_file</a>(data-&gt;mContextAttributes, config_file);
                <span class="keywordflow">if</span> (rc != 0)
                {
                        snprintf(ErrorString,
                                         <span class="keyword">sizeof</span>(ErrorString),
                                         <span class="stringliteral">"lbmaux_context_attr_setopt_from_file() failed, %s"</span>,
                                         <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                        rcv_cleanup(data);
                        <span class="keywordflow">return</span> (-1);
                }
        }
        <span class="comment">/* Go back through the options, looking for any specific context options. */</span>
        ptr = (<span class="keyword">const</span> <span class="keywordtype">char</span> *) TransportOptions;
        <span class="keywordflow">while</span> ((ptr = <a class="code" href="lbmmon_8h.html#d10ac6fdaa7ba17b8efceca176c36070" title="Retrieve the next key/value pair from a semicolon-separated list.">lbmmon_next_key_value_pair</a>(ptr, key, <span class="keyword">sizeof</span>(key), value, <span class="keyword">sizeof</span>(value))) != NULL)
        {
                <span class="keywordflow">if</span> (sscanf(key, <span class="stringliteral">"%[a-zA-Z_]|%[a-zA-Z_]"</span>, scope, option) != 2)
                {
                        <span class="keywordflow">continue</span>;
                }
                <span class="keywordflow">if</span> (scope_is_valid(scope) == -1)
                {
                        snprintf(ErrorString,
                                         <span class="keyword">sizeof</span>(ErrorString),
                                         <span class="stringliteral">"invalid option scope [%s]"</span>,
                                         scope);
                        rcv_cleanup(data);
                        <span class="keywordflow">return</span> (-1);
                }
                <span class="keywordflow">if</span> (strcasecmp(scope, <span class="stringliteral">"context"</span>) == 0)
                {
                        rc = <a class="code" href="lbm_8h.html#f45c2cec5557da4057a0c96f305d6a40" title="Set an option for the given UM context attribute using a string.">lbm_context_attr_str_setopt</a>(data-&gt;mContextAttributes, option, value);
                        <span class="keywordflow">if</span> (rc == LBM_FAILURE)
                        {
                                snprintf(ErrorString,
                                                 <span class="keyword">sizeof</span>(ErrorString),
                                                 <span class="stringliteral">"invalid option [context %s %s], %s"</span>,
                                                 option,
                                                 value,
                                                 <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                                rcv_cleanup(data);
                                <span class="keywordflow">return</span> (rc);
                        }
                }
        }

        entry = &amp;ReceiverContextOptionFixed[0];
        <span class="keywordflow">while</span> (entry-&gt;option != NULL)
        {
                rc = <a class="code" href="lbm_8h.html#f45c2cec5557da4057a0c96f305d6a40" title="Set an option for the given UM context attribute using a string.">lbm_context_attr_str_setopt</a>(data-&gt;mContextAttributes, entry-&gt;option, entry-&gt;value);
                <span class="keywordflow">if</span> (rc == LBM_FAILURE)
                {
                        snprintf(ErrorString,
                                         <span class="keyword">sizeof</span>(ErrorString),
                                         <span class="stringliteral">"error setting option [context %s %s], %s"</span>,
                                         entry-&gt;option,
                                         entry-&gt;value,
                                         <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                        rcv_cleanup(data);
                        <span class="keywordflow">return</span> (rc);
                }
                entry++;
        }

        <span class="comment">/* Create the context */</span>
        rc = <a class="code" href="lbm_8h.html#8058947690bd0995bc2c59d4a61b462f" title="Create and initialize an lbm_context_t object.">lbm_context_create</a>(&amp;(data-&gt;mContext), data-&gt;mContextAttributes, NULL, NULL);
        <span class="keywordflow">if</span> (rc == LBM_FAILURE)
        {
                snprintf(ErrorString,
                                 <span class="keyword">sizeof</span>(ErrorString),
                                 <span class="stringliteral">"lbm_context_create() failed, %s"</span>,
                                 <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                rcv_cleanup(data);
                <span class="keywordflow">return</span> (rc);
        }

        <span class="comment">/* If a wildcard topic was specified, initialize the wildcard receiver attributes. */</span>
        <span class="keywordflow">if</span> (wildcard_topic[0] != <span class="charliteral">'\0'</span>)
        {
                rc = <a class="code" href="lbm_8h.html#5ebb6c37e8e27a5338bc786f10c05007" title="Create and fill a UM wildcard receiver attribute object with the initial default...">lbm_wildcard_rcv_attr_create_default</a>(&amp;(data-&gt;mWildcardReceiverAttributes));
                <span class="keywordflow">if</span> (rc == LBM_FAILURE)
                {
                        snprintf(ErrorString,
                                         <span class="keyword">sizeof</span>(ErrorString),
                                         <span class="stringliteral">"lbm_wildcard_rcv_attr_init() failed, %s"</span>,
                                         <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                        rcv_cleanup(data);
                        <span class="keywordflow">return</span> (rc);
                }
                <span class="keywordflow">if</span> (config_file[0] != <span class="charliteral">'\0'</span>)
                {
                        <span class="comment">/* A config file was passed as an option. Use it to populate the wildcard receiver attributes. */</span>
                        rc = <a class="code" href="lbmaux_8h.html#4427d2383bf4d2631ea2aa79e625bea1" title="Set attributes values in an lbm_wildcard_rcv_attr_t object from a configuration file...">lbmaux_wildcard_rcv_attr_setopt_from_file</a>(data-&gt;mWildcardReceiverAttributes, config_file);
                        <span class="keywordflow">if</span> (rc == LBM_FAILURE)
                        {
                                snprintf(ErrorString,
                                                 <span class="keyword">sizeof</span>(ErrorString),
                                                 <span class="stringliteral">"lbmaux_wildcard_rcv_attr_setopt_from_file() failed, %s"</span>,
                                                 <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                                rcv_cleanup(data);
                                <span class="keywordflow">return</span> (-1);
                        }
                }
                <span class="comment">/* Go back through the options, looking for any specific wildcard receiver options. */</span>
                ptr = (<span class="keyword">const</span> <span class="keywordtype">char</span> *) TransportOptions;
                <span class="keywordflow">while</span> ((ptr = <a class="code" href="lbmmon_8h.html#d10ac6fdaa7ba17b8efceca176c36070" title="Retrieve the next key/value pair from a semicolon-separated list.">lbmmon_next_key_value_pair</a>(ptr, key, <span class="keyword">sizeof</span>(key), value, <span class="keyword">sizeof</span>(value))) != NULL)
                {
                        <span class="keywordflow">if</span> (sscanf(key, <span class="stringliteral">"%[a-zA-Z_]|%[a-zA-Z_]"</span>, scope, option) != 2)
                        {
                                <span class="keywordflow">continue</span>;
                        }
                        <span class="keywordflow">if</span> (strcasecmp(scope, <span class="stringliteral">"wildcard_receiver"</span>) == 0)
                        {
                                rc = <a class="code" href="lbm_8h.html#cee962d050b7c17a8e92445612d7b404" title="Set an option value within the given wildcard receiver attribute.">lbm_wildcard_rcv_attr_str_setopt</a>(data-&gt;mWildcardReceiverAttributes, option, value);
                                <span class="keywordflow">if</span> (rc == LBM_FAILURE)
                                {
                                        snprintf(ErrorString,
                                                         <span class="keyword">sizeof</span>(ErrorString),
                                                         <span class="stringliteral">"invalid option [wildcard_receiver %s %s], %s"</span>,
                                                         option,
                                                         value,
                                                         <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                                        rcv_cleanup(data);
                                        <span class="keywordflow">return</span> (rc);
                                }
                        }
                }
                entry = &amp;WildcardReceiverOption[0];
                <span class="keywordflow">while</span> (entry-&gt;option != NULL)
                {
                        rc = <a class="code" href="lbm_8h.html#cee962d050b7c17a8e92445612d7b404" title="Set an option value within the given wildcard receiver attribute.">lbm_wildcard_rcv_attr_str_setopt</a>(data-&gt;mWildcardReceiverAttributes, entry-&gt;option, entry-&gt;value);
                        <span class="keywordflow">if</span> (rc == LBM_FAILURE)
                        {
                                snprintf(ErrorString,
                                                 <span class="keyword">sizeof</span>(ErrorString),
                                                 <span class="stringliteral">"error setting option [wildcard_receiver %s %s], %s"</span>,
                                                 entry-&gt;option,
                                                 entry-&gt;value,
                                                 <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                                rcv_cleanup(data);
                                <span class="keywordflow">return</span> (rc);
                        }
                }
                entry++;
        }

        <span class="comment">/* Initialize and set the receiver topic attributes. */</span>
        rc = <a class="code" href="lbm_8h.html#a0b62bc911b175ff51236ecf101d0d93" title="Create and fill a UM receiver topic attribute object with the initial default values...">lbm_rcv_topic_attr_create_default</a>(&amp;(data-&gt;mTopicAttributes));
        <span class="keywordflow">if</span> (rc == LBM_FAILURE)
        {
                snprintf(ErrorString,
                                 <span class="keyword">sizeof</span>(ErrorString),
                                 <span class="stringliteral">"lbm_rcv_topic_attr_init() failed, %s"</span>,
                                 <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                rcv_cleanup(data);
                <span class="keywordflow">return</span> (rc);
        }
        <span class="keywordflow">if</span> (config_file[0] != <span class="charliteral">'\0'</span>)
        {
                <span class="comment">/* A config file was passed as an option. Use it to populate the receiver topic attributes. */</span>
                rc = <a class="code" href="lbmaux_8h.html#5c6d7294c9f3dfd3e1ef78d00fa927a3" title="Set attributes values in an lbm_rcv_topic_attr_t object from a configuration file...">lbmaux_rcv_topic_attr_setopt_from_file</a>(data-&gt;mTopicAttributes, config_file);
                <span class="keywordflow">if</span> (rc == LBM_FAILURE)
                {
                        snprintf(ErrorString,
                                         <span class="keyword">sizeof</span>(ErrorString),
                                         <span class="stringliteral">"lbmaux_rcv_topic_attr_setopt_from_file() failed, %s"</span>,
                                         <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                        rcv_cleanup(data);
                        <span class="keywordflow">return</span> (-1);
                }
        }
        <span class="comment">/* Go back through the options, looking for any specific receiver options. */</span>
        ptr = (<span class="keyword">const</span> <span class="keywordtype">char</span> *) TransportOptions;
        <span class="keywordflow">while</span> ((ptr = <a class="code" href="lbmmon_8h.html#d10ac6fdaa7ba17b8efceca176c36070" title="Retrieve the next key/value pair from a semicolon-separated list.">lbmmon_next_key_value_pair</a>(ptr, key, <span class="keyword">sizeof</span>(key), value, <span class="keyword">sizeof</span>(value))) != NULL)
        {
                <span class="keywordflow">if</span> (sscanf(key, <span class="stringliteral">"%[a-zA-Z_]|%[a-zA-Z_]"</span>, scope, option) != 2)
                {
                        <span class="keywordflow">continue</span>;
                }
                <span class="keywordflow">if</span> (strcasecmp(scope, <span class="stringliteral">"receiver"</span>) == 0)
                {
                        rc = <a class="code" href="lbm_8h.html#fabe075e34f7f712f09f710df87d9164" title="Set an option value within the given receiver topic attribute.">lbm_rcv_topic_attr_str_setopt</a>(data-&gt;mTopicAttributes, option, value);
                        <span class="keywordflow">if</span> (rc == LBM_FAILURE)
                        {
                                snprintf(ErrorString,
                                                 <span class="keyword">sizeof</span>(ErrorString),
                                                 <span class="stringliteral">"invalid option [receiver %s %s], %s"</span>,
                                                 option,
                                                 value,
                                                 <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                                rcv_cleanup(data);
                                <span class="keywordflow">return</span> (rc);
                        }
                }
        }
        entry = &amp;ReceiverTopicOption[0];
        <span class="keywordflow">while</span> (entry-&gt;option != NULL)
        {
                rc = <a class="code" href="lbm_8h.html#fabe075e34f7f712f09f710df87d9164" title="Set an option value within the given receiver topic attribute.">lbm_rcv_topic_attr_str_setopt</a>(data-&gt;mTopicAttributes, entry-&gt;option, entry-&gt;value);
                <span class="keywordflow">if</span> (rc == LBM_FAILURE)
                {
                        snprintf(ErrorString,
                                         <span class="keyword">sizeof</span>(ErrorString),
                                         <span class="stringliteral">"error setting option [receiver %s %s], %s"</span>,
                                         entry-&gt;option,
                                         entry-&gt;value,
                                         <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                        rcv_cleanup(data);
                        <span class="keywordflow">return</span> (rc);
                }
                entry++;
        }

        <span class="comment">/* For a non-wildcard topic, lookup the topic. */</span>
        <span class="keywordflow">if</span> (wildcard_topic[0] == <span class="charliteral">'\0'</span>)
        {
                rc = <a class="code" href="lbm_8h.html#3de8a6a659896f76475c453683db4e18" title="Turn a Topic string into a UM topic object usable by receivers.">lbm_rcv_topic_lookup</a>(&amp;(data-&gt;mTopic), data-&gt;mContext, topic, data-&gt;mTopicAttributes);
                <span class="keywordflow">if</span> (rc == LBM_FAILURE)
                {
                        snprintf(ErrorString,
                                         <span class="keyword">sizeof</span>(ErrorString),
                                         <span class="stringliteral">"lbm_rcv_topic_lookup() failed, %s"</span>,
                                         <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                        rcv_cleanup(data);
                        <span class="keywordflow">return</span> (rc);
                }
        }

<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>        InitializeCriticalSection(&amp;(data-&gt;mLock));
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        pthread_mutex_init(&amp;(data-&gt;mLock), NULL);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>        data-&gt;mLockCreated = 1;
        lock_receiver(data);
        <span class="keywordflow">if</span> (wildcard_topic[0] != <span class="charliteral">'\0'</span>)
        {
                <span class="comment">/* Wildcard topic, create a wildcard receiver */</span>
                rc = <a class="code" href="lbm_8h.html#5b5d52f6b87499213757b73b09bc8160" title="Create a UM wildcard receiver that will receive messages sent to any topic matching...">lbm_wildcard_rcv_create</a>(&amp;(data-&gt;mWildcardReceiver),
                                                                         data-&gt;mContext,
                                                                         wildcard_topic,
                                                                         data-&gt;mTopicAttributes,
                                                                         data-&gt;mWildcardReceiverAttributes,
                                                                         receive_callback,
                                                                         data,
                                                                         NULL);
        }
        <span class="keywordflow">else</span>
        {
                <span class="comment">/* Non-wildcard topic, create a normal receiver */</span>
                rc = <a class="code" href="lbm_8h.html#a7491c50fefbc2b70f8035fce7ac1477" title="Create a UM receiver that will receive messages sent to the given topic.">lbm_rcv_create</a>(&amp;(data-&gt;mReceiver),
                                                        data-&gt;mContext,
                                                        data-&gt;mTopic,
                                                        receive_callback,
                                                        data,
                                                        NULL);
        }
        <span class="keywordflow">if</span> (rc == LBM_FAILURE)
        {
                snprintf(ErrorString,
                                 <span class="keyword">sizeof</span>(ErrorString),
                                 <span class="stringliteral">"lbm_wildcard_rcv_create()/lbm_rcv_create() failed, %s"</span>,
                                 <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
                unlock_receiver(data);
                rcv_cleanup(data);
                <span class="keywordflow">return</span> (rc);
        }

        <span class="comment">/* Pass back the lbmmon_transport_lbmsnmp_rcv_t created */</span>
        *TransportClientData = data;
        unlock_receiver(data);
        <span class="keywordflow">return</span> (0);
}

<span class="keywordtype">int</span>
lbmmon_transport_lbmsnmp_send(<span class="keyword">const</span> <span class="keywordtype">char</span> * Data, <span class="keywordtype">size_t</span> Length, <span class="keywordtype">void</span> * TransportClientData)
{
        lbmmon_transport_lbmsnmp_src_t * src;
        <span class="keywordtype">int</span> rc;

        <span class="keywordflow">if</span> ((Data == NULL) || (TransportClientData == NULL))
        {
                strncpy(ErrorString, <span class="stringliteral">"Invalid argument"</span>, <span class="keyword">sizeof</span>(ErrorString));
                <span class="keywordflow">return</span> (-1);
        }
        src = (lbmmon_transport_lbmsnmp_src_t *) TransportClientData;
        rc = <a class="code" href="lbm_8h.html#91f4b9cb04fe1323ec56833211cc5cb7" title="Send a message to the topic associated with a UM source.">lbm_src_send</a>(src-&gt;mSource, Data, Length, 0);
        <span class="keywordflow">if</span> (rc == LBM_FAILURE)
        {
                snprintf(ErrorString,
                                 <span class="keyword">sizeof</span>(ErrorString),
                                 <span class="stringliteral">"lbm_src_send() failed, %s"</span>,
                                 <a class="code" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055" title="Return an ASCII string containing the error message last encountered by this thread...">lbm_errmsg</a>());
        }
        <span class="keywordflow">return</span> (rc);
}

<span class="keywordtype">int</span>
lbmmon_transport_lbmsnmp_receive(<span class="keywordtype">char</span> * Data, <span class="keywordtype">size_t</span> * Length, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> TimeoutMS, <span class="keywordtype">void</span> * TransportClientData)
{
        lbmmon_transport_lbmsnmp_rcv_t * rcv = (lbmmon_transport_lbmsnmp_rcv_t *) TransportClientData;
        lbmmon_transport_lbmsnmp_rcv_node_t * node;
        <span class="keywordtype">int</span> rc = 0;
        <span class="keywordtype">size_t</span> length_remaining;
<span class="preprocessor">#if defined(_WIN32)</span>
<span class="preprocessor"></span><span class="preprocessor">#elif defined(__TANDEM)</span>
<span class="preprocessor"></span>        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sleep_sec;
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sleep_usec;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        <span class="keyword">struct </span>timespec ivl;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
        <span class="keywordflow">if</span> ((Data == NULL) || (Length == NULL) || (TransportClientData == NULL))
        {
                strncpy(ErrorString, <span class="stringliteral">"Invalid argument"</span>, <span class="keyword">sizeof</span>(ErrorString));
                <span class="keywordflow">return</span> (-1);
        }
        <span class="keywordflow">if</span> (*Length == 0)
        {
                <span class="keywordflow">return</span> (0);
        }
        lock_receiver(rcv);
        <span class="keywordflow">if</span> (rcv-&gt;mHead != NULL)
        {
                <span class="comment">/* Queue is non-empty. Pull the first message from the queue. */</span>
                node = rcv-&gt;mHead;
                length_remaining = node-&gt;mMessage-&gt;len - node-&gt;mUsedBytes;
                <span class="keywordflow">if</span> (*Length &gt;= length_remaining)
                {
                        <span class="comment">/* We can transfer the rest of the message */</span>
                        memcpy(Data, node-&gt;mMessage-&gt;data + node-&gt;mUsedBytes, length_remaining);
                        *Length = length_remaining;
                        rc = 0;
                        <span class="comment">/* We're done with the LBM message, so let LBM know. */</span>
                        <a class="code" href="lbm_8h.html#a5fc1eb324a55b8c800c31460b0f0116" title="Delete a UM message object.">lbm_msg_delete</a>(node-&gt;mMessage);
                        <span class="comment">/* Unlink the node from the queue */</span>
                        rcv-&gt;mHead = node-&gt;mNext;
                        <span class="keywordflow">if</span> (rcv-&gt;mHead == NULL)
                        {
                                rcv-&gt;mTail = NULL;
                        }
                        free(node);
                }
                <span class="keywordflow">else</span>
                {
                        <span class="comment">/* Can only transfer part of the message */</span>
                        memcpy(Data, node-&gt;mMessage-&gt;data + node-&gt;mUsedBytes, *Length);
                        node-&gt;mUsedBytes -= *Length;
                        rc = 0;
                }
                unlock_receiver(rcv);
        }
        <span class="keywordflow">else</span>
        {
                unlock_receiver(rcv);
                <span class="comment">/* Sleep for wait time */</span>
<span class="preprocessor">#define NANOSECONDS_PER_SECOND 1000000000</span>
<span class="preprocessor"></span><span class="preprocessor">#define MICROSECONDS_PER_SECOND 1000000</span>
<span class="preprocessor"></span><span class="preprocessor">#define MILLISECONDS_PER_SECOND 1000</span>
<span class="preprocessor"></span><span class="preprocessor">#define NANOSECONDS_PER_MILLISECOND (NANOSECONDS_PER_SECOND / MILLISECONDS_PER_SECOND)</span>
<span class="preprocessor"></span><span class="preprocessor">#define MICROSECONDS_PER_MILLISECOND (MICROSECONDS_PER_SECOND / MILLISECONDS_PER_SECOND)</span>
<span class="preprocessor"></span><span class="preprocessor">#if defined(_WIN32)</span>
<span class="preprocessor"></span>                Sleep(TimeoutMS);
<span class="preprocessor">#elif defined(__TANDEM)</span>
<span class="preprocessor"></span>                sleep_sec = TimeoutMS / MILLISECONDS_PER_SECOND;
                sleep_usec = (TimeoutMS % MILLISECONDS_PER_SECOND) * MICROSECONDS_PER_MILLISECOND;
                <span class="keywordflow">if</span> (sleep_usec &gt; 0)
                {
                        usleep(sleep_usec);
                }
                <span class="keywordflow">if</span> (sleep_sec &gt; 0)
                {
                        sleep(sleep_sec);
                }
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>                ivl.tv_sec = TimeoutMS / MILLISECONDS_PER_SECOND;
                ivl.tv_nsec = (TimeoutMS % MILLISECONDS_PER_SECOND) * NANOSECONDS_PER_MILLISECOND;
                nanosleep(&amp;ivl, NULL);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>                rc = 1;
        }
        <span class="keywordflow">return</span> (rc);
}

<span class="keywordtype">void</span>
src_cleanup(lbmmon_transport_lbmsnmp_src_t * Data)
{
        <span class="keywordflow">if</span> (Data-&gt;mSource != NULL)
        {
                <a class="code" href="lbm_8h.html#29d45db8f76835b4ae78f4568c25712f" title="Delete a UM source object.">lbm_src_delete</a>(Data-&gt;mSource);
                Data-&gt;mSource = NULL;
        }
        Data-&gt;mTopic = NULL;
        <span class="keywordflow">if</span> (Data-&gt;mTopicAttributes != NULL)
        {
                <a class="code" href="lbm_8h.html#cb24cc75476206c155b00c4994aece85" title="Delete a source topic attribute object.">lbm_src_topic_attr_delete</a>(Data-&gt;mTopicAttributes);
                Data-&gt;mTopicAttributes = NULL;
        }
        <span class="keywordflow">if</span> (Data-&gt;mContext != NULL)
        {
                <a class="code" href="lbm_8h.html#962bfceb336c65191ba08497ac70602b" title="Delete a UM context object.">lbm_context_delete</a>(Data-&gt;mContext);
                Data-&gt;mContext = NULL;
        }
        <span class="keywordflow">if</span> (Data-&gt;mContextAttributes != NULL)
        {
                <a class="code" href="lbm_8h.html#9c0a3c1f4a8854d8ec5585392c817c85" title="Delete a UM context attribute object.">lbm_context_attr_delete</a>(Data-&gt;mContextAttributes);
                Data-&gt;mContextAttributes = NULL;
        }
        free(Data);
}

<span class="keywordtype">int</span>
lbmmon_transport_lbmsnmp_src_finish(<span class="keywordtype">void</span> * TransportClientData)
{
        lbmmon_transport_lbmsnmp_src_t * src;

        <span class="keywordflow">if</span> (TransportClientData == NULL)
        {
                strncpy(ErrorString, <span class="stringliteral">"Invalid argument"</span>, <span class="keyword">sizeof</span>(ErrorString));
                <span class="keywordflow">return</span> (-1);
        }
        src = (lbmmon_transport_lbmsnmp_src_t *) TransportClientData;
        src_cleanup(src);
        <span class="keywordflow">return</span> (0);
}

<span class="keywordtype">void</span>
rcv_cleanup(lbmmon_transport_lbmsnmp_rcv_t * Data)
{
        lbmmon_transport_lbmsnmp_rcv_node_t * node;
        lbmmon_transport_lbmsnmp_rcv_node_t * next;

        <span class="comment">/* Stop the receiver to prevent any more incoming messages */</span>
        <span class="keywordflow">if</span> (Data-&gt;mWildcardReceiver != NULL)
        {
                <a class="code" href="lbm_8h.html#64407f3874012efaebcba322ea6d229d" title="Delete a UM wildcard receiver object.">lbm_wildcard_rcv_delete</a>(Data-&gt;mWildcardReceiver);
                Data-&gt;mWildcardReceiver = NULL;
        }
        <span class="keywordflow">if</span> (Data-&gt;mWildcardReceiverAttributes != NULL)
        {
                <a class="code" href="lbm_8h.html#e9ec474237895a81cf15a4e14619cd25" title="Delete a wildcard receiver attribute object.">lbm_wildcard_rcv_attr_delete</a>(Data-&gt;mWildcardReceiverAttributes);
                Data-&gt;mWildcardReceiverAttributes = NULL;
        }
        <span class="keywordflow">if</span> (Data-&gt;mReceiver != NULL)
        {
                <a class="code" href="lbm_8h.html#8d5e8713f5ae776330b23a1e371f934d" title="Delete a UM receiver object.">lbm_rcv_delete</a>(Data-&gt;mReceiver);
                Data-&gt;mReceiver = NULL;
        }
        <span class="keywordflow">if</span> (Data-&gt;mTopicAttributes != NULL)
        {
                <a class="code" href="lbm_8h.html#f70d14c26efadade6ad1e22d254f4e1b" title="Delete a receiver topic attribute object.">lbm_rcv_topic_attr_delete</a>(Data-&gt;mTopicAttributes);
                Data-&gt;mTopicAttributes = NULL;
        }
        Data-&gt;mTopic = NULL;

        <span class="comment">/* Lock the receiver */</span>
        <span class="keywordflow">if</span> (Data-&gt;mLockCreated != 0)
        {
                lock_receiver(Data);
        }

        <span class="comment">/* Delete the context to really make sure no more messages come in */</span>
        <span class="keywordflow">if</span> (Data-&gt;mContext != NULL)
        {
                <a class="code" href="lbm_8h.html#962bfceb336c65191ba08497ac70602b" title="Delete a UM context object.">lbm_context_delete</a>(Data-&gt;mContext);
                Data-&gt;mContext = NULL;
        }
        <span class="keywordflow">if</span> (Data-&gt;mContextAttributes != NULL)
        {
                <a class="code" href="lbm_8h.html#9c0a3c1f4a8854d8ec5585392c817c85" title="Delete a UM context attribute object.">lbm_context_attr_delete</a>(Data-&gt;mContextAttributes);
                Data-&gt;mContextAttributes = NULL;
        }

        <span class="comment">/* Clean out the queue */</span>
        node = Data-&gt;mHead;
        <span class="keywordflow">while</span> (node != NULL)
        {
                <span class="comment">/* Let LBM know we're done with the message */</span>
                <a class="code" href="lbm_8h.html#a5fc1eb324a55b8c800c31460b0f0116" title="Delete a UM message object.">lbm_msg_delete</a>(node-&gt;mMessage);
                next = node-&gt;mNext;
                free(node);
                node = next;
        }

        <span class="keywordflow">if</span> (Data-&gt;mLockCreated)
        {
                unlock_receiver(Data);
<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>                DeleteCriticalSection(&amp;(Data-&gt;mLock));
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>                pthread_mutex_destroy(&amp;(Data-&gt;mLock));
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>        }

        free(Data);
}

<span class="keywordtype">int</span>
lbmmon_transport_lbmsnmp_rcv_finish(<span class="keywordtype">void</span> * TransportClientData)
{
        lbmmon_transport_lbmsnmp_rcv_t * rcv;

        <span class="keywordflow">if</span> (TransportClientData == NULL)
        {
                strncpy(ErrorString, <span class="stringliteral">"Invalid argument"</span>, <span class="keyword">sizeof</span>(ErrorString));
                <span class="keywordflow">return</span> (-1);
        }
        rcv = (lbmmon_transport_lbmsnmp_rcv_t *) TransportClientData;
        rcv_cleanup(rcv);
        <span class="keywordflow">return</span> (0);
}

<span class="keywordtype">void</span>
lock_receiver(lbmmon_transport_lbmsnmp_rcv_t * Receiver)
{
<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>        EnterCriticalSection(&amp;(Receiver-&gt;mLock));
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        pthread_mutex_lock(&amp;(Receiver-&gt;mLock));
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>}

<span class="keywordtype">void</span>
unlock_receiver(lbmmon_transport_lbmsnmp_rcv_t * Receiver)
{
<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>        LeaveCriticalSection(&amp;(Receiver-&gt;mLock));
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        pthread_mutex_unlock(&amp;(Receiver-&gt;mLock));
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>}

<span class="keyword">const</span> <span class="keywordtype">char</span> *
lbmmon_transport_lbmsnmp_errmsg(<span class="keywordtype">void</span>)
{
        <span class="keywordflow">return</span> (ErrorString);
}

<span class="keywordtype">int</span>
scope_is_valid(<span class="keyword">const</span> <span class="keywordtype">char</span> * Scope)
{
        <span class="keywordflow">if</span> (strcasecmp(Scope, <span class="stringliteral">"context"</span>) == 0)
        {
                <span class="keywordflow">return</span> (0);
        }
        <span class="keywordflow">if</span> (strcasecmp(Scope, <span class="stringliteral">"source"</span>) == 0)
        {
                <span class="keywordflow">return</span> (0);
        }
        <span class="keywordflow">if</span> (strcasecmp(Scope, <span class="stringliteral">"receiver"</span>) == 0)
        {
                <span class="keywordflow">return</span> (0);
        }
        <span class="keywordflow">if</span> (strcasecmp(Scope, <span class="stringliteral">"event_queue"</span>) == 0)
        {
                <span class="keywordflow">return</span> (0);
        }
        <span class="keywordflow">return</span> (-1);
}

</pre></div> <hr size="1"><address style="text-align: right;"><small>Generated on Thu Mar 6 13:11:15 2014 for LBM API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
<script type="text/javascript">highlight();</script>
</html>
