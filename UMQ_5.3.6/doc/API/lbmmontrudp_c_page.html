<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>LBM API: Source code for lbmmontrudp.c</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
	<script type="text/javascript" src="../Search/highlight.js"></script>
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="lbmmon_examples.html">LBMMON Example source code</a>&nbsp;&raquo&nbsp;<a class="el" href="lbmmon_udp_transport.html">LBMMON UDP transport module</a></div>
<h1><a class="anchor" name="lbmmontrudp_c_page">Source code for lbmmontrudp.c</a></h1><div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment">  All of the documentation and software included in this and any</span>
<span class="comment">  other Informatica Corporation Ultra Messaging Releases</span>
<span class="comment">  Copyright (C) Informatica Corporation. All rights reserved.</span>
<span class="comment">  </span>
<span class="comment">  Redistribution and use in source and binary forms, with or without</span>
<span class="comment">  modification, are permitted only as covered by the terms of a</span>
<span class="comment">  valid software license agreement with Informatica Corporation.</span>
<span class="comment"></span>
<span class="comment">  Copyright (C) 2004-2014, Informatica Corporation. All Rights Reserved.</span>
<span class="comment"></span>
<span class="comment">  THE SOFTWARE IS PROVIDED "AS IS" AND INFORMATICA DISCLAIMS ALL WARRANTIES </span>
<span class="comment">  EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY IMPLIED WARRANTIES OF </span>
<span class="comment">  NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR </span>
<span class="comment">  PURPOSE.  INFORMATICA DOES NOT WARRANT THAT USE OF THE SOFTWARE WILL BE </span>
<span class="comment">  UNINTERRUPTED OR ERROR-FREE.  INFORMATICA SHALL NOT, UNDER ANY CIRCUMSTANCES, BE </span>
<span class="comment">  LIABLE TO LICENSEE FOR LOST PROFITS, CONSEQUENTIAL, INCIDENTAL, SPECIAL OR </span>
<span class="comment">  INDIRECT DAMAGES ARISING OUT OF OR RELATED TO THIS AGREEMENT OR THE </span>
<span class="comment">  TRANSACTIONS CONTEMPLATED HEREUNDER, EVEN IF INFORMATICA HAS BEEN APPRISED OF </span>
<span class="comment">  THE LIKELIHOOD OF SUCH DAMAGES.</span>
<span class="comment">  </span>
<span class="comment">*/</span>

<span class="preprocessor">#ifdef __VOS__</span>
<span class="preprocessor"></span><span class="preprocessor">#define _POSIX_C_SOURCE 200112L</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/time.h&gt;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;time.h&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;limits.h&gt;</span>
<span class="preprocessor">#include &lt;errno.h&gt;</span>
<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span><span class="preprocessor">        #include &lt;winsock2.h&gt;</span>
<span class="preprocessor">        #include &lt;ws2tcpip.h&gt;</span>
<span class="preprocessor">        #define strcasecmp stricmp</span>
<span class="preprocessor"></span><span class="preprocessor">        #define snprintf _snprintf</span>
<span class="preprocessor"></span>        <span class="keyword">typedef</span> <span class="keywordtype">int</span> ssize_t;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">        #include "config.h"</span>
<span class="preprocessor">        #include &lt;unistd.h&gt;</span>
<span class="preprocessor">        #if defined(__TANDEM)</span>
<span class="preprocessor"></span><span class="preprocessor">                #if defined(HAVE_TANDEM_SPT)</span>
<span class="preprocessor"></span><span class="preprocessor">                        #include &lt;ktdmtyp.h&gt;</span>
<span class="preprocessor">                        #include &lt;spthread.h&gt;</span>
<span class="preprocessor">                #else</span>
<span class="preprocessor"></span><span class="preprocessor">                        #include &lt;pthread.h&gt;</span>
<span class="preprocessor">                #endif</span>
<span class="preprocessor"></span><span class="preprocessor">        #else</span>
<span class="preprocessor"></span><span class="preprocessor">                #include &lt;pthread.h&gt;</span>
<span class="preprocessor">        #endif</span>
<span class="preprocessor"></span><span class="preprocessor">        #include &lt;strings.h&gt;</span>
<span class="preprocessor">        #include &lt;sys/socket.h&gt;</span>
<span class="preprocessor">        #include &lt;netinet/in.h&gt;</span>
<span class="preprocessor">        #include &lt;arpa/inet.h&gt;</span>
<span class="preprocessor">        #include &lt;unistd.h&gt;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span><span class="preprocessor">#if defined(__VMS)</span>
<span class="preprocessor"></span>        <span class="keyword">typedef</span> <span class="keywordtype">int</span> socklen_t;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;lbm/lbmmon.h&gt;</span>
<span class="preprocessor">#include &lt;lbm/lbmmontrudp.h&gt;</span>

<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span><span class="preprocessor">        #define LBMMON_INVALID_HANDLE INVALID_SOCKET</span>
<span class="preprocessor"></span><span class="preprocessor">        #define LBMMON_SOCKET_ERROR SOCKET_ERROR</span>
<span class="preprocessor"></span><span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">        #define LBMMON_INVALID_HANDLE -1</span>
<span class="preprocessor"></span><span class="preprocessor">        #define LBMMON_SOCKET_ERROR -1</span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span><span class="preprocessor">#ifndef INADDR_NONE</span>
<span class="preprocessor"></span><span class="preprocessor">        #define INADDR_NONE ((in_addr_t) 0xffffffff)</span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="comment">/*                                                                              </span>
<span class="comment">        Package all of the needed function pointers for this module into a</span>
<span class="comment">        lbmmon_transport_func_t structure.                                                                                                                                                              </span>
<span class="comment">*/</span>
<span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="structlbmmon__transport__func__t__stct.html" title="Transport module function pointer container.">lbmmon_transport_func_t</a> LBMMON_TRANSPORT_UDP =
{
        lbmmon_transport_udp_initsrc,
        lbmmon_transport_udp_initrcv,
        lbmmon_transport_udp_send,
        lbmmon_transport_udp_receive,
        lbmmon_transport_udp_src_finish,
        lbmmon_transport_udp_rcv_finish,
        lbmmon_transport_udp_errmsg
};

<span class="comment">/*                                                                              </span>
<span class="comment">        For a statistics source, one of these gets returned as the TransportClientData.                                                                                                                                                         </span>
<span class="comment">*/</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span>
{
        <span class="comment">/* Socket used to send a statistics packet */</span>
<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>        SOCKET mSocket;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        <span class="keywordtype">int</span> mSocket;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>        <span class="comment">/* Peer socket address */</span>
        <span class="keyword">struct </span>sockaddr_in mPeer;
        <span class="comment">/* Mode */</span>
        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> mMode;
} lbmmon_transport_udp_src_t;

<span class="preprocessor">#define MODE_UNICAST 0</span>
<span class="preprocessor"></span><span class="preprocessor">#define MODE_BROADCAST 1</span>
<span class="preprocessor"></span><span class="preprocessor">#define MODE_MULTICAST 2</span>
<span class="preprocessor"></span>
<span class="comment">/*</span>
<span class="comment">        A queue of incoming statistics packets is maintained. This describes each </span>
<span class="comment">        entry in the queue.</span>
<span class="comment">*/</span>
<span class="keyword">struct </span>lbmmon_transport_udp_rcv_node_t_stct
{
        <span class="comment">/* Pointer to the message */</span>
        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * mMessage;
        <span class="comment">/* Length of the message */</span>
        <span class="keywordtype">size_t</span> mMessageLength;
        <span class="comment">/* Number of bytes of the message returned to caller */</span>
        <span class="keywordtype">size_t</span> mUsedBytes;
        <span class="comment">/* Next entry in the queue */</span>
        <span class="keyword">struct </span>lbmmon_transport_udp_rcv_node_t_stct * mNext;
};
<span class="keyword">typedef</span> <span class="keyword">struct </span>lbmmon_transport_udp_rcv_node_t_stct lbmmon_transport_udp_rcv_node_t;

<span class="comment">/*                                                                              </span>
<span class="comment">        For a statistics receiver, one of these gets returned as the TransportClientData.                                                                                                                                                               </span>
<span class="comment">*/</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span>
{
        <span class="comment">/* Lock to prevent access by multiple threads */</span>
<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>        CRITICAL_SECTION mLock;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        pthread_mutex_t mLock;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>        <span class="comment">/* Socket used to receive packets */</span>
<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>        SOCKET mSocket;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        <span class="keywordtype">int</span> mSocket;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>        <span class="comment">/* Peer socket address */</span>
        <span class="keyword">struct </span>sockaddr_in mPeer;
        <span class="comment">/* Interface */</span>
        <span class="keyword">struct </span>sockaddr_in mInterface;
        <span class="comment">/* Multicast membership */</span>
        <span class="keyword">struct </span>ip_mreq mMulticastMembership;
        <span class="comment">/* Mode */</span>
        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> mMode;
        <span class="comment">/* Head of the message queue */</span>
        lbmmon_transport_udp_rcv_node_t * mHead;
        <span class="comment">/* Tail of the message queue */</span>
        lbmmon_transport_udp_rcv_node_t * mTail;
        <span class="comment">/* Receiving thread */</span>
<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>        HANDLE mThread;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        pthread_t mThread;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>        <span class="comment">/* Flag to terminate thread */</span>
        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> mTerminateThread;
} lbmmon_transport_udp_rcv_t;

<span class="preprocessor">#define DEFAULT_INTERFACE "0.0.0.0"</span>
<span class="preprocessor"></span><span class="preprocessor">#define DEFAULT_PORT "2933"</span>
<span class="preprocessor"></span><span class="preprocessor">#define DEFAULT_TTL "16"</span>
<span class="preprocessor"></span>
<span class="comment">/* Error codes */</span>
<span class="preprocessor">#define LBMMONTRUDP_ERR_INVALID_OPTION 1</span>
<span class="preprocessor"></span><span class="preprocessor">#define LBMMONTRUDP_ERR_SOCKET 2</span>
<span class="preprocessor"></span><span class="preprocessor">#define LBMMONTRUDP_ERR_SEND 3</span>
<span class="preprocessor"></span><span class="preprocessor">#define LBMMONTRUDP_ERR_THREAD 4</span>
<span class="preprocessor"></span>
<span class="keyword">static</span> <span class="keywordtype">void</span> lock_receiver(lbmmon_transport_udp_rcv_t * Receiver);
<span class="keyword">static</span> <span class="keywordtype">void</span> unlock_receiver(lbmmon_transport_udp_rcv_t * Receiver);
<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span><span class="keyword">static</span> DWORD WINAPI receive_thread_proc(<span class="keywordtype">void</span> * Arg);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> * receive_thread_proc(<span class="keywordtype">void</span> * Arg);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="keyword">static</span> <span class="keywordtype">char</span> ErrorString[1024];

<span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
last_socket_error(<span class="keywordtype">void</span>)
{
        <span class="keyword">static</span> <span class="keywordtype">char</span> message[512];
<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>        snprintf(message, <span class="keyword">sizeof</span>(message), <span class="stringliteral">"error %d"</span>, WSAGetLastError());
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        snprintf(message,
                         <span class="keyword">sizeof</span>(message),
                         <span class="stringliteral">"error %d, %s"</span>,
                         errno,
                         strerror(errno));
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>        <span class="keywordflow">return</span> (message);
}

<span class="keyword">const</span> <a class="code" href="structlbmmon__transport__func__t__stct.html" title="Transport module function pointer container.">lbmmon_transport_func_t</a> *
lbmmon_transport_udp_module(<span class="keywordtype">void</span>)
{
        <span class="keywordflow">return</span> (&amp;LBMMON_TRANSPORT_UDP);
}

<span class="keywordtype">int</span>
lbmmon_transport_udp_initsrc(<span class="keywordtype">void</span> * * TransportClientData, <span class="keyword">const</span> <span class="keywordtype">void</span> * TransportOptions)
{
        lbmmon_transport_udp_src_t * data;
        <span class="keywordtype">int</span> rc;
        <span class="keyword">const</span> <span class="keywordtype">char</span> * ptr = (<span class="keyword">const</span> <span class="keywordtype">char</span> *) TransportOptions;
        <span class="keywordtype">char</span> key[512];
        <span class="keywordtype">char</span> value[512];
        <span class="keywordtype">char</span> address[512];
        <span class="keywordtype">char</span> port[512];
        <span class="keywordtype">char</span> interface[512];
        <span class="keywordtype">char</span> mcgroup[512];
        <span class="keywordtype">char</span> bcaddress[512];
        <span class="keywordtype">char</span> ttl[512];
        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> port_value;
        <span class="keyword">struct </span>in_addr multicast_group;
        <span class="keyword">struct </span>in_addr multicast_interface;
        <span class="keyword">struct </span>in_addr broadcast_address;
        <span class="keyword">struct </span>in_addr host_address;
        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> ttl_value = 0;

        memset(ErrorString, 0, <span class="keyword">sizeof</span>(ErrorString));
        data = malloc(<span class="keyword">sizeof</span>(lbmmon_transport_udp_src_t));
        multicast_group.s_addr = 0;
        multicast_interface.s_addr = 0;
        broadcast_address.s_addr = 0;
        host_address.s_addr = 0;

        <span class="comment">/* Process any options */</span>
        memset(address, 0, <span class="keyword">sizeof</span>(address));
        memset(port, 0, <span class="keyword">sizeof</span>(port));
        strcpy(port, DEFAULT_PORT);
        memset(interface, 0, <span class="keyword">sizeof</span>(interface));
        strcpy(interface, DEFAULT_INTERFACE);
        memset(mcgroup, 0, <span class="keyword">sizeof</span>(mcgroup));
        memset(bcaddress, 0, <span class="keyword">sizeof</span>(bcaddress));
        memset(ttl, 0, <span class="keyword">sizeof</span>(ttl));
        strcpy(ttl, DEFAULT_TTL);
        data-&gt;mMode = MODE_UNICAST;
        <span class="keywordflow">while</span> ((ptr = <a class="code" href="lbmmon_8h.html#d10ac6fdaa7ba17b8efceca176c36070" title="Retrieve the next key/value pair from a semicolon-separated list.">lbmmon_next_key_value_pair</a>(ptr, key, <span class="keyword">sizeof</span>(key), value, <span class="keyword">sizeof</span>(value))) != NULL)
        {
                <span class="keywordflow">if</span> (strcasecmp(key, <span class="stringliteral">"address"</span>) == 0)
                {
                        strncpy(address, value, <span class="keyword">sizeof</span>(address));
                }
                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp(key, <span class="stringliteral">"port"</span>) == 0)
                {
                        strncpy(port, value, <span class="keyword">sizeof</span>(port));
                }
                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp(key, <span class="stringliteral">"interface"</span>) == 0)
                {
                        strncpy(interface, value, <span class="keyword">sizeof</span>(interface));
                }
                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp(key, <span class="stringliteral">"mcgroup"</span>) == 0)
                {
                        strncpy(mcgroup, value, <span class="keyword">sizeof</span>(mcgroup));
                }
                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp(key, <span class="stringliteral">"bcaddress"</span>) == 0)
                {
                        strncpy(bcaddress, value, <span class="keyword">sizeof</span>(bcaddress));
                }
                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp(key, <span class="stringliteral">"ttl"</span>) == 0)
                {
                        strncpy(ttl, value, <span class="keyword">sizeof</span>(ttl));
                }
        }

        <span class="comment">/*      Validate the options</span>
<span class="comment">                Note the following:</span>
<span class="comment">                - interface and ttl only apply to mcgroup</span>
<span class="comment">                - mcgroup (and thus multicast) takes precedence over bcaddress (and thus broadcast)</span>
<span class="comment">                - bcaddress takes precedence over address.</span>
<span class="comment">        */</span>
        port_value = strtoul(port, NULL, 0);
        <span class="keywordflow">if</span> ((port_value == ULONG_MAX) &amp;&amp; (errno == ERANGE))
        {
                strncpy(ErrorString, <span class="stringliteral">"Invalid port value"</span>, <span class="keyword">sizeof</span>(ErrorString));
                free(data);
                <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (port_value &gt; USHRT_MAX)
        {
                strncpy(ErrorString, <span class="stringliteral">"Invalid port value"</span>, <span class="keyword">sizeof</span>(ErrorString));
                free(data);
                <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);
        }

        <span class="keywordflow">if</span> (mcgroup[0] != <span class="charliteral">'\0'</span>)
        {
                data-&gt;mMode = MODE_MULTICAST;
                multicast_group.s_addr = inet_addr(mcgroup);
                <span class="keywordflow">if</span> (multicast_group.s_addr == INADDR_NONE)
                {
                        strncpy(ErrorString, <span class="stringliteral">"Invalid mcgroup value"</span>, <span class="keyword">sizeof</span>(ErrorString));
                        free(data);
                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);
                }
                <span class="keywordflow">if</span> (!IN_MULTICAST(ntohl(multicast_group.s_addr)))
                {
                        strncpy(ErrorString, <span class="stringliteral">"Invalid mcgroup value"</span>, <span class="keyword">sizeof</span>(ErrorString));
                        free(data);
                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);
                }
                multicast_interface.s_addr = inet_addr(interface);
                <span class="keywordflow">if</span> (multicast_interface.s_addr == INADDR_NONE)
                {
                        strncpy(ErrorString, <span class="stringliteral">"Invalid interface value"</span>, <span class="keyword">sizeof</span>(ErrorString));
                        free(data);
                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);
                }
                ttl_value = strtoul(ttl, NULL, 0);
                <span class="keywordflow">if</span> ((ttl_value == ULONG_MAX) &amp;&amp; (errno == ERANGE))
                {
                        strncpy(ErrorString, <span class="stringliteral">"Invalid ttl value"</span>, <span class="keyword">sizeof</span>(ErrorString));
                        free(data);
                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);
                }
                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ttl_value &gt; UCHAR_MAX)
                {
                        strncpy(ErrorString, <span class="stringliteral">"Invalid ttl value"</span>, <span class="keyword">sizeof</span>(ErrorString));
                        free(data);
                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);
                }
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bcaddress[0] != <span class="charliteral">'\0'</span>)
        {
                data-&gt;mMode = MODE_BROADCAST;
                broadcast_address.s_addr = inet_addr(bcaddress);
                <span class="keywordflow">if</span> (broadcast_address.s_addr == INADDR_NONE)
                {
                        strncpy(ErrorString, <span class="stringliteral">"Invalid bcaddress value"</span>, <span class="keyword">sizeof</span>(ErrorString));
                        free(data);
                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);
                }
        }
        <span class="keywordflow">else</span>
        {
                host_address.s_addr = inet_addr(address);
                <span class="keywordflow">if</span> (host_address.s_addr == INADDR_NONE)
                {
                        strncpy(ErrorString, <span class="stringliteral">"Invalid address value"</span>, <span class="keyword">sizeof</span>(ErrorString));
                        free(data);
                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);
                }
        }

        <span class="comment">/* Create the socket */</span>
        data-&gt;mSocket = socket(PF_INET, SOCK_DGRAM, 0);
        <span class="keywordflow">if</span> (data-&gt;mSocket == LBMMON_INVALID_HANDLE)
        {
                snprintf(ErrorString,
                                 <span class="keyword">sizeof</span>(ErrorString),
                                 <span class="stringliteral">"socket() failed, %s"</span>,
                                 last_socket_error());
                free(data);
                <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_SOCKET);
        }

        <span class="comment">/* If broadcast mode, enable broadcast on the socket */</span>
        <span class="keywordflow">if</span> (data-&gt;mMode == MODE_BROADCAST)
        {
                <span class="keywordtype">int</span> option = 1;
                socklen_t len = <span class="keyword">sizeof</span>(option);
                rc = setsockopt(data-&gt;mSocket, SOL_SOCKET, SO_BROADCAST, (<span class="keywordtype">void</span> *) &amp;option, len);
                <span class="keywordflow">if</span> (rc == LBMMON_SOCKET_ERROR)
                {
                        snprintf(ErrorString,
                                         <span class="keyword">sizeof</span>(ErrorString),
                                         <span class="stringliteral">"setsockopt(...,SO_BROADCAST,...) failed, %s"</span>,
                                         last_socket_error());
<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>                        closesocket(data-&gt;mSocket);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>                        close(data-&gt;mSocket);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>                        free(data);
                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_SOCKET);
                }
        }

        <span class="comment">/* For multicast, set the outgoing interface and TTL. */</span>
        <span class="keywordflow">if</span> (data-&gt;mMode == MODE_MULTICAST)
        {
                <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> optval = (<span class="keywordtype">unsigned</span> char) ttl_value;
                <span class="keyword">struct </span>in_addr ifc_addr;
                rc = setsockopt(data-&gt;mSocket, IPPROTO_IP, IP_MULTICAST_TTL, (<span class="keywordtype">void</span> *) &amp;optval, <span class="keyword">sizeof</span>(optval));
                <span class="keywordflow">if</span> (rc != LBMMON_SOCKET_ERROR)
                {
                        ifc_addr.s_addr = multicast_interface.s_addr;
                        rc = setsockopt(data-&gt;mSocket, IPPROTO_IP, IP_MULTICAST_IF, (<span class="keywordtype">void</span> *) &amp;ifc_addr, <span class="keyword">sizeof</span>(ifc_addr));
                        <span class="keywordflow">if</span> (rc == LBMMON_SOCKET_ERROR)
                        {
                                snprintf(ErrorString,
                                                 <span class="keyword">sizeof</span>(ErrorString),
                                                 <span class="stringliteral">"setsockopt(...,IP_MULTICAST_IF,...) failed, %s"</span>,
                                                 last_socket_error());
                        }
                }
                <span class="keywordflow">else</span>
                {
                        snprintf(ErrorString,
                                         <span class="keyword">sizeof</span>(ErrorString),
                                         <span class="stringliteral">"setsockopt(...,IP_MULTICAST_TTL,...) failed, %s"</span>,
                                         last_socket_error());
                }
                <span class="keywordflow">if</span> (rc == LBMMON_SOCKET_ERROR)
                {
<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>                        closesocket(data-&gt;mSocket);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>                        close(data-&gt;mSocket);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>                        free(data);
                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_SOCKET);
                }
        }

        <span class="comment">/* Build the peer sockaddr_in. */</span>
        data-&gt;mPeer.sin_family = AF_INET;
        data-&gt;mPeer.sin_port = htons((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>) port_value);
        <span class="keywordflow">switch</span> (data-&gt;mMode)
        {
                <span class="keywordflow">case</span> MODE_UNICAST:
                <span class="keywordflow">default</span>:
                        data-&gt;mPeer.sin_addr.s_addr = host_address.s_addr;
                        <span class="keywordflow">break</span>;

                <span class="keywordflow">case</span> MODE_BROADCAST:
                        data-&gt;mPeer.sin_addr.s_addr = broadcast_address.s_addr;
                        <span class="keywordflow">break</span>;

                <span class="keywordflow">case</span> MODE_MULTICAST:
                        data-&gt;mPeer.sin_addr.s_addr = multicast_group.s_addr;
                        <span class="keywordflow">break</span>;
        }

        <span class="comment">/* Pass back the lbmmon_transport_udp_src_t created */</span>
        *TransportClientData = data;
        <span class="keywordflow">return</span> (0);
}

<span class="keywordtype">int</span>
lbmmon_transport_udp_initrcv(<span class="keywordtype">void</span> * * TransportClientData, <span class="keyword">const</span> <span class="keywordtype">void</span> * TransportOptions)
{
        lbmmon_transport_udp_rcv_t * data;
        <span class="keywordtype">int</span> rc;
        <span class="keyword">const</span> <span class="keywordtype">char</span> * ptr = (<span class="keyword">const</span> <span class="keywordtype">char</span> *) TransportOptions;
        <span class="keywordtype">char</span> key[512];
        <span class="keywordtype">char</span> value[512];
        <span class="keywordtype">char</span> port[512];
        <span class="keywordtype">char</span> interface[512];
        <span class="keywordtype">char</span> mcgroup[512];
        <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> port_value;
        <span class="keyword">struct </span>in_addr multicast_group;
        <span class="keyword">struct </span>in_addr multicast_interface;

        memset(ErrorString, 0, <span class="keyword">sizeof</span>(ErrorString));
        data = malloc(<span class="keyword">sizeof</span>(lbmmon_transport_udp_rcv_t));
        multicast_group.s_addr = 0;
        multicast_interface.s_addr = 0;
        data-&gt;mHead = NULL;
        data-&gt;mTail = NULL;
        data-&gt;mTerminateThread = 0;

        <span class="comment">/* Process any options */</span>
        memset(port, 0, <span class="keyword">sizeof</span>(port));
        strcpy(port, DEFAULT_PORT);
        memset(interface, 0, <span class="keyword">sizeof</span>(interface));
        strcpy(interface, DEFAULT_INTERFACE);
        memset(mcgroup, 0, <span class="keyword">sizeof</span>(mcgroup));
        data-&gt;mMode = MODE_UNICAST;
        <span class="keywordflow">while</span> ((ptr = <a class="code" href="lbmmon_8h.html#d10ac6fdaa7ba17b8efceca176c36070" title="Retrieve the next key/value pair from a semicolon-separated list.">lbmmon_next_key_value_pair</a>(ptr, key, <span class="keyword">sizeof</span>(key), value, <span class="keyword">sizeof</span>(value))) != NULL)
        {
                <span class="keywordflow">if</span> (strcasecmp(key, <span class="stringliteral">"port"</span>) == 0)
                {
                        strncpy(port, value, <span class="keyword">sizeof</span>(port));
                }
                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp(key, <span class="stringliteral">"interface"</span>) == 0)
                {
                        strncpy(interface, value, <span class="keyword">sizeof</span>(interface));
                }
                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcasecmp(key, <span class="stringliteral">"mcgroup"</span>) == 0)
                {
                        strncpy(mcgroup, value, <span class="keyword">sizeof</span>(mcgroup));
                }
        }

        <span class="comment">/*      Validate the options</span>
<span class="comment">                Note the following:</span>
<span class="comment">                - interface only applies to mcgroup</span>
<span class="comment">                - mcgroup (and thus multicast) takes precedence over broadcast/unicast</span>
<span class="comment">        */</span>
        port_value = strtoul(port, NULL, 0);
        <span class="keywordflow">if</span> ((port_value == ULONG_MAX) &amp;&amp; (errno == ERANGE))
        {
                strncpy(ErrorString, <span class="stringliteral">"Invalid port value"</span>, <span class="keyword">sizeof</span>(ErrorString));
                free(data);
                <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (port_value &gt; USHRT_MAX)
        {
                strncpy(ErrorString, <span class="stringliteral">"Invalid port value"</span>, <span class="keyword">sizeof</span>(ErrorString));
                free(data);
                <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);
        }

        <span class="keywordflow">if</span> (mcgroup[0] != <span class="charliteral">'\0'</span>)
        {
                data-&gt;mMode = MODE_MULTICAST;
                multicast_group.s_addr = inet_addr(mcgroup);
                <span class="keywordflow">if</span> (multicast_group.s_addr == INADDR_NONE)
                {
                        strncpy(ErrorString, <span class="stringliteral">"Invalid mcgroup value"</span>, <span class="keyword">sizeof</span>(ErrorString));
                        free(data);
                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);
                }
                <span class="keywordflow">if</span> (!IN_MULTICAST(ntohl(multicast_group.s_addr)))
                {
                        strncpy(ErrorString, <span class="stringliteral">"Invalid mcgroup value"</span>, <span class="keyword">sizeof</span>(ErrorString));
                        free(data);
                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);
                }
                multicast_interface.s_addr = inet_addr(interface);
                <span class="keywordflow">if</span> (multicast_interface.s_addr == INADDR_NONE)
                {
                        strncpy(ErrorString, <span class="stringliteral">"Invalid interface value"</span>, <span class="keyword">sizeof</span>(ErrorString));
                        free(data);
                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_INVALID_OPTION);
                }
        }

        <span class="comment">/* Create the socket */</span>
        data-&gt;mSocket = socket(PF_INET, SOCK_DGRAM, 0);
        <span class="keywordflow">if</span> (data-&gt;mSocket == LBMMON_INVALID_HANDLE)
        {
                snprintf(ErrorString,
                                 <span class="keyword">sizeof</span>(ErrorString),
                                 <span class="stringliteral">"socket() failed, %s"</span>,
                                 last_socket_error());
                free(data);
                <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_SOCKET);
        }

        <span class="comment">/* Build the interface sockaddr_in. */</span>
        memset(&amp;(data-&gt;mInterface), 0, <span class="keyword">sizeof</span>(data-&gt;mInterface));
        data-&gt;mInterface.sin_family = AF_INET;
        data-&gt;mInterface.sin_port = htons((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>) port_value);
        data-&gt;mInterface.sin_addr.s_addr = INADDR_ANY;

        <span class="comment">/* Bind the socket. */</span>
        rc = bind(data-&gt;mSocket, (<span class="keyword">struct</span> sockaddr *) &amp;(data-&gt;mInterface), <span class="keyword">sizeof</span>(data-&gt;mInterface));
        <span class="keywordflow">if</span> (rc == LBMMON_SOCKET_ERROR)
        {
                snprintf(ErrorString,
                                 <span class="keyword">sizeof</span>(ErrorString),
                                 <span class="stringliteral">"bind() failed, %s"</span>,
                                 last_socket_error());
<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>                        closesocket(data-&gt;mSocket);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>                        close(data-&gt;mSocket);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_SOCKET);
        }

        <span class="comment">/* For multicast, join the group. */</span>
        <span class="keywordflow">if</span> (data-&gt;mMode == MODE_MULTICAST)
        {
                data-&gt;mMulticastMembership.imr_interface.s_addr = multicast_interface.s_addr;
                data-&gt;mMulticastMembership.imr_multiaddr.s_addr = multicast_group.s_addr;
                rc = setsockopt(data-&gt;mSocket, IPPROTO_IP, IP_ADD_MEMBERSHIP, (<span class="keywordtype">void</span> *) &amp;(data-&gt;mMulticastMembership), <span class="keyword">sizeof</span>(data-&gt;mMulticastMembership));
                <span class="keywordflow">if</span> (rc == LBMMON_SOCKET_ERROR)
                {
                        snprintf(ErrorString,
                                         <span class="keyword">sizeof</span>(ErrorString),
                                         <span class="stringliteral">"setsockopt(...,IP_ADD_MEMBERSHIP,...) failed, %s"</span>,
                                         last_socket_error());
<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>                        closesocket(data-&gt;mSocket);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>                        close(data-&gt;mSocket);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>                        free(data);
                        <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_SOCKET);
                }
        }

        <span class="comment">/* Build the peer sockaddr_in. */</span>
        data-&gt;mPeer.sin_family = AF_INET;
        data-&gt;mPeer.sin_port = htons((<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>) port_value);
        data-&gt;mPeer.sin_addr.s_addr = INADDR_ANY;

<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>        InitializeCriticalSection(&amp;(data-&gt;mLock));
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        pthread_mutex_init(&amp;(data-&gt;mLock), NULL);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
        <span class="comment">/* Start the receive thread */</span>
<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>        data-&gt;mThread = CreateThread(NULL, 0, receive_thread_proc, data, 0, NULL);
        <span class="keywordflow">if</span> (data-&gt;mThread == NULL)
        {
                snprintf(ErrorString,
                                 <span class="keyword">sizeof</span>(ErrorString),
                                 <span class="stringliteral">"CreateThread() failed, error %d"</span>,
                                 GetLastError());
                closesocket(data-&gt;mSocket);
                free(data);
                <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_THREAD);
        }
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">#ifdef __VOS__</span>
<span class="preprocessor"></span>        {
                pthread_attr_t pth_attr;
                pthread_attr_init (&amp;pth_attr);
                pthread_attr_setschedpolicy (&amp;pth_attr, SCHED_RR);
                rc = pthread_create(&amp;(data-&gt;mThread), &amp;pth_attr, receive_thread_proc, data);
        }
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        rc = pthread_create(&amp;(data-&gt;mThread), NULL, receive_thread_proc, data);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>        <span class="keywordflow">if</span> (rc != 0)
        {
                snprintf(ErrorString,
                                 <span class="keyword">sizeof</span>(ErrorString),
                                 <span class="stringliteral">"pthread_create() failed, error %d, %s"</span>,
                                 rc,
                                 strerror(rc));
                close(data-&gt;mSocket);
                free(data);
                <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_THREAD);
        }
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
        <span class="comment">/* Pass back the lbmmon_transport_udp_rcv_t created */</span>
        *TransportClientData = data;
        <span class="keywordflow">return</span> (0);
}

<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>DWORD WINAPI
receive_thread_proc(<span class="keywordtype">void</span> * Arg)
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="keywordtype">void</span> *
receive_thread_proc(<span class="keywordtype">void</span> * Arg)
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>{
        lbmmon_transport_udp_rcv_t * rcv = (lbmmon_transport_udp_rcv_t *) Arg;
        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buffer[8192];
        <span class="keyword">struct </span>timeval timeout;
        fd_set readfds;
        <span class="keywordtype">int</span> rc;
        ssize_t bytes_read;
        lbmmon_transport_udp_rcv_node_t * node;

        <span class="keywordflow">while</span> (rcv-&gt;mTerminateThread == 0)
        {
                FD_ZERO(&amp;readfds);
                FD_SET(rcv-&gt;mSocket, &amp;readfds);
                timeout.tv_sec = 0;
                timeout.tv_usec = 500000;
                rc = select(rcv-&gt;mSocket + 1, &amp;readfds, NULL, NULL, &amp;timeout);
                <span class="keywordflow">if</span> (rc &lt;= 0)
                {
                        <span class="keywordflow">continue</span>;
                }
                bytes_read = recvfrom(rcv-&gt;mSocket, buffer, <span class="keyword">sizeof</span>(buffer), 0, NULL, NULL);
                <span class="keywordflow">if</span> (bytes_read == LBMMON_SOCKET_ERROR)
                {
                        <span class="keywordflow">continue</span>;
                }

                <span class="comment">/* A data message. We want to enqueue it for processing. */</span>
                lock_receiver(rcv);
                node = malloc(<span class="keyword">sizeof</span>(lbmmon_transport_udp_rcv_node_t));
                node-&gt;mMessage = malloc((<span class="keywordtype">size_t</span>) bytes_read);
                memcpy(node-&gt;mMessage, buffer, (<span class="keywordtype">size_t</span>) bytes_read);
                node-&gt;mMessageLength = (size_t) bytes_read;
                node-&gt;mUsedBytes = 0;   <span class="comment">/* No data returned as yet */</span>

                <span class="comment">/* Link the message onto the queue */</span>
                node-&gt;mNext = NULL;
                <span class="keywordflow">if</span> (rcv-&gt;mTail != NULL)
                {
                        rcv-&gt;mTail-&gt;mNext = node;
                }
                <span class="keywordflow">else</span>
                {
                        rcv-&gt;mHead = node;
                }
                rcv-&gt;mTail = node;
                unlock_receiver(rcv);
        }
<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>        <span class="keywordflow">return</span> (0);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        <span class="keywordflow">return</span> (NULL);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>}

<span class="keywordtype">int</span>
lbmmon_transport_udp_send(<span class="keyword">const</span> <span class="keywordtype">char</span> * Data, <span class="keywordtype">size_t</span> Length, <span class="keywordtype">void</span> * TransportClientData)
{
        lbmmon_transport_udp_src_t * src;
        <span class="keywordtype">int</span> rc;

        <span class="keywordflow">if</span> ((Data == NULL) || (TransportClientData == NULL))
        {
                <span class="keywordflow">return</span> (-1);
        }
        src = (lbmmon_transport_udp_src_t *) TransportClientData;
        rc = sendto(src-&gt;mSocket, Data, Length, 0, (<span class="keyword">struct</span> sockaddr *) &amp;(src-&gt;mPeer), <span class="keyword">sizeof</span>(src-&gt;mPeer));
        <span class="keywordflow">if</span> (rc == LBMMON_SOCKET_ERROR)
        {
                snprintf(ErrorString,
                                 <span class="keyword">sizeof</span>(ErrorString),
                                 <span class="stringliteral">"sendto() failed, %s"</span>,
                                 last_socket_error());
                <span class="keywordflow">return</span> (LBMMONTRUDP_ERR_SEND);
        }
        <span class="keywordflow">return</span> (0);
}

<span class="keywordtype">int</span>
lbmmon_transport_udp_receive(<span class="keywordtype">char</span> * Data, <span class="keywordtype">size_t</span> * Length, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> TimeoutMS, <span class="keywordtype">void</span> * TransportClientData)
{
        lbmmon_transport_udp_rcv_t * rcv = (lbmmon_transport_udp_rcv_t *) TransportClientData;
        lbmmon_transport_udp_rcv_node_t * node;
        <span class="keywordtype">int</span> rc = 0;
        <span class="keywordtype">size_t</span> length_remaining;
<span class="preprocessor">#if defined(_WIN32)</span>
<span class="preprocessor"></span><span class="preprocessor">#elif defined(__TANDEM)</span>
<span class="preprocessor"></span>        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sleep_sec;
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sleep_usec;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        <span class="keyword">struct </span>timespec ivl;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
        <span class="keywordflow">if</span> ((Data == NULL) || (Length == NULL) || (TransportClientData == NULL))
        {
                <span class="keywordflow">return</span> (-1);
        }
        <span class="keywordflow">if</span> (*Length == 0)
        {
                <span class="keywordflow">return</span> (0);
        }
        lock_receiver(rcv);
        <span class="keywordflow">if</span> (rcv-&gt;mHead != NULL)
        {
                <span class="comment">/* Queue is non-empty. Pull the first message from the queue. */</span>
                node = rcv-&gt;mHead;
                length_remaining = node-&gt;mMessageLength - node-&gt;mUsedBytes;
                <span class="keywordflow">if</span> (*Length &gt;= length_remaining)
                {
                        <span class="comment">/* We can transfer the rest of the message */</span>
                        memcpy(Data, node-&gt;mMessage + node-&gt;mUsedBytes, length_remaining);
                        *Length = length_remaining;
                        rc = 0;
                        <span class="comment">/* We're done with the message, so free it. */</span>
                        free(node-&gt;mMessage);
                        node-&gt;mMessage = NULL;
                        <span class="comment">/* Unlink the node from the queue */</span>
                        rcv-&gt;mHead = node-&gt;mNext;
                        <span class="keywordflow">if</span> (rcv-&gt;mHead == NULL)
                        {
                                rcv-&gt;mTail = NULL;
                        }
                        free(node);
                }
                <span class="keywordflow">else</span>
                {
                        <span class="comment">/* Can only transfer part of the message */</span>
                        memcpy(Data, node-&gt;mMessage + node-&gt;mUsedBytes, *Length);
                        node-&gt;mUsedBytes -= *Length;
                        rc = 0;
                }
                unlock_receiver(rcv);
        }
        <span class="keywordflow">else</span>
        {
                unlock_receiver(rcv);
                <span class="comment">/* Sleep for wait time */</span>
<span class="preprocessor">#define NANOSECONDS_PER_SECOND 1000000000</span>
<span class="preprocessor"></span><span class="preprocessor">#define MICROSECONDS_PER_SECOND 1000000</span>
<span class="preprocessor"></span><span class="preprocessor">#define MILLISECONDS_PER_SECOND 1000</span>
<span class="preprocessor"></span><span class="preprocessor">#define NANOSECONDS_PER_MILLISECOND (NANOSECONDS_PER_SECOND / MILLISECONDS_PER_SECOND)</span>
<span class="preprocessor"></span><span class="preprocessor">#define MICROSECONDS_PER_MILLISECOND (MICROSECONDS_PER_SECOND / MILLISECONDS_PER_SECOND)</span>
<span class="preprocessor"></span><span class="preprocessor">#if defined(_WIN32)</span>
<span class="preprocessor"></span>                Sleep(TimeoutMS);
<span class="preprocessor">#elif defined(__TANDEM)</span>
<span class="preprocessor"></span>                sleep_sec = TimeoutMS / MILLISECONDS_PER_SECOND;
                sleep_usec = (TimeoutMS % MILLISECONDS_PER_SECOND) * MICROSECONDS_PER_MILLISECOND;
                <span class="keywordflow">if</span> (sleep_usec &gt; 0)
                {
                        usleep(sleep_usec);
                }
                <span class="keywordflow">if</span> (sleep_sec &gt; 0)
                {
                        sleep(sleep_sec);
                }
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>                ivl.tv_sec = TimeoutMS / MILLISECONDS_PER_SECOND;
                ivl.tv_nsec = (TimeoutMS % MILLISECONDS_PER_SECOND) * NANOSECONDS_PER_MILLISECOND;
                nanosleep(&amp;ivl, NULL);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>                rc = 1;
        }
        <span class="keywordflow">return</span> (rc);
}

<span class="keywordtype">int</span>
lbmmon_transport_udp_src_finish(<span class="keywordtype">void</span> * TransportClientData)
{
        lbmmon_transport_udp_src_t * src;

        <span class="keywordflow">if</span> (TransportClientData == NULL)
        {
                strncpy(ErrorString, <span class="stringliteral">"Invalid parameter"</span>, <span class="keyword">sizeof</span>(ErrorString));
                <span class="keywordflow">return</span> (-1);
        }
        src = (lbmmon_transport_udp_src_t *) TransportClientData;

<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>        closesocket(src-&gt;mSocket);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        close(src-&gt;mSocket);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>        <span class="comment">/* Clean up our data */</span>
        free(TransportClientData);
        <span class="keywordflow">return</span> (0);
}

<span class="keywordtype">int</span>
lbmmon_transport_udp_rcv_finish(<span class="keywordtype">void</span> * TransportClientData)
{
        lbmmon_transport_udp_rcv_t * rcv = (lbmmon_transport_udp_rcv_t *) TransportClientData;
        lbmmon_transport_udp_rcv_node_t * node;
        lbmmon_transport_udp_rcv_node_t * next;
        <span class="keywordtype">int</span> rc;

        <span class="comment">/* Stop the thread to prevent any more incoming messages */</span>
        rcv-&gt;mTerminateThread = 1;

        <span class="comment">/* Lock the receiver */</span>
        lock_receiver(rcv);

        <span class="comment">/* Clean out the queue */</span>
        node = rcv-&gt;mHead;
        <span class="keywordflow">while</span> (node != NULL)
        {
                <span class="comment">/* Let LBM know we're done with the message */</span>
                free(node-&gt;mMessage);
                next = node-&gt;mNext;
                free(node);
                node = next;
        }

        unlock_receiver(rcv);

        <span class="comment">/* If multicast, drop membership. */</span>
        <span class="keywordflow">if</span> (rcv-&gt;mMode == MODE_MULTICAST)
        {
                rc = setsockopt(rcv-&gt;mSocket, IPPROTO_IP, IP_DROP_MEMBERSHIP, (<span class="keywordtype">void</span> *) &amp;(rcv-&gt;mMulticastMembership), <span class="keyword">sizeof</span>(rcv-&gt;mMulticastMembership));
        }
<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>        closesocket(rcv-&gt;mSocket);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        close(rcv-&gt;mSocket);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span><span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>        DeleteCriticalSection(&amp;(rcv-&gt;mLock));
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        pthread_mutex_destroy(&amp;(rcv-&gt;mLock));
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
        free(TransportClientData);
        <span class="keywordflow">return</span> (0);
}

<span class="keywordtype">void</span>
lock_receiver(lbmmon_transport_udp_rcv_t * Receiver)
{
<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>        EnterCriticalSection(&amp;(Receiver-&gt;mLock));
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        pthread_mutex_lock(&amp;(Receiver-&gt;mLock));
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>}

<span class="keywordtype">void</span>
unlock_receiver(lbmmon_transport_udp_rcv_t * Receiver)
{
<span class="preprocessor">#ifdef _WIN32</span>
<span class="preprocessor"></span>        LeaveCriticalSection(&amp;(Receiver-&gt;mLock));
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        pthread_mutex_unlock(&amp;(Receiver-&gt;mLock));
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>}

<span class="keyword">const</span> <span class="keywordtype">char</span> *
lbmmon_transport_udp_errmsg(<span class="keywordtype">void</span>)
{
        <span class="keywordflow">return</span> (ErrorString);
}

</pre></div> <hr size="1"><address style="text-align: right;"><small>Generated on Thu Mar 6 13:11:14 2014 for LBM API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
<script type="text/javascript">highlight();</script>
</html>
