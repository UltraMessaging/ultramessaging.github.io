<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>LBM API: lbm.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
	<script type="text/javascript" src="../Search/highlight.js"></script>
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul>
</div>
<h1>lbm.h File Reference</h1>Ultra Messaging (UM) API. <a href="#_details">More...</a>
<p>
<code>#include &lt;inttypes.h&gt;</code><br>

<p>
Include dependency graph for lbm.h:<p><center><img src="lbm_8h__incl.png" border="0" usemap="#lbm.h_map" alt=""></center>
<map name="lbm.h_map">
<area shape="rect" title="Ultra Messaging (UM) API." alt="" coords="109,5,189,32"></map>

<p>
<a href="lbm_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__iovec__t__stct.html">lbm_iovec_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure, struct iovec compatible, that holds information about buffers used for vectored sends.  <a href="structlbm__iovec__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__ipv4__address__mask__t__stct.html">lbm_ipv4_address_mask_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds an IPv4 address and a CIDR style netmask.  <a href="structlbm__ipv4__address__mask__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__timeval__t__stct.html">lbm_timeval_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds seconds and microseconds since midnight, Jan 1, 1970 UTC.  <a href="structlbm__timeval__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__src__event__wakeup__t__stct.html">lbm_src_event_wakeup_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds source wakeup event data.  <a href="structlbm__src__event__wakeup__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__src__event__flight__size__notification__t__stct.html">lbm_src_event_flight_size_notification_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds flight size notification event data.  <a href="structlbm__src__event__flight__size__notification__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__src__event__ume__registration__t__stct.html">lbm_src_event_ume_registration_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds store registration information for the UMP source.  <a href="structlbm__src__event__ume__registration__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__src__event__ume__registration__ex__t__stct.html">lbm_src_event_ume_registration_ex_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds store registration information for the UMP source in an extended form.  <a href="structlbm__src__event__ume__registration__ex__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__src__event__ume__registration__complete__ex__t__stct.html">lbm_src_event_ume_registration_complete_ex_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for sources after registration is complete to all involved stores.  <a href="structlbm__src__event__ume__registration__complete__ex__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__src__event__ume__deregistration__ex__t__stct.html">lbm_src_event_ume_deregistration_ex_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds store deregistration information for the UMP source in an extended form.  <a href="structlbm__src__event__ume__deregistration__ex__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__msg__ume__registration__t__stct.html">lbm_msg_ume_registration_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds store registration information for the UMP receiver.  <a href="structlbm__msg__ume__registration__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__msg__ume__registration__ex__t__stct.html">lbm_msg_ume_registration_ex_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds store registration information for the UM receiver in an extended form.  <a href="structlbm__msg__ume__registration__ex__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__msg__ume__registration__complete__ex__t__stct.html">lbm_msg_ume_registration_complete_ex_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for receivers after registration is complete to all involved stores.  <a href="structlbm__msg__ume__registration__complete__ex__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__msg__ume__deregistration__ex__t__stct.html">lbm_msg_ume_deregistration_ex_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds store deregistration information for the UM receiver in an extended form.  <a href="structlbm__msg__ume__deregistration__ex__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__src__event__ume__ack__info__t__stct.html">lbm_src_event_ume_ack_info_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds ACK information for a given message.  <a href="structlbm__src__event__ume__ack__info__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__src__event__ume__ack__ex__info__t__stct.html">lbm_src_event_ume_ack_ex_info_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds ACK information for a given message in an extended form.  <a href="structlbm__src__event__ume__ack__ex__info__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__flight__size__inflight__t__stct.html">lbm_flight_size_inflight_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for source total inflight messages and bytes.  <a href="structlbm__flight__size__inflight__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__umq__index__info__t__stct.html">lbm_umq_index_info_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information used for sending and receiving messages with UMQ indices.  <a href="structlbm__umq__index__info__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__msg__umq__index__assignment__eligibility__stop__complete__ex__t__stct.html">lbm_msg_umq_index_assignment_eligibility_stop_complete_ex_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds index assignment information for receivers.  <a href="structlbm__msg__umq__index__assignment__eligibility__stop__complete__ex__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__msg__umq__index__assigned__ex__t__stct.html">lbm_msg_umq_index_assigned_ex_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds beginning-of-index information for receivers.  <a href="structlbm__msg__umq__index__assigned__ex__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__msg__umq__index__released__ex__t__stct.html">lbm_msg_umq_index_released_ex_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds end-of-index information for receivers.  <a href="structlbm__msg__umq__index__released__ex__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__msg__umq__index__assignment__eligibility__start__complete__ex__t__stct.html">lbm_msg_umq_index_assignment_eligibility_start_complete_ex_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds index assignment information for receivers.  <a href="structlbm__msg__umq__index__assignment__eligibility__start__complete__ex__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__umq__msg__total__lifetime__info__t__stct.html">lbm_umq_msg_total_lifetime_info_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds UMQ message total lifetime information.  <a href="structlbm__umq__msg__total__lifetime__info__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionlbm__hf__sequence__number__t__stct.html">lbm_hf_sequence_number_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure to hold a hot failover sequence number.  <a href="unionlbm__hf__sequence__number__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__umq__msgid__t__stct.html">lbm_umq_msgid_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for UMQ messages that allows the message to be identified uniquely.  <a href="structlbm__umq__msgid__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_umq_queue_application_set_t_stct</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__umq__queue__topic__t__stct.html">lbm_umq_queue_topic_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds queue topic information and can be used as a handle to a queue topic.  <a href="structlbm__umq__queue__topic__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__umq__queue__topic__status__t.html">lbm_umq_queue_topic_status_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Struct containing extended asynchronous operation status information about a single UMQ topic.  <a href="structlbm__umq__queue__topic__status__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__ctx__umq__queue__topic__list__info__t.html">lbm_ctx_umq_queue_topic_list_info_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Struct containing an array of queue topics retrieved via lbm_umq_queue_topic_list.  <a href="structlbm__ctx__umq__queue__topic__list__info__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__umq__queue__msg__status__t.html">lbm_umq_queue_msg_status_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Struct containing extended asynchronous operation status information about a single UMQ message.  <a href="structlbm__umq__queue__msg__status__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__rcv__umq__queue__msg__list__info__t.html">lbm_rcv_umq_queue_msg_list_info_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Struct containing an array of UMQ messages listed via lbm_rcv_umq_queue_msg_list.  <a href="structlbm__rcv__umq__queue__msg__list__info__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__rcv__umq__queue__msg__retrieve__info__t.html">lbm_rcv_umq_queue_msg_retrieve_info_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Struct containing an array of UMQ messages retrieved via lbm_rcv_umq_queue_msg_retrieve.  <a href="structlbm__rcv__umq__queue__msg__retrieve__info__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__async__operation__info__t.html">lbm_async_operation_info_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Results struct returned via the user-specified asynchronous operation callback from any asynchronous API.  <a href="structlbm__async__operation__info__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__async__operation__func__t.html">lbm_async_operation_func_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for asynchronous operation callbacks.  <a href="structlbm__async__operation__func__t.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__src__send__ex__info__t__stct.html">lbm_src_send_ex_info_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for the extended send calls A structure used with UM sources that utilize the extended send calls to pass options.  <a href="structlbm__src__send__ex__info__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__ume__rcv__regid__ex__func__info__t__stct.html">lbm_ume_rcv_regid_ex_func_info_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for UMP receiver registration ID application callbacks.  <a href="structlbm__ume__rcv__regid__ex__func__info__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__src__event__sequence__number__info__t__stct.html">lbm_src_event_sequence_number_info_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds sequence number information for a message sent by a source.  <a href="structlbm__src__event__sequence__number__info__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__ume__rcv__recovery__info__ex__func__info__t__stct.html">lbm_ume_rcv_recovery_info_ex_func_info_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for UMP receiver recovery sequence number info application callbacks.  <a href="structlbm__ume__rcv__recovery__info__ex__func__info__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__src__event__umq__message__id__info__t__stct.html">lbm_src_event_umq_message_id_info_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds Message ID information for a message sent by a sending UMQ application.  <a href="structlbm__src__event__umq__message__id__info__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__context__event__umq__registration__ex__t__stct.html">lbm_context_event_umq_registration_ex_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds queue registration information for the UMQ context in an extended form.  <a href="structlbm__context__event__umq__registration__ex__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__context__event__umq__registration__complete__ex__t__stct.html">lbm_context_event_umq_registration_complete_ex_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for contexts after registration is complete to all involved queue instances.  <a href="structlbm__context__event__umq__registration__complete__ex__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__src__event__umq__registration__complete__ex__t__stct.html">lbm_src_event_umq_registration_complete_ex_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for sources after registration is complete to all involved queue instances.  <a href="structlbm__src__event__umq__registration__complete__ex__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__msg__umq__registration__complete__ex__t__stct.html">lbm_msg_umq_registration_complete_ex_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for receivers after registration is complete to all involved queue instances.  <a href="structlbm__msg__umq__registration__complete__ex__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__src__event__umq__stability__ack__info__ex__t__stct.html">lbm_src_event_umq_stability_ack_info_ex_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds UMQ ACK information for a given message in an extended form.  <a href="structlbm__src__event__umq__stability__ack__info__ex__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__msg__umq__deregistration__complete__ex__t__stct.html">lbm_msg_umq_deregistration_complete_ex_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for receivers after they de-register from a queue.  <a href="structlbm__msg__umq__deregistration__complete__ex__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__src__event__umq__ulb__receiver__info__ex__t__stct.html">lbm_src_event_umq_ulb_receiver_info_ex_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds UMQ ULB receiver information in an extended form.  <a href="structlbm__src__event__umq__ulb__receiver__info__ex__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__src__event__umq__ulb__message__info__ex__t__stct.html">lbm_src_event_umq_ulb_message_info_ex_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds UMQ ULB message information in an extended form.  <a href="structlbm__src__event__umq__ulb__message__info__ex__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_str_hash_func_t_stct</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__str__hash__func__ex__t__stct.html">lbm_str_hash_func_ex_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the hash function callback information.  <a href="structlbm__str__hash__func__ex__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__src__notify__func__t__stct.html">lbm_src_notify_func_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the callback for source notifications.  <a href="structlbm__src__notify__func__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__wildcard__rcv__compare__func__t__stct.html">lbm_wildcard_rcv_compare_func_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the application callback pattern type information for wildcard receivers.  <a href="structlbm__wildcard__rcv__compare__func__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__ume__rcv__regid__func__t__stct.html">lbm_ume_rcv_regid_func_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the application callback for registration ID setting.  <a href="structlbm__ume__rcv__regid__func__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__ume__rcv__regid__ex__func__t__stct.html">lbm_ume_rcv_regid_ex_func_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the application callback for registration ID setting, extended form.  <a href="structlbm__ume__rcv__regid__ex__func__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__ume__src__force__reclaim__func__t__stct.html">lbm_ume_src_force_reclaim_func_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the application callback for forced reclamation notifications.  <a href="structlbm__ume__src__force__reclaim__func__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__mim__unrecloss__func__t__stct.html">lbm_mim_unrecloss_func_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the application callback for multicast immediate message unrecoverable loss notification.  <a href="structlbm__mim__unrecloss__func__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__ume__rcv__recovery__info__ex__func__t__stct.html">lbm_ume_rcv_recovery_info_ex_func_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the application callback for recovery sequence number information, extended form.  <a href="structlbm__ume__rcv__recovery__info__ex__func__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__ume__store__entry__t__stct.html">lbm_ume_store_entry_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for a UMP store for configuration purposes.  <a href="structlbm__ume__store__entry__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__ucast__resolver__entry__t__stct.html">lbm_ucast_resolver_entry_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for a unicast resolver daemon for configuration purposes.  <a href="structlbm__ucast__resolver__entry__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__ume__store__name__entry__t__stct.html">lbm_ume_store_name_entry_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for a UMP store by name for configuration purposes.  <a href="structlbm__ume__store__name__entry__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__ume__store__group__entry__t__stct.html">lbm_ume_store_group_entry_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for a UMP store group for configuration purposes.  <a href="structlbm__ume__store__group__entry__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__rcv__src__notification__func__t__stct.html">lbm_rcv_src_notification_func_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the application callback for source status notifications for receivers.  <a href="structlbm__rcv__src__notification__func__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structume__liveness__receiving__context__t__stct.html">ume_liveness_receiving_context_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the information about a receiving context.  <a href="structume__liveness__receiving__context__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__ume__ctx__rcv__ctx__notification__func__t__stct.html">lbm_ume_ctx_rcv_ctx_notification_func_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the application callback for receiving context status notifications for source context.  <a href="structlbm__ume__ctx__rcv__ctx__notification__func__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__umq__queue__entry__t__stct.html">lbm_umq_queue_entry_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for a UMQ queue registration ID for configuration purposes.  <a href="structlbm__umq__queue__entry__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__umq__ulb__receiver__type__entry__t__stct.html">lbm_umq_ulb_receiver_type_entry_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for a UMQ ULB sources receiver type associations with application sets.  <a href="structlbm__umq__ulb__receiver__type__entry__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__umq__ulb__application__set__attr__t__stct.html">lbm_umq_ulb_application_set_attr_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for a UMQ ULB sources application set attributes.  <a href="structlbm__umq__ulb__application__set__attr__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__umq__ulb__receiver__type__attr__t__stct.html">lbm_umq_ulb_receiver_type_attr_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for a UMQ ULB sources receiver type attributes.  <a href="structlbm__umq__ulb__receiver__type__attr__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__context__src__event__func__t__stct.html">lbm_context_src_event_func_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the application callback for context-level source events.  <a href="structlbm__context__src__event__func__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__context__event__func__t__stct.html">lbm_context_event_func_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the application callback for context-level events.  <a href="structlbm__context__event__func__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__serialized__response__t__stct.html">lbm_serialized_response_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds a serialized UM response object.  <a href="structlbm__serialized__response__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__msg__fragment__info__t__stct.html">lbm_msg_fragment_info_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds fragment information for UM messages when appropriate.  <a href="structlbm__msg__fragment__info__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__msg__gateway__info__t__stct.html">lbm_msg_gateway_info_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds originating information for UM messages which arrived via a gateway.  <a href="structlbm__msg__gateway__info__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__msg__channel__info__t__stct.html">lbm_msg_channel_info_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that represents UMS Spectrum channel information.  <a href="structlbm__msg__channel__info__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that stores information about a received message.  <a href="structlbm__msg__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__context__rcv__immediate__msgs__func__t__stct.html">lbm_context_rcv_immediate_msgs_func_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the application callback for receiving topic-less immediate mode messages.  <a href="structlbm__context__rcv__immediate__msgs__func__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__transport__source__info__t__stct.html">lbm_transport_source_info_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds formatted and parsed transport source strings.  <a href="structlbm__transport__source__info__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__src__cost__func__t__stct.html">lbm_src_cost_func_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the "source_cost_evaluation_function" context attribute.  <a href="structlbm__src__cost__func__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_config_option_stct_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__wildcard__rcv__create__func__t__stct.html">lbm_wildcard_rcv_create_func_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the receiver creation callback information for wildcard receivers.  <a href="structlbm__wildcard__rcv__create__func__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__wildcard__rcv__delete__func__t__stct.html">lbm_wildcard_rcv_delete_func_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the receiver deletion callback information for wildcard receivers.  <a href="structlbm__wildcard__rcv__delete__func__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__src__transport__stats__tcp__t__stct.html">lbm_src_transport_stats_tcp_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds datagram statistics for source TCP transports.  <a href="structlbm__src__transport__stats__tcp__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__src__transport__stats__lbtrm__t__stct.html">lbm_src_transport_stats_lbtrm_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds datagram statistics for source LBT-RM transports.  <a href="structlbm__src__transport__stats__lbtrm__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__src__transport__stats__daemon__t__stct.html">lbm_src_transport_stats_daemon_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds statistics for source daemon mode transport (deprecated).  <a href="structlbm__src__transport__stats__daemon__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__src__transport__stats__lbtru__t__stct.html">lbm_src_transport_stats_lbtru_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds datagram statistics for source LBT-RU transports.  <a href="structlbm__src__transport__stats__lbtru__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__src__transport__stats__lbtipc__t__stct.html">lbm_src_transport_stats_lbtipc_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds datagram statistics for source LBT-IPC transports.  <a href="structlbm__src__transport__stats__lbtipc__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__src__transport__stats__lbtrdma__t__stct.html">lbm_src_transport_stats_lbtrdma_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds datagram statistics for source LBT-RDMA transports.  <a href="structlbm__src__transport__stats__lbtrdma__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__src__transport__stats__t__stct.html">lbm_src_transport_stats_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds statistics for source transports.  <a href="structlbm__src__transport__stats__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__rcv__transport__stats__tcp__t__stct.html">lbm_rcv_transport_stats_tcp_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds datagram statistics for receiver TCP transports.  <a href="structlbm__rcv__transport__stats__tcp__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__rcv__transport__stats__lbtrm__t__stct.html">lbm_rcv_transport_stats_lbtrm_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds datagram statistics for receiver LBT-RM transports.  <a href="structlbm__rcv__transport__stats__lbtrm__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__rcv__transport__stats__daemon__t__stct.html">lbm_rcv_transport_stats_daemon_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds statistics for receiver daemon mode transport (deprecated).  <a href="structlbm__rcv__transport__stats__daemon__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__rcv__transport__stats__lbtru__t__stct.html">lbm_rcv_transport_stats_lbtru_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds datagram statistics for receiver LBT-RU transports.  <a href="structlbm__rcv__transport__stats__lbtru__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__rcv__transport__stats__lbtipc__t__stct.html">lbm_rcv_transport_stats_lbtipc_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds datagram statistics for receiver LBT-IPC transports.  <a href="structlbm__rcv__transport__stats__lbtipc__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__rcv__transport__stats__lbtrdma__t__stct.html">lbm_rcv_transport_stats_lbtrdma_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds datagram statistics for receiver LBT-RDMA transports.  <a href="structlbm__rcv__transport__stats__lbtrdma__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__rcv__transport__stats__t__stct.html">lbm_rcv_transport_stats_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds statistics for receiver transports.  <a href="structlbm__rcv__transport__stats__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__event__queue__stats__t__stct.html">lbm_event_queue_stats_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds statistics for an event queue.  <a href="structlbm__event__queue__stats__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__context__stats__t__stct.html">lbm_context_stats_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds statistics for a context.  <a href="structlbm__context__stats__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__event__queue__cancel__cb__info__t__stct.html">lbm_event_queue_cancel_cb_info_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure passed to cancel/delete functions so that a cancel callback may be called.  <a href="structlbm__event__queue__cancel__cb__info__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__apphdr__chain__elem__t__stct.html">lbm_apphdr_chain_elem_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that represents an element in an app header chain.  <a href="structlbm__apphdr__chain__elem__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__msg__properties__iter__t__stct.html">lbm_msg_properties_iter_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A struct used for iterating over properties pointed to by an lbm_msg_properties_t.  <a href="structlbm__msg__properties__iter__t__stct.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlbm__umm__info__t__stct.html">lbm_umm_info_t_stct</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure for specifying UMM daemon connection options.  <a href="structlbm__umm__info__t__stct.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="19496d12ae944749435713218883d734"></a><!-- doxytag: member="lbm.h::LBM_VERS_MAJOR" ref="19496d12ae944749435713218883d734" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_VERS_MAJOR</b>&nbsp;&nbsp;&nbsp;5</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1e5ee898ac7fceda293800a42ba1bd4f"></a><!-- doxytag: member="lbm.h::LBM_VERS_MINOR" ref="1e5ee898ac7fceda293800a42ba1bd4f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_VERS_MINOR</b>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="78fd5c25f98ec34b6da86111425f72a7"></a><!-- doxytag: member="lbm.h::LBM_VERS_MAINT" ref="78fd5c25f98ec34b6da86111425f72a7" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_VERS_MAINT</b>&nbsp;&nbsp;&nbsp;6</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c2a4f967d3c6161bbb8a8d404b0cf0f1"></a><!-- doxytag: member="lbm.h::LBM_VERS_SFX" ref="c2a4f967d3c6161bbb8a8d404b0cf0f1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_VERS_SFX</b>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="14731be20af53b7571fdcfe319ca9584"></a><!-- doxytag: member="lbm.h::LBM_VERS_TAG" ref="14731be20af53b7571fdcfe319ca9584" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_VERS_TAG</b>&nbsp;&nbsp;&nbsp;&quot;&quot;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="097f20fae5281b3cc6bbea388e810a46"></a><!-- doxytag: member="lbm.h::LBM_VERS" ref="097f20fae5281b3cc6bbea388e810a46" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_VERS</b>&nbsp;&nbsp;&nbsp;(LBM_VERS_MAJOR*10000+LBM_VERS_MINOR*100+LBM_VERS_MAINT)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="af2f8b78274ac72f4b56c4ee8ef084ef"></a><!-- doxytag: member="lbm.h::PRIuSZ" ref="af2f8b78274ac72f4b56c4ee8ef084ef" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PRIuSZ</b>&nbsp;&nbsp;&nbsp;&quot;zu&quot;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="33073a87c63bfb22a09d7695ef02eb35"></a><!-- doxytag: member="lbm.h::PRIuSZcast" ref="33073a87c63bfb22a09d7695ef02eb35" args="(x)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>PRIuSZcast</b>(x)&nbsp;&nbsp;&nbsp;(size_t)(x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="aaa38f815050f17d0dba768788b1a0ca"></a><!-- doxytag: member="lbm.h::SCNuSZ" ref="aaa38f815050f17d0dba768788b1a0ca" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>SCNuSZ</b>&nbsp;&nbsp;&nbsp;&quot;zu&quot;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2f911b3da244150d88f423f457b60150"></a><!-- doxytag: member="lbm.h::SCNuSZcast" ref="2f911b3da244150d88f423f457b60150" args="(x)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>SCNuSZcast</b>(x)&nbsp;&nbsp;&nbsp;(size_t * )(x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b1ed45ed4d74f1d83449d8f699701b85"></a><!-- doxytag: member="lbm.h::LBMExpDLL" ref="b1ed45ed4d74f1d83449d8f699701b85" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBMExpDLL</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#df5e90fc057c91d8edfde3a6dacead36">LBM_EINVAL</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#75f0f83b8684df30d9816210cc20b4b0">LBM_EWOULDBLOCK</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#cb2933529ac090f72d189a6ef8bad81f">LBM_ENOMEM</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#24ee8abac59b5a0584c662c2eeddefb6">LBM_EOP</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#987b349dea4592bf3832af15ef66b22c">LBM_EOS</a>&nbsp;&nbsp;&nbsp;5</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#11df546da476e408cb7bb333b2a7c60a">LBM_ETIMEDOUT</a>&nbsp;&nbsp;&nbsp;6</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#2c339a557567c26309cdcfb7389f72a4">LBM_EDAEMONCONN</a>&nbsp;&nbsp;&nbsp;7</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#2ef169e3b343481d569a88755f22bd59">LBM_EUMENOREG</a>&nbsp;&nbsp;&nbsp;8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f2390eaa119a81bb0087b30c5b36aefa">LBM_EOPNOTSUPP</a>&nbsp;&nbsp;&nbsp;9</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#84ffe407ae998e9d27c51186e35ff558">LBM_EINPROGRESS</a>&nbsp;&nbsp;&nbsp;10</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#08de784eb29c9dd67d32ad87537616bc">LBM_ENO_QUEUE_REG</a>&nbsp;&nbsp;&nbsp;11</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#e5cf704243cf7e614863f2e535182676">LBM_ENO_STORE_REG</a>&nbsp;&nbsp;&nbsp;12</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#71d76f5ed5dbf09472d01d0620489376">LBM_EMSG_SELECTOR</a>&nbsp;&nbsp;&nbsp;14</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a47eb604db7dc9fd53f9650ed940e058">LBM_MSG_DATA</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#2647b87f92adb5a34ea129fbfeeed5a3">LBM_MSG_EOS</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b83f7de50ce32f69651a7252d84ea828">LBM_MSG_REQUEST</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#1d6c42864a4f2eb50d3300f12d8a33cb">LBM_MSG_RESPONSE</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#88920e0a4188081f9a14fc8f76c18578">LBM_MSG_UNRECOVERABLE_LOSS</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6629139aaf902976c8df9de3f37d10db">LBM_MSG_UNRECOVERABLE_LOSS_BURST</a>&nbsp;&nbsp;&nbsp;5</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#e5762d573ecd4a041f1d1326d35312aa">LBM_MSG_NO_SOURCE_NOTIFICATION</a>&nbsp;&nbsp;&nbsp;6</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#eb0203ec0c560a60c3b97017afc61ada">LBM_MSG_UME_REGISTRATION_ERROR</a>&nbsp;&nbsp;&nbsp;7</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#2ffe0658e008764982ad97128fedcaf0">LBM_MSG_UME_REGISTRATION_SUCCESS</a>&nbsp;&nbsp;&nbsp;8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c12f55e0cdd14bd4d389bb3ef3afded3">LBM_MSG_UME_REGISTRATION_CHANGE</a>&nbsp;&nbsp;&nbsp;9</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#cae32fc8bfc50769993fcea62e553bd8">LBM_MSG_UME_REGISTRATION_SUCCESS_EX</a>&nbsp;&nbsp;&nbsp;10</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b0571ebaf7704333a5503d1c0668a989">LBM_MSG_UME_REGISTRATION_COMPLETE_EX</a>&nbsp;&nbsp;&nbsp;11</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c6a7a25ddf1e95d30d686b967fd7e5c9">LBM_MSG_UME_DEREGISTRATION_SUCCESS_EX</a>&nbsp;&nbsp;&nbsp;12</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#86121aa40ecebeaa5c17e711dcd76b96">LBM_MSG_UME_DEREGISTRATION_COMPLETE_EX</a>&nbsp;&nbsp;&nbsp;13</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#9d1e2e6ee259b458a8a7097462ae7166">LBM_MSG_UMQ_REGISTRATION_ERROR</a>&nbsp;&nbsp;&nbsp;16</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f5cdc6cdb79853c73d03abac074e2d4c">LBM_MSG_UMQ_REGISTRATION_COMPLETE_EX</a>&nbsp;&nbsp;&nbsp;18</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#7e05596c569bc4043d30833347f92bba">LBM_MSG_UMQ_DEREGISTRATION_COMPLETE_EX</a>&nbsp;&nbsp;&nbsp;19</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b5489080adc7157549a9930b30c68425">LBM_MSG_BOS</a>&nbsp;&nbsp;&nbsp;20</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6fd9dbb2e6c9559c16fb2ad2e6c0781d">LBM_MSG_UMQ_INDEX_ASSIGNMENT_ELIGIBILITY_ERROR</a>&nbsp;&nbsp;&nbsp;21</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#0be80e79faa49ef9cb1e399c9bf436f6">LBM_MSG_UMQ_INDEX_ASSIGNMENT_ELIGIBILITY_START_COMPLETE_EX</a>&nbsp;&nbsp;&nbsp;22</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#cee7666e4e4d1b4ee55d4e580cf21c90">LBM_MSG_UMQ_INDEX_ASSIGNMENT_ELIGIBILITY_STOP_COMPLETE_EX</a>&nbsp;&nbsp;&nbsp;23</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#84058f898fab99ffe5652d64e105c1aa">LBM_MSG_UMQ_INDEX_ASSIGNED_EX</a>&nbsp;&nbsp;&nbsp;24</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#3ba42691e5f6f4f8f38b46ccce203ba4">LBM_MSG_UMQ_INDEX_RELEASED_EX</a>&nbsp;&nbsp;&nbsp;25</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#55784af6ed72244740c3d0509f9d4e84">LBM_MSG_UMQ_INDEX_ASSIGNMENT_ERROR</a>&nbsp;&nbsp;&nbsp;26</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#e451edfbf80aa1cf945bfc844563933a">LBM_MSG_HF_RESET</a>&nbsp;&nbsp;&nbsp;27</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ad39695c269efdb19af8371edaa3bb89">LBM_MSG_START_BATCH</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#8c283640e3e5ffdae94fd89900b38db4">LBM_MSG_END_BATCH</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#645d298b05f49d6b7ba11db4ce208584">LBM_MSG_COMPLETE_BATCH</a>&nbsp;&nbsp;&nbsp;0x3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ff5c45a7f7b65c5bde5988165b89fbd2">LBM_MSG_FLUSH</a>&nbsp;&nbsp;&nbsp;0x4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b8a470f02029480f179cc4872b7fa713">LBM_SRC_NONBLOCK</a>&nbsp;&nbsp;&nbsp;0x8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#51d2a9b83f28205fadae8ab9abf89b38">LBM_SRC_BLOCK_TEMP</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#41a6bc8b3a5d8670b4066cf14fbe2556">LBM_SRC_BLOCK</a>&nbsp;&nbsp;&nbsp;0x20</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f769aef242bc786cdbf9d0df28e06b2c">LBM_MSG_IOV_GATHER</a>&nbsp;&nbsp;&nbsp;0x40</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#e38db10baacaa5e86f2968993fb3e8a9">LBM_RCV_NONBLOCK</a>&nbsp;&nbsp;&nbsp;0x8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#01cfd803e98493dfc2c7988aaa7f4b79">LBM_RCV_BLOCK_TEMP</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ba03604772ef910a1c10064d8fcbd58d">LBM_RCV_BLOCK</a>&nbsp;&nbsp;&nbsp;0x20</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#4834e225e76aa9d4b4d32496552bae94">LBM_MSG_FLAG_START_BATCH</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#dc1c5e04a364561221d4f36285350f1f">LBM_MSG_FLAG_END_BATCH</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#cf728840c483a968c63f2b0613723725">LBM_MSG_FLAG_HF_PASS_THROUGH</a>&nbsp;&nbsp;&nbsp;0x4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#bae94fa27ea855156f5aac9962d5435c">LBM_MSG_FLAG_UME_RETRANSMIT</a>&nbsp;&nbsp;&nbsp;0x8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#1313dd3d0692d160c256956f48d023dd">LBM_MSG_FLAG_RETRANSMIT</a>&nbsp;&nbsp;&nbsp;0x8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#381f386fad7f6919d46676bd6e3f2d3a">LBM_MSG_FLAG_IMMEDIATE</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#9510697e9e5ab993733ec3063f107d86">LBM_MSG_FLAG_HF_DUPLICATE</a>&nbsp;&nbsp;&nbsp;0x20</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#560d3a276cb5cf3bd67b2617394e8a9e">LBM_MSG_FLAG_UMQ_REASSIGNED</a>&nbsp;&nbsp;&nbsp;0x40</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a56ddca7bfbc1b4f057ea5f0f1162582">LBM_MSG_FLAG_UMQ_RESUBMITTED</a>&nbsp;&nbsp;&nbsp;0x80</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f1c052d0506e76507dbc109e4d77160e">LBM_MSG_FLAG_TOPICLESS</a>&nbsp;&nbsp;&nbsp;0x100</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#84bff966269331fc0d7a8b61210b919b">LBM_MSG_FLAG_DELIVERY_LATENCY</a>&nbsp;&nbsp;&nbsp;0x200</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#768d9db1d811448e30738dd58125b699">LBM_MSG_FLAG_HF_OPTIONAL</a>&nbsp;&nbsp;&nbsp;0x400</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b2bf26e11ab181e8176a62300bfcbaff">LBM_MSG_FLAG_HF_32</a>&nbsp;&nbsp;&nbsp;0x800</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#9dfe5a7d9229f8683a1e5114bde50336">LBM_MSG_FLAG_HF_64</a>&nbsp;&nbsp;&nbsp;0x1000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#2b086d6bd8088880fe53f8b82d3d6eec">LBM_MSG_FLAG_OTR</a>&nbsp;&nbsp;&nbsp;0x2000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#749bcd06a6a03250751f6171a6522a7b">LBM_MSG_FLAG_NUMBERED_CHANNEL</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ab8c1c27f8edbea06cb38387b5146eb5">LBM_TOPIC_RES_REQUEST_RESERVED1</a>&nbsp;&nbsp;&nbsp;0x08</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#2d53d68f1969481af25a04c9f132408d">LBM_TOPIC_RES_REQUEST_ADVERTISEMENT</a>&nbsp;&nbsp;&nbsp;0x04</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b00ed9cd0b3212bdde1b4aeaf6d0bb12">LBM_TOPIC_RES_REQUEST_QUERY</a>&nbsp;&nbsp;&nbsp;0x02</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#598fc36ad06eb844dcc9ff8107ad87dd">LBM_TOPIC_RES_REQUEST_WILDCARD_QUERY</a>&nbsp;&nbsp;&nbsp;0x01</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#db8a3d729fdaa96b9729144ee86668ad">LBM_SRC_EVENT_CONNECT</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#cf50e4167d38a398bf5ae12c163ff2bb">LBM_SRC_EVENT_DISCONNECT</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a905cb268bbee255c71b74694370fe61">LBM_SRC_EVENT_WAKEUP</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#565d6e278372a69bf318b3cde5bfcb23">LBM_SRC_EVENT_DAEMON_CONFIRM</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b030d061f44d60babc7d9efba6769cc2">LBM_SRC_EVENT_UME_REGISTRATION_ERROR</a>&nbsp;&nbsp;&nbsp;5</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#eb34dd1f9e35b809f214b1a9b5f1bed9">LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS</a>&nbsp;&nbsp;&nbsp;6</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#9b8f0ee19762fe6d8c9a43ccdb0d94ef">LBM_SRC_EVENT_UME_MESSAGE_STABLE</a>&nbsp;&nbsp;&nbsp;7</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b9d560dcaaa6d7982d9590ae897ce0b5">LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION</a>&nbsp;&nbsp;&nbsp;8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#9505bdf346c03c9751b7d1c3755d4843">LBM_SRC_EVENT_UME_STORE_UNRESPONSIVE</a>&nbsp;&nbsp;&nbsp;9</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#d1821a408b0feaf8c28893ee79816dab">LBM_SRC_EVENT_UME_MESSAGE_RECLAIMED</a>&nbsp;&nbsp;&nbsp;10</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#99e39b5b7215553654f91f8b74ad98c8">LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX</a>&nbsp;&nbsp;&nbsp;11</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#1e46557c499f8e8f97bb7996a1662f26">LBM_SRC_EVENT_UME_REGISTRATION_COMPLETE_EX</a>&nbsp;&nbsp;&nbsp;12</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#cf1cedd5755e63083db63f3d45e45df6">LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX</a>&nbsp;&nbsp;&nbsp;13</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#e7124621f7cab5925ed8354690d736f9">LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX</a>&nbsp;&nbsp;&nbsp;14</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#350c2cab7f6f029276ebc323b7d73795">LBM_SRC_EVENT_SEQUENCE_NUMBER_INFO</a>&nbsp;&nbsp;&nbsp;15</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#2baee742e0a92121e87871afb2215ab5">LBM_SRC_EVENT_UMQ_REGISTRATION_ERROR</a>&nbsp;&nbsp;&nbsp;16</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#9145c5492742c8c53163874789d0d8b5">LBM_SRC_EVENT_UMQ_MESSAGE_ID_INFO</a>&nbsp;&nbsp;&nbsp;17</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a409add379c0380b2efa63f4095d69e4">LBM_SRC_EVENT_UMQ_REGISTRATION_COMPLETE_EX</a>&nbsp;&nbsp;&nbsp;18</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#65cd8e57a5b144f29cc70c8537c7d506">LBM_SRC_EVENT_UMQ_MESSAGE_STABLE_EX</a>&nbsp;&nbsp;&nbsp;19</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#9cfe28e7621da64e7c4a0cadd87314fa">LBM_SRC_EVENT_UMQ_ULB_MESSAGE_ASSIGNED_EX</a>&nbsp;&nbsp;&nbsp;20</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f5f5b23502005a15f3baa56ef898deff">LBM_SRC_EVENT_UMQ_ULB_MESSAGE_REASSIGNED_EX</a>&nbsp;&nbsp;&nbsp;21</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6defdca03dccc09650911b703601e532">LBM_SRC_EVENT_UMQ_ULB_MESSAGE_TIMEOUT_EX</a>&nbsp;&nbsp;&nbsp;22</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#4a7db539dc44a3ea20b28221a760d1ab">LBM_SRC_EVENT_UMQ_ULB_MESSAGE_COMPLETE_EX</a>&nbsp;&nbsp;&nbsp;23</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#9b09c5d3c47ada94e65653cdc8e3084f">LBM_SRC_EVENT_UMQ_ULB_MESSAGE_CONSUMED_EX</a>&nbsp;&nbsp;&nbsp;24</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#79201bd07423ee41ed965fabe08f0e24">LBM_SRC_EVENT_UMQ_ULB_RECEIVER_REGISTRATION_EX</a>&nbsp;&nbsp;&nbsp;25</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#3bbeb7b185382c984ae914eabeb38c1f">LBM_SRC_EVENT_UMQ_ULB_RECEIVER_DEREGISTRATION_EX</a>&nbsp;&nbsp;&nbsp;26</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#4f1ebd4914b356901f6decd9fe7e31c2">LBM_SRC_EVENT_UMQ_ULB_RECEIVER_READY_EX</a>&nbsp;&nbsp;&nbsp;27</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#00bee6cad8e118c8d3846d9a36dd32e3">LBM_SRC_EVENT_UMQ_ULB_RECEIVER_TIMEOUT_EX</a>&nbsp;&nbsp;&nbsp;28</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6d75dfecae9635b61c289efa3a8aa017">LBM_SRC_EVENT_FLIGHT_SIZE_NOTIFICATION</a>&nbsp;&nbsp;&nbsp;29</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#91689d8826be0160f64358ccfcff2877">LBM_SRC_EVENT_UME_MESSAGE_RECLAIMED_EX</a>&nbsp;&nbsp;&nbsp;30</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#161b30d489f39fde9ead22bea7e13c83">LBM_SRC_EVENT_UME_DEREGISTRATION_SUCCESS_EX</a>&nbsp;&nbsp;&nbsp;31</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#cd799cdd68375462a2b6dec522e0250b">LBM_SRC_EVENT_UME_DEREGISTRATION_COMPLETE_EX</a>&nbsp;&nbsp;&nbsp;32</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#5aa7c61a4613a1e63f75fb481796edd0">LBM_CONTEXT_EVENT_UMQ_REGISTRATION_COMPLETE_EX</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#027e25776e82d746adb67f3bbd6b95b6">LBM_CONTEXT_EVENT_UMQ_REGISTRATION_SUCCESS_EX</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#8c24d36b98bf3118143307d2e64182bf">LBM_CONTEXT_EVENT_UMQ_REGISTRATION_ERROR</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ec8f983c8bdc7abdb2d8dae56029acdf">LBM_CONTEXT_EVENT_UMQ_INSTANCE_LIST_NOTIFICATION</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#15f010b660c2d9093f2ff605b383da38">LBM_TRANSPORT_TYPE_TCP</a>&nbsp;&nbsp;&nbsp;0x00</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#5f0a2858a79f5865eb4df2c042e677c3">LBM_TRANSPORT_TYPE_LBTRU</a>&nbsp;&nbsp;&nbsp;0x01</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#baa12e19600af1560d72e4edd0175089">LBM_TRANSPORT_TYPE_LBTRM</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f267de2c80e4873002aa5814588cce81">LBM_TRANSPORT_TYPE_LBTIPC</a>&nbsp;&nbsp;&nbsp;0x40</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#79030d6b72ec8c7f4fd0450695876735">LBM_TRANSPORT_TYPE_LBTRDMA</a>&nbsp;&nbsp;&nbsp;0x20</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1cbed5e55b7f3455df89826c6515e884"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_OP_EMBEDDED" ref="1cbed5e55b7f3455df89826c6515e884" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_OP_EMBEDDED</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3ae501a14bc85cb48eaaaa505a44c4a0"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_OP_DAEMON" ref="3ae501a14bc85cb48eaaaa505a44c4a0" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_OP_DAEMON</b>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="486ff03da2f9986d7203adc1893cd673"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_OP_SEQUENTIAL" ref="486ff03da2f9986d7203adc1893cd673" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_OP_SEQUENTIAL</b>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="73390cd27e1256aa75060803bdaf1a22"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_FDTYPE_POLL" ref="73390cd27e1256aa75060803bdaf1a22" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_FDTYPE_POLL</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8205936a34169a4290c6a9af0fdf5183"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_FDTYPE_SELECT" ref="8205936a34169a4290c6a9af0fdf5183" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_FDTYPE_SELECT</b>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="083d3108cdbc25bbb5f94c866d576c42"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_FDTYPE_WSAEV" ref="083d3108cdbc25bbb5f94c866d576c42" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_FDTYPE_WSAEV</b>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="476920461a4c889751de07f228227e34"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_FDTYPE_WINCPORT" ref="476920461a4c889751de07f228227e34" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_FDTYPE_WINCPORT</b>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="be684c7f86d67257aee5376f5abdff1a"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_FDTYPE_WINCPORT_OV" ref="be684c7f86d67257aee5376f5abdff1a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_FDTYPE_WINCPORT_OV</b>&nbsp;&nbsp;&nbsp;5</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="27d26c66764804647024eb845fc7d53d"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_FDTYPE_EPOLL" ref="27d26c66764804647024eb845fc7d53d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_FDTYPE_EPOLL</b>&nbsp;&nbsp;&nbsp;6</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9eba3bf6d5882ef088bac115cdc75239"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_FDTYPE_DEVPOLL" ref="9eba3bf6d5882ef088bac115cdc75239" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_FDTYPE_DEVPOLL</b>&nbsp;&nbsp;&nbsp;7</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d8477736b87c664e209da14b34aebd29"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_FDTYPE_KQUEUE" ref="d8477736b87c664e209da14b34aebd29" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_FDTYPE_KQUEUE</b>&nbsp;&nbsp;&nbsp;8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fe7e75264479fd5a93af99debaf59e06"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_FDTYPE_WINRIOCPORT" ref="fe7e75264479fd5a93af99debaf59e06" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_FDTYPE_WINRIOCPORT</b>&nbsp;&nbsp;&nbsp;9</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fc6b2a64ce62ac7ab5f60ac095f8b782"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_MON_TRANSPORT_LBM" ref="fc6b2a64ce62ac7ab5f60ac095f8b782" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_MON_TRANSPORT_LBM</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a642f614205315232f9a83196dfc71c1"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_MON_TRANSPORT_LBMSNMP" ref="a642f614205315232f9a83196dfc71c1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_MON_TRANSPORT_LBMSNMP</b>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b6fc9472cc139298432dad3dcba410d1"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_IPC_RCV_THREAD_PEND" ref="b6fc9472cc139298432dad3dcba410d1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_IPC_RCV_THREAD_PEND</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0c8493c5d612a07c1d09a9e177e54476"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_IPC_RCV_THREAD_BUSY_WAIT" ref="0c8493c5d612a07c1d09a9e177e54476" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_IPC_RCV_THREAD_BUSY_WAIT</b>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ebf4837eb5136b6b0726ea9859a15c1c"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_RDMA_RCV_THREAD_PEND" ref="ebf4837eb5136b6b0726ea9859a15c1c" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_RDMA_RCV_THREAD_PEND</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bce537efb8c93ce87130df066a90d46c"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_RDMA_RCV_THREAD_BUSY_WAIT" ref="bce537efb8c93ce87130df066a90d46c" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_RDMA_RCV_THREAD_BUSY_WAIT</b>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9ee34bdbf57c9d793a4a61bed469c123"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_RCV_THRD_POOL_CREATE" ref="9ee34bdbf57c9d793a4a61bed469c123" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_RCV_THRD_POOL_CREATE</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cb2dd5f44e76c795f5578cc52d902e80"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_RCV_THRD_POOL_DYNAMIC" ref="cb2dd5f44e76c795f5578cc52d902e80" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_RCV_THRD_POOL_DYNAMIC</b>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3adf720d87af9645648ea6f61d9beca1"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_DEFAULT" ref="3adf720d87af9645648ea6f61d9beca1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_DEFAULT</b>&nbsp;&nbsp;&nbsp;0x00000000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c00ad3cc042eb58465cad845f7c267f7"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_3_6" ref="c00ad3cc042eb58465cad845f7c267f7" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_3_6</b>&nbsp;&nbsp;&nbsp;0x00030600</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="02bea2d750042d79dfb60611e9a21e37"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_3_6_1" ref="02bea2d750042d79dfb60611e9a21e37" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_3_6_1</b>&nbsp;&nbsp;&nbsp;0x00030601</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="18918deb887f6a74d26a2e064f6a80d4"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_3_6_2" ref="18918deb887f6a74d26a2e064f6a80d4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_3_6_2</b>&nbsp;&nbsp;&nbsp;0x00030602</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="27ba0220f10e6cfa80af9d568b313b9d"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_3_6_5" ref="27ba0220f10e6cfa80af9d568b313b9d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_3_6_5</b>&nbsp;&nbsp;&nbsp;0x00030605</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="81f4ba9d137854397c1dfaba878f889d"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_0" ref="81f4ba9d137854397c1dfaba878f889d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_0</b>&nbsp;&nbsp;&nbsp;0x00040000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="82738c5657c083f6c5eb22d6f6c7cddb"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_0_1" ref="82738c5657c083f6c5eb22d6f6c7cddb" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_0_1</b>&nbsp;&nbsp;&nbsp;0x00040001</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b52e3e2ed071ea57195bd43466ebeb49"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_1" ref="b52e3e2ed071ea57195bd43466ebeb49" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_1</b>&nbsp;&nbsp;&nbsp;0x00040100</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="85114a36283fea253a222929e150df7f"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_1_1" ref="85114a36283fea253a222929e150df7f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_1_1</b>&nbsp;&nbsp;&nbsp;0x00040101</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a2fe6c21fa5ac2625a70141166832487"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_1_2" ref="a2fe6c21fa5ac2625a70141166832487" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_1_2</b>&nbsp;&nbsp;&nbsp;0x00040102</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2d980c0a58d5066f1251a86a6c46eb07"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_1_3" ref="2d980c0a58d5066f1251a86a6c46eb07" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_1_3</b>&nbsp;&nbsp;&nbsp;0x00040103</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8ab3f9e705c168a45455cb0307fa8f68"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_2_1" ref="8ab3f9e705c168a45455cb0307fa8f68" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_2_1</b>&nbsp;&nbsp;&nbsp;0x00040201</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1c58804207b8d0eafe0644f6e3968475"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_2_2" ref="1c58804207b8d0eafe0644f6e3968475" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_2_2</b>&nbsp;&nbsp;&nbsp;0x00040202</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="722ee91b064ddafdf90cdddc18c2266c"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_2_3" ref="722ee91b064ddafdf90cdddc18c2266c" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_2_3</b>&nbsp;&nbsp;&nbsp;0x00040203</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c870bd598b7cbd921550073036c03762"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_2_4" ref="c870bd598b7cbd921550073036c03762" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_2_4</b>&nbsp;&nbsp;&nbsp;0x00040204</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="14524d832e2a81a439bec2ca6b97f36d"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_2_5" ref="14524d832e2a81a439bec2ca6b97f36d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_2_5</b>&nbsp;&nbsp;&nbsp;0x00040205</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="828724336d46570d9459e04fa424f458"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_2_6" ref="828724336d46570d9459e04fa424f458" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_2_6</b>&nbsp;&nbsp;&nbsp;0x00040206</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3cfbeca76ac700d15f3b8f4634378423"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_2_7" ref="3cfbeca76ac700d15f3b8f4634378423" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_2_7</b>&nbsp;&nbsp;&nbsp;0x00040207</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5dae5930e4f6827c0c1587cf50e7ab87"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_2_8" ref="5dae5930e4f6827c0c1587cf50e7ab87" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_LBM_4_2_8</b>&nbsp;&nbsp;&nbsp;0x00040208</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="16ff6379a62cf274d342ba01b9f1fa6a"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_0" ref="16ff6379a62cf274d342ba01b9f1fa6a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_0</b>&nbsp;&nbsp;&nbsp;0x01030000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ff5681f90a80211e5c8219e6fe6e4f78"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_0_1" ref="ff5681f90a80211e5c8219e6fe6e4f78" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_0_1</b>&nbsp;&nbsp;&nbsp;0x01030001</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="613a79c2d24b85975c56703fb1c20cf1"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_0_2" ref="613a79c2d24b85975c56703fb1c20cf1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_0_2</b>&nbsp;&nbsp;&nbsp;0x01030002</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="05e0f066a19c4ad006c0f2e77cc107ce"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_1" ref="05e0f066a19c4ad006c0f2e77cc107ce" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_1</b>&nbsp;&nbsp;&nbsp;0x01030100</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4cb5a559f7f0196d864f61990af9ecaf"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_1_1" ref="4cb5a559f7f0196d864f61990af9ecaf" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_1_1</b>&nbsp;&nbsp;&nbsp;0x01030101</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3bad83928569d054dfa9eb9f45b69306"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_1_2" ref="3bad83928569d054dfa9eb9f45b69306" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_1_2</b>&nbsp;&nbsp;&nbsp;0x01030102</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3b2983a3671a3f92b51bec1583845e94"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_1_3" ref="3b2983a3671a3f92b51bec1583845e94" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_1_3</b>&nbsp;&nbsp;&nbsp;0x01030103</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1d99825faf47025a3d569e35aad43a46"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_2_1" ref="1d99825faf47025a3d569e35aad43a46" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_2_1</b>&nbsp;&nbsp;&nbsp;0x01030201</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b8a75b81001ff0f78e013e24d5f8ee4a"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_2_2" ref="b8a75b81001ff0f78e013e24d5f8ee4a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_2_2</b>&nbsp;&nbsp;&nbsp;0x01030202</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3e7828f1de376cd8817fb1a2a8559c0f"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_2_3" ref="3e7828f1de376cd8817fb1a2a8559c0f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_2_3</b>&nbsp;&nbsp;&nbsp;0x01030203</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="54943be69feb1359e68e5c9bd19501f1"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_2_4" ref="54943be69feb1359e68e5c9bd19501f1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_2_4</b>&nbsp;&nbsp;&nbsp;0x01030204</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="62ed1858f6d4d6be2eddbb760a70a328"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_2_5" ref="62ed1858f6d4d6be2eddbb760a70a328" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_2_5</b>&nbsp;&nbsp;&nbsp;0x01030205</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f89c99e975dc8ed772f2f47bdec68b3a"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_2_6" ref="f89c99e975dc8ed772f2f47bdec68b3a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_2_6</b>&nbsp;&nbsp;&nbsp;0x01030206</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="abc1d9bd5b2978ae7d2f6e93ecc4b487"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_2_7" ref="abc1d9bd5b2978ae7d2f6e93ecc4b487" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_2_7</b>&nbsp;&nbsp;&nbsp;0x01030207</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fc85b408a75e990f1a09985d4e877f6d"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_2_8" ref="fc85b408a75e990f1a09985d4e877f6d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UME_3_2_8</b>&nbsp;&nbsp;&nbsp;0x01030208</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8756475505da9789d7e60444d536d6d8"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_1_0" ref="8756475505da9789d7e60444d536d6d8" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_1_0</b>&nbsp;&nbsp;&nbsp;0x02010000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="23e768e2e0fc3d9a49829a0110c6ba6b"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_1_1" ref="23e768e2e0fc3d9a49829a0110c6ba6b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_1_1</b>&nbsp;&nbsp;&nbsp;0x02010100</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="86ab7c407bf6c8478844cb732d7ae43e"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_1_1_1" ref="86ab7c407bf6c8478844cb732d7ae43e" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_1_1_1</b>&nbsp;&nbsp;&nbsp;0x02010101</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="01c9a60bfd9304c7be9c0d6a1c324790"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_2_0" ref="01c9a60bfd9304c7be9c0d6a1c324790" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_2_0</b>&nbsp;&nbsp;&nbsp;0x02020000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="47e6c84b80f34eee2f0c5337352dc290"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_2_0_1" ref="47e6c84b80f34eee2f0c5337352dc290" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_2_0_1</b>&nbsp;&nbsp;&nbsp;0x02020001</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="69bc98efa8a64f936e070e46e34b4e0f"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_2_1_1" ref="69bc98efa8a64f936e070e46e34b4e0f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_2_1_1</b>&nbsp;&nbsp;&nbsp;0x02020101</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b8715b96eb173bc432ea3688e774c550"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_2_1_3" ref="b8715b96eb173bc432ea3688e774c550" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_2_1_3</b>&nbsp;&nbsp;&nbsp;0x02020103</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fff39dd78d2ac780915750e929663e69"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_2_1_4" ref="fff39dd78d2ac780915750e929663e69" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_2_1_4</b>&nbsp;&nbsp;&nbsp;0x02020104</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="596165c2a4f4b613e03f21fcc627cf6f"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_2_1_5" ref="596165c2a4f4b613e03f21fcc627cf6f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_2_1_5</b>&nbsp;&nbsp;&nbsp;0x02020105</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3178073221e01ea5dc2048a586323b2a"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_2_1_6" ref="3178073221e01ea5dc2048a586323b2a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_2_1_6</b>&nbsp;&nbsp;&nbsp;0x02020106</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e319e0804185c192a939c9cd07f9d8e2"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_2_1_7" ref="e319e0804185c192a939c9cd07f9d8e2" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_2_1_7</b>&nbsp;&nbsp;&nbsp;0x02020107</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8f7d6e81f2a2f60788a24c0980b0724b"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_2_1_8" ref="8f7d6e81f2a2f60788a24c0980b0724b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_2_1_8</b>&nbsp;&nbsp;&nbsp;0x02020108</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bf83aaeb1cef654f79ba673301324de1"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_2_1_9" ref="bf83aaeb1cef654f79ba673301324de1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_2_1_9</b>&nbsp;&nbsp;&nbsp;0x02020109</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a7111cc391f23392aae657a85008ddd7"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_2_1_10" ref="a7111cc391f23392aae657a85008ddd7" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UMQ_2_1_10</b>&nbsp;&nbsp;&nbsp;0x0202010a</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c48aab6811a555fce1483aa6bb2470d9"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UM_5_0" ref="c48aab6811a555fce1483aa6bb2470d9" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UM_5_0</b>&nbsp;&nbsp;&nbsp;0x03050000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="62fd92497dfb0d632a9ff54e13095803"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UM_5_0_1" ref="62fd92497dfb0d632a9ff54e13095803" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UM_5_0_1</b>&nbsp;&nbsp;&nbsp;0x03050001</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f486ff18caca2731df6645a2de4f9a17"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UM_5_1" ref="f486ff18caca2731df6645a2de4f9a17" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UM_5_1</b>&nbsp;&nbsp;&nbsp;0x03050100</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7fe6d5b2abd2bb4c0475a5df8edaee26"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UM_5_1_1" ref="7fe6d5b2abd2bb4c0475a5df8edaee26" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UM_5_1_1</b>&nbsp;&nbsp;&nbsp;0x03050101</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9e7b5d01a4b40f11cb952c859d8325ef"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UM_5_1_2" ref="9e7b5d01a4b40f11cb952c859d8325ef" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UM_5_1_2</b>&nbsp;&nbsp;&nbsp;0x03050102</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9df06a48d4371738025891947fd41f3c"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UM_5_2" ref="9df06a48d4371738025891947fd41f3c" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UM_5_2</b>&nbsp;&nbsp;&nbsp;0x03050200</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="645086648515626a20d12cf1cf11f47a"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UM_5_2_1" ref="645086648515626a20d12cf1cf11f47a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UM_5_2_1</b>&nbsp;&nbsp;&nbsp;0x03050201</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7f5684e9570ea8737b93d0f067f92da5"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UM_5_2_2" ref="7f5684e9570ea8737b93d0f067f92da5" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UM_5_2_2</b>&nbsp;&nbsp;&nbsp;0x03050202</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ba65ce089e51f777bf20097a4f42cac6"></a><!-- doxytag: member="lbm.h::LBM_CTX_ATTR_NET_COMPAT_MODE_UM_5_3" ref="ba65ce089e51f777bf20097a4f42cac6" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_CTX_ATTR_NET_COMPAT_MODE_UM_5_3</b>&nbsp;&nbsp;&nbsp;0x03050300</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8ee120211ce7c89bccc40cd68befff4a"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_TRANSPORT_TCP" ref="8ee120211ce7c89bccc40cd68befff4a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_TRANSPORT_TCP</b>&nbsp;&nbsp;&nbsp;LBM_TRANSPORT_TYPE_TCP</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="008eb4cb80fffb68d73c82d89c117ac7"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_TRANSPORT_LBTRM" ref="008eb4cb80fffb68d73c82d89c117ac7" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_TRANSPORT_LBTRM</b>&nbsp;&nbsp;&nbsp;LBM_TRANSPORT_TYPE_LBTRM</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e2ce1833dc85c9c7f47723544740b66b"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_TRANSPORT_LBTRU" ref="e2ce1833dc85c9c7f47723544740b66b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_TRANSPORT_LBTRU</b>&nbsp;&nbsp;&nbsp;LBM_TRANSPORT_TYPE_LBTRU</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c68c5ba32927be143fae85702547d485"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_TRANSPORT_LBTIPC" ref="c68c5ba32927be143fae85702547d485" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_TRANSPORT_LBTIPC</b>&nbsp;&nbsp;&nbsp;LBM_TRANSPORT_TYPE_LBTIPC</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e8d50761f4677c19e5bed7a342c0109e"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_TRANSPORT_LBTRDMA" ref="e8d50761f4677c19e5bed7a342c0109e" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_TRANSPORT_LBTRDMA</b>&nbsp;&nbsp;&nbsp;LBM_TRANSPORT_TYPE_LBTRDMA</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5701e3f2ed683f366f5d2e76cbf92570"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_TCP_MULTI_RECV_NORMAL" ref="5701e3f2ed683f366f5d2e76cbf92570" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_TCP_MULTI_RECV_NORMAL</b>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d0ccd0d85d24f24bc81b004960d45013"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_TCP_MULTI_RECV_BOUNDED_LATENCY" ref="d0ccd0d85d24f24bc81b004960d45013" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_TCP_MULTI_RECV_BOUNDED_LATENCY</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3ff056385e39f0db63cbda35d133a4c6"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_TCP_MULTI_RECV_SOURCE_PACED" ref="3ff056385e39f0db63cbda35d133a4c6" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_TCP_MULTI_RECV_SOURCE_PACED</b>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e519e4dfb82160b2365435abbc3a486f"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_TCP_MULTI_RECV_SEND_ORDER_SERIAL" ref="e519e4dfb82160b2365435abbc3a486f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_TCP_MULTI_RECV_SEND_ORDER_SERIAL</b>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c5a3a71128eba61e2283527b297fb302"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_TCP_MULTI_RECV_SEND_ORDER_RANDOM" ref="c5a3a71128eba61e2283527b297fb302" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_TCP_MULTI_RECV_SEND_ORDER_RANDOM</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7e9e2c41f82da2d7e962cc897f12c358"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_SSF_NONE" ref="7e9e2c41f82da2d7e962cc897f12c358" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_SSF_NONE</b>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a9622db33b3ba882b886aea302c1766c"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_SSF_INCLUSION" ref="a9622db33b3ba882b886aea302c1766c" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_SSF_INCLUSION</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ddad8ea0f53521eda4e274bb7da0dba1"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_SSF_EXCLUSION" ref="ddad8ea0f53521eda4e274bb7da0dba1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_SSF_EXCLUSION</b>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7f6dd5ac3767654f68892afa50f20fa2"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_IMPLICIT_BATCH_TYPE_DEFAULT" ref="7f6dd5ac3767654f68892afa50f20fa2" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_IMPLICIT_BATCH_TYPE_DEFAULT</b>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2fe720a124f33a6e0300e3f3d08a2d55"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_IMPLICIT_BATCH_TYPE_ADAPTIVE" ref="2fe720a124f33a6e0300e3f3d08a2d55" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_IMPLICIT_BATCH_TYPE_ADAPTIVE</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8c1f3d0ad79acaca362a8d45e318da3f"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UME_STORE_BEHAVIOR_RR" ref="8c1f3d0ad79acaca362a8d45e318da3f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UME_STORE_BEHAVIOR_RR</b>&nbsp;&nbsp;&nbsp;0x0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b87603dc28f93be790aacf547d59eac8"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UME_STORE_BEHAVIOR_QC" ref="b87603dc28f93be790aacf547d59eac8" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UME_STORE_BEHAVIOR_QC</b>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="045ba56ca4914ea00092ee58917994db"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UME_QC_SQN_BEHAVIOR_LOWEST" ref="045ba56ca4914ea00092ee58917994db" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UME_QC_SQN_BEHAVIOR_LOWEST</b>&nbsp;&nbsp;&nbsp;0x0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e62ad561364626e836d6724bc28f304c"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UME_QC_SQN_BEHAVIOR_MAJORITY" ref="e62ad561364626e836d6724bc28f304c" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UME_QC_SQN_BEHAVIOR_MAJORITY</b>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3784fa44333db035f6ddfc73dbe50621"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UME_QC_SQN_BEHAVIOR_HIGHEST" ref="3784fa44333db035f6ddfc73dbe50621" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UME_QC_SQN_BEHAVIOR_HIGHEST</b>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e4fe906aabbf790c3ebd9eb640768bd3"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UME_STABLE_BEHAVIOR_ANY" ref="e4fe906aabbf790c3ebd9eb640768bd3" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UME_STABLE_BEHAVIOR_ANY</b>&nbsp;&nbsp;&nbsp;0x0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cf9867f0d50dc2492cdf9cbb57bcd320"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UME_STABLE_BEHAVIOR_MAJORITY" ref="cf9867f0d50dc2492cdf9cbb57bcd320" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UME_STABLE_BEHAVIOR_MAJORITY</b>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0e68a02ed2e18bd59f33a37cbbdddf91"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UME_STABLE_BEHAVIOR_QUORUM" ref="0e68a02ed2e18bd59f33a37cbbdddf91" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UME_STABLE_BEHAVIOR_QUORUM</b>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7db9bae12063c150887d234585d3a911"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UME_STABLE_BEHAVIOR_ALL" ref="7db9bae12063c150887d234585d3a911" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UME_STABLE_BEHAVIOR_ALL</b>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0f16d68ac221267b2cf2ca86792ce870"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UME_STABLE_BEHAVIOR_ALL_ACTIVE" ref="0f16d68ac221267b2cf2ca86792ce870" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UME_STABLE_BEHAVIOR_ALL_ACTIVE</b>&nbsp;&nbsp;&nbsp;0x3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c19b47390d9e41b05b057b352946f253"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UMQ_STABLE_BEHAVIOR_ANY" ref="c19b47390d9e41b05b057b352946f253" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UMQ_STABLE_BEHAVIOR_ANY</b>&nbsp;&nbsp;&nbsp;0x0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b183d4ad961ec18531ccdab743c30a3c"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UMQ_STABLE_BEHAVIOR_MAJORITY" ref="b183d4ad961ec18531ccdab743c30a3c" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UMQ_STABLE_BEHAVIOR_MAJORITY</b>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="da72598b1a1a29d002f34ab7512dab2d"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UMQ_STABLE_BEHAVIOR_QUORUM" ref="da72598b1a1a29d002f34ab7512dab2d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UMQ_STABLE_BEHAVIOR_QUORUM</b>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c43df51d829b8c49b18090ca65252fe6"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UMQ_STABLE_BEHAVIOR_ALL" ref="c43df51d829b8c49b18090ca65252fe6" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UMQ_STABLE_BEHAVIOR_ALL</b>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b5620cefeeaa84cdacde39041e43a1dc"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UMQ_STABLE_BEHAVIOR_ALL_ACTIVE" ref="b5620cefeeaa84cdacde39041e43a1dc" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UMQ_STABLE_BEHAVIOR_ALL_ACTIVE</b>&nbsp;&nbsp;&nbsp;0x3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5fb115d962875a27e5bf81176adf8faa"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_LBTIPC_BEHAVIOR_SOURCE_PACED" ref="5fb115d962875a27e5bf81176adf8faa" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_LBTIPC_BEHAVIOR_SOURCE_PACED</b>&nbsp;&nbsp;&nbsp;LBTIPC_BEHAVIOR_SRC_PACED</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4a9a4b248013b23ce54d7254eddecd85"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_LBTIPC_BEHAVIOR_RECEIVER_PACED" ref="4a9a4b248013b23ce54d7254eddecd85" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_LBTIPC_BEHAVIOR_RECEIVER_PACED</b>&nbsp;&nbsp;&nbsp;LBTIPC_BEHAVIOR_RCVR_PACED</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1d99bcec1bad6b447fefca7783dd33d9"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UMQ_ULB_EVENT_MSG_CONSUME" ref="1d99bcec1bad6b447fefca7783dd33d9" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UMQ_ULB_EVENT_MSG_CONSUME</b>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6975ac4452d97c48018cb9dc725fed40"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UMQ_ULB_EVENT_MSG_TIMEOUT" ref="6975ac4452d97c48018cb9dc725fed40" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UMQ_ULB_EVENT_MSG_TIMEOUT</b>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="afc51b7b5c363a1ddb2d542730b7a4e5"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UMQ_ULB_EVENT_MSG_ASSIGNMENT" ref="afc51b7b5c363a1ddb2d542730b7a4e5" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UMQ_ULB_EVENT_MSG_ASSIGNMENT</b>&nbsp;&nbsp;&nbsp;0x4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="35ae431b1329e9367e116ddc0ec1d998"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UMQ_ULB_EVENT_MSG_REASSIGNMENT" ref="35ae431b1329e9367e116ddc0ec1d998" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UMQ_ULB_EVENT_MSG_REASSIGNMENT</b>&nbsp;&nbsp;&nbsp;0x8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6a059661e3a487b7e6cfe3bc4be1b1eb"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UMQ_ULB_EVENT_MSG_COMPLETE" ref="6a059661e3a487b7e6cfe3bc4be1b1eb" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UMQ_ULB_EVENT_MSG_COMPLETE</b>&nbsp;&nbsp;&nbsp;0x10</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a77cad56261416fac8bd063d06bb6f0d"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UMQ_ULB_EVENT_RCV_TIMEOUT" ref="a77cad56261416fac8bd063d06bb6f0d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UMQ_ULB_EVENT_RCV_TIMEOUT</b>&nbsp;&nbsp;&nbsp;0x20</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="45dfe96cc7aa9aa027c7002b839eb5f7"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UMQ_ULB_EVENT_RCV_REGISTRATION" ref="45dfe96cc7aa9aa027c7002b839eb5f7" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UMQ_ULB_EVENT_RCV_REGISTRATION</b>&nbsp;&nbsp;&nbsp;0x40</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7149d94536c4ac1beb85d8a8f0c84ab8"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UMQ_ULB_EVENT_RCV_DEREGISTRATION" ref="7149d94536c4ac1beb85d8a8f0c84ab8" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UMQ_ULB_EVENT_RCV_DEREGISTRATION</b>&nbsp;&nbsp;&nbsp;0x80</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7d8aa849eb05b93ae73709d8f71fbd26"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UMQ_ULB_EVENT_RCV_READY" ref="7d8aa849eb05b93ae73709d8f71fbd26" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UMQ_ULB_EVENT_RCV_READY</b>&nbsp;&nbsp;&nbsp;0x100</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="74ce1c5fa2a82efd9e6ff43b2ebb6586"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UMQ_ULB_EVENT_ALL" ref="74ce1c5fa2a82efd9e6ff43b2ebb6586" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UMQ_ULB_EVENT_ALL</b>&nbsp;&nbsp;&nbsp;0x1FF</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="eca322b0d6c58513a0fc3a35a8ed4a77"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UMQ_ULB_ASSIGNMENT_DEFAULT" ref="eca322b0d6c58513a0fc3a35a8ed4a77" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UMQ_ULB_ASSIGNMENT_DEFAULT</b>&nbsp;&nbsp;&nbsp;0x0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="313fa77be1da5f4a544df78ea294674f"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UMQ_ULB_ASSIGNMENT_RANDOM" ref="313fa77be1da5f4a544df78ea294674f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UMQ_ULB_ASSIGNMENT_RANDOM</b>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8a1d80b48f30f11e35d1477307e67870"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UMQ_ULB_LF_BEHAVIOR_IGNORED" ref="8a1d80b48f30f11e35d1477307e67870" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UMQ_ULB_LF_BEHAVIOR_IGNORED</b>&nbsp;&nbsp;&nbsp;0x0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="90a14a31ccaaec42944940ee91214ca4"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UMQ_ULB_LF_BEHAVIOR_PROVISIONED" ref="90a14a31ccaaec42944940ee91214ca4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UMQ_ULB_LF_BEHAVIOR_PROVISIONED</b>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6b063d8540f5aecd3df824c7917f1c7d"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UMQ_ULB_LF_BEHAVIOR_DYNAMIC" ref="6b063d8540f5aecd3df824c7917f1c7d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UMQ_ULB_LF_BEHAVIOR_DYNAMIC</b>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fa2daeb7c552fff4efe488d58446266a"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UME_STABLE_EVENT_NONE" ref="fa2daeb7c552fff4efe488d58446266a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UME_STABLE_EVENT_NONE</b>&nbsp;&nbsp;&nbsp;0x0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c28dbbae559990c8493546fb72be99fc"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UME_STABLE_EVENT_PER_FRAGMENT" ref="c28dbbae559990c8493546fb72be99fc" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UME_STABLE_EVENT_PER_FRAGMENT</b>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2253d5c0e63d3030144be0fc912672b5"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UME_STABLE_EVENT_PER_MESSAGE" ref="2253d5c0e63d3030144be0fc912672b5" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UME_STABLE_EVENT_PER_MESSAGE</b>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0a560e08f724a65c45100db58dbdce4a"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UME_STABLE_EVENT_FRAG_AND_MSG" ref="0a560e08f724a65c45100db58dbdce4a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UME_STABLE_EVENT_FRAG_AND_MSG</b>&nbsp;&nbsp;&nbsp;0x3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3253f94a100376a123a0f4fbc63d150"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UME_CDELV_EVENT_NONE" ref="a3253f94a100376a123a0f4fbc63d150" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UME_CDELV_EVENT_NONE</b>&nbsp;&nbsp;&nbsp;0x0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2342802910fe0d5cbc4ecb0a5e9572f8"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UME_CDELV_EVENT_PER_FRAGMENT" ref="2342802910fe0d5cbc4ecb0a5e9572f8" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UME_CDELV_EVENT_PER_FRAGMENT</b>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6c90e481d11465deb866bbedf7594687"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UME_CDELV_EVENT_PER_MESSAGE" ref="6c90e481d11465deb866bbedf7594687" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UME_CDELV_EVENT_PER_MESSAGE</b>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="91ead038a6d3649212601019937cce37"></a><!-- doxytag: member="lbm.h::LBM_SRC_TOPIC_ATTR_UME_CDELV_EVENT_FRAG_AND_MSG" ref="91ead038a6d3649212601019937cce37" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_SRC_TOPIC_ATTR_UME_CDELV_EVENT_FRAG_AND_MSG</b>&nbsp;&nbsp;&nbsp;0x3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="435f03b84fcfcb4ff2cc1b4edf88be3a"></a><!-- doxytag: member="lbm.h::LBM_RCV_TOPIC_ATTR_UME_QC_SQN_BEHAVIOR_LOWEST" ref="435f03b84fcfcb4ff2cc1b4edf88be3a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_RCV_TOPIC_ATTR_UME_QC_SQN_BEHAVIOR_LOWEST</b>&nbsp;&nbsp;&nbsp;0x0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1aff5267c71bfaf77a27bfb4fec50eeb"></a><!-- doxytag: member="lbm.h::LBM_RCV_TOPIC_ATTR_UME_QC_SQN_BEHAVIOR_MAJORITY" ref="1aff5267c71bfaf77a27bfb4fec50eeb" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_RCV_TOPIC_ATTR_UME_QC_SQN_BEHAVIOR_MAJORITY</b>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0aea6398eb396f32d318267eb8222e83"></a><!-- doxytag: member="lbm.h::LBM_RCV_TOPIC_ATTR_UME_QC_SQN_BEHAVIOR_HIGHEST" ref="0aea6398eb396f32d318267eb8222e83" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_RCV_TOPIC_ATTR_UME_QC_SQN_BEHAVIOR_HIGHEST</b>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6569aff9898b9519d6493f53c11650ee"></a><!-- doxytag: member="lbm.h::LBM_RCV_TOPIC_ATTR_TCP_ACTIVITY_TIMEOUT_SO_KEEPALIVE" ref="6569aff9898b9519d6493f53c11650ee" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_RCV_TOPIC_ATTR_TCP_ACTIVITY_TIMEOUT_SO_KEEPALIVE</b>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3b5150252a089cd8cba91cdaf132d965"></a><!-- doxytag: member="lbm.h::LBM_RCV_TOPIC_ATTR_TCP_ACTIVITY_TIMEOUT_TIMER" ref="3b5150252a089cd8cba91cdaf132d965" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_RCV_TOPIC_ATTR_TCP_ACTIVITY_TIMEOUT_TIMER</b>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c657991c1a0e8cba70f5630dd43a54be"></a><!-- doxytag: member="lbm.h::LBM_RCV_TOPIC_ATTR_CHANNEL_BEHAVIOR_DELIVER_MSGS" ref="c657991c1a0e8cba70f5630dd43a54be" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_RCV_TOPIC_ATTR_CHANNEL_BEHAVIOR_DELIVER_MSGS</b>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f1eaad1b6d0f26d42035cd5cef831a12"></a><!-- doxytag: member="lbm.h::LBM_RCV_TOPIC_ATTR_CHANNEL_BEHAVIOR_DISCARD_MSGS" ref="f1eaad1b6d0f26d42035cd5cef831a12" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_RCV_TOPIC_ATTR_CHANNEL_BEHAVIOR_DISCARD_MSGS</b>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2ce28ef0c877ea0ad327a76049a2ffdd"></a><!-- doxytag: member="lbm.h::LBM_RCV_TOPIC_ATTR_UMQ_INDEX_ASSIGN_ELIGIBILITY_INELIGIBLE" ref="2ce28ef0c877ea0ad327a76049a2ffdd" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_RCV_TOPIC_ATTR_UMQ_INDEX_ASSIGN_ELIGIBILITY_INELIGIBLE</b>&nbsp;&nbsp;&nbsp;0x0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d23190eb7dd72fee320272c8afc59f56"></a><!-- doxytag: member="lbm.h::LBM_RCV_TOPIC_ATTR_UMQ_INDEX_ASSIGN_ELIGIBILITY_ELIGIBLE" ref="d23190eb7dd72fee320272c8afc59f56" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_RCV_TOPIC_ATTR_UMQ_INDEX_ASSIGN_ELIGIBILITY_ELIGIBLE</b>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4afad0143d6b67e61a5bc09a81559373"></a><!-- doxytag: member="lbm.h::LBM_RCV_TOPIC_ATTR_UMQ_QUEUE_PARTICIPATION_NONE" ref="4afad0143d6b67e61a5bc09a81559373" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_RCV_TOPIC_ATTR_UMQ_QUEUE_PARTICIPATION_NONE</b>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5d7a79f79064302279457d62076d048f"></a><!-- doxytag: member="lbm.h::LBM_RCV_TOPIC_ATTR_UMQ_QUEUE_PARTICIPATION_NORMAL" ref="5d7a79f79064302279457d62076d048f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_RCV_TOPIC_ATTR_UMQ_QUEUE_PARTICIPATION_NORMAL</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e9ebe9a7576efedd87af873d6a9a7d32"></a><!-- doxytag: member="lbm.h::LBM_RCV_TOPIC_ATTR_UMQ_QUEUE_PARTICIPATION_OBSERVER" ref="e9ebe9a7576efedd87af873d6a9a7d32" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_RCV_TOPIC_ATTR_UMQ_QUEUE_PARTICIPATION_OBSERVER</b>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8f45e346428cead7e2112e19a63a9504"></a><!-- doxytag: member="lbm.h::LBM_RCV_TOPIC_ATTR_UMQ_HOLD_INTERVAL_FOREVER" ref="8f45e346428cead7e2112e19a63a9504" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_RCV_TOPIC_ATTR_UMQ_HOLD_INTERVAL_FOREVER</b>&nbsp;&nbsp;&nbsp;0xFFFFFFFF</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="86fb6db711fba17d191e538fb331c590"></a><!-- doxytag: member="lbm.h::LBM_MSG_MAX_SOURCE_LEN" ref="86fb6db711fba17d191e538fb331c590" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_MSG_MAX_SOURCE_LEN</b>&nbsp;&nbsp;&nbsp;128</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dac987902e37de55e6e26e25a57a6ef5"></a><!-- doxytag: member="lbm.h::LBM_MSG_MAX_TOPIC_LEN" ref="dac987902e37de55e6e26e25a57a6ef5" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_MSG_MAX_TOPIC_LEN</b>&nbsp;&nbsp;&nbsp;256</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="260648a0d0458c429646817ef4067fb1"></a><!-- doxytag: member="lbm.h::LBM_MSG_MAX_STATE_LEN" ref="260648a0d0458c429646817ef4067fb1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_MSG_MAX_STATE_LEN</b>&nbsp;&nbsp;&nbsp;32</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6ab0da4efded572ae6e938da4e6e4a15"></a><!-- doxytag: member="lbm.h::LBM_UME_MAX_STORE_STRLEN" ref="6ab0da4efded572ae6e938da4e6e4a15" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_UME_MAX_STORE_STRLEN</b>&nbsp;&nbsp;&nbsp;24</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="82a1f98f9c6a3346590aefce12a43a64"></a><!-- doxytag: member="lbm.h::LBM_UMQ_MAX_QUEUE_STRLEN" ref="82a1f98f9c6a3346590aefce12a43a64" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_UMQ_MAX_QUEUE_STRLEN</b>&nbsp;&nbsp;&nbsp;256</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3b8ea5c520ce850ed73034ef9f1e62ce"></a><!-- doxytag: member="lbm.h::LBM_UMQ_MAX_TOPIC_STRLEN" ref="3b8ea5c520ce850ed73034ef9f1e62ce" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_UMQ_MAX_TOPIC_STRLEN</b>&nbsp;&nbsp;&nbsp;256</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="31dbd7c7cb942a8c584ac1d9ae38a836"></a><!-- doxytag: member="lbm.h::LBM_UMQ_MAX_APPSET_STRLEN" ref="31dbd7c7cb942a8c584ac1d9ae38a836" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_UMQ_MAX_APPSET_STRLEN</b>&nbsp;&nbsp;&nbsp;256</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b80e5ab33e6f44e3c1d27c3a560659ad"></a><!-- doxytag: member="lbm.h::LBM_MAX_CONTEXT_NAME_LEN" ref="b80e5ab33e6f44e3c1d27c3a560659ad" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_MAX_CONTEXT_NAME_LEN</b>&nbsp;&nbsp;&nbsp;128</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0b551ca1d43c4780e26718c0a8d51edf"></a><!-- doxytag: member="lbm.h::LBM_MAX_EVENT_QUEUE_NAME_LEN" ref="0b551ca1d43c4780e26718c0a8d51edf" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_MAX_EVENT_QUEUE_NAME_LEN</b>&nbsp;&nbsp;&nbsp;128</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="661e60ac7e9f7605a50fcc296faf298d"></a><!-- doxytag: member="lbm.h::LBM_UMQ_ULB_MAX_RECEIVER_STRLEN" ref="661e60ac7e9f7605a50fcc296faf298d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_UMQ_ULB_MAX_RECEIVER_STRLEN</b>&nbsp;&nbsp;&nbsp;32</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bcd89bbe4bc6fb6e744dda87e20fcbf3"></a><!-- doxytag: member="lbm.h::LBM_UMQ_MAX_INDEX_LEN" ref="bcd89bbe4bc6fb6e744dda87e20fcbf3" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_UMQ_MAX_INDEX_LEN</b>&nbsp;&nbsp;&nbsp;216</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="89a9bcf774d0f7a9767800145131173b"></a><!-- doxytag: member="lbm.h::LBM_UMQ_USER_NAME_LENGTH_MAX" ref="89a9bcf774d0f7a9767800145131173b" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_UMQ_USER_NAME_LENGTH_MAX</b>&nbsp;&nbsp;&nbsp;127</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="345d48f45d1ff38cd25367f3d6acc796"></a><!-- doxytag: member="lbm.h::LBM_UMQ_PASSWORD_LENGTH_MAX" ref="345d48f45d1ff38cd25367f3d6acc796" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_UMQ_PASSWORD_LENGTH_MAX</b>&nbsp;&nbsp;&nbsp;15</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c11cc4d4a3a78885264e5a7b1b317af6"></a><!-- doxytag: member="lbm.h::LBM_UMM_NUM_SERVERS_MAX" ref="c11cc4d4a3a78885264e5a7b1b317af6" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_UMM_NUM_SERVERS_MAX</b>&nbsp;&nbsp;&nbsp;16</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5a91a15ae2739bfa0e828ef4530e8326"></a><!-- doxytag: member="lbm.h::LBM_UMM_USER_NAME_LENGTH_MAX" ref="5a91a15ae2739bfa0e828ef4530e8326" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_UMM_USER_NAME_LENGTH_MAX</b>&nbsp;&nbsp;&nbsp;100</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a7d56e021ef331b8f86b4bd32dc6459c"></a><!-- doxytag: member="lbm.h::LBM_UMM_APP_NAME_LENGTH_MAX" ref="a7d56e021ef331b8f86b4bd32dc6459c" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_UMM_APP_NAME_LENGTH_MAX</b>&nbsp;&nbsp;&nbsp;100</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="457d9bb9cbf26e34cd97ca17e39f3b99"></a><!-- doxytag: member="lbm.h::LBM_UMM_PASSWORD_LENGTH_MAX" ref="457d9bb9cbf26e34cd97ca17e39f3b99" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_UMM_PASSWORD_LENGTH_MAX</b>&nbsp;&nbsp;&nbsp;100</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e62f4ec9854122851066821f8ae93f48"></a><!-- doxytag: member="lbm.h::LBM_UMM_SERVER_LENGTH_MAX" ref="e62f4ec9854122851066821f8ae93f48" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_UMM_SERVER_LENGTH_MAX</b>&nbsp;&nbsp;&nbsp;32</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6a53474eea121fe3b461ccb8d09437e4"></a><!-- doxytag: member="lbm.h::LBM_HMAC_BLOCK_SZ" ref="6a53474eea121fe3b461ccb8d09437e4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_HMAC_BLOCK_SZ</b>&nbsp;&nbsp;&nbsp;20</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f52c6bb653b8eb08f0be92f19576cd21"></a><!-- doxytag: member="lbm.h::LBM_FLIGHT_SIZE_BEHAVIOR_NOTIFY" ref="f52c6bb653b8eb08f0be92f19576cd21" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_FLIGHT_SIZE_BEHAVIOR_NOTIFY</b>&nbsp;&nbsp;&nbsp;0x0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8aad01588962569a876c385a9f73d283"></a><!-- doxytag: member="lbm.h::LBM_FLIGHT_SIZE_BEHAVIOR_BLOCK" ref="8aad01588962569a876c385a9f73d283" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_FLIGHT_SIZE_BEHAVIOR_BLOCK</b>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ba1b4477a130ebca41ca8fa07820acf8">LBM_FD_EVENT_READ</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#888ea40737dc555b9d8cad3e3170b790">LBM_FD_EVENT_WRITE</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#33de981e32d17806f4488a572e53d8c2">LBM_FD_EVENT_EXCEPT</a>&nbsp;&nbsp;&nbsp;0x4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a7202a258223ec773160a9a10b5a200f">LBM_FD_EVENT_ACCEPT</a>&nbsp;&nbsp;&nbsp;0x8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#85802e46728ea5804511097a66f7e8b4">LBM_FD_EVENT_CLOSE</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#50d726f1c661fbdc9ff1631c0d65fe11">LBM_FD_EVENT_CONNECT</a>&nbsp;&nbsp;&nbsp;0x20</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ad8b25f8f19d67d5e52acd69a4fe41d6">LBM_FD_EVENT_ALL</a>&nbsp;&nbsp;&nbsp;0x3f</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#2c6b535637bfd72be2905b0cd4782140">LBM_EVENT_QUEUE_BLOCK</a>&nbsp;&nbsp;&nbsp;0xFFFFFFFF</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#1995a85e2c983f6b38322c5c5784f32e">LBM_EVENT_QUEUE_POLL</a>&nbsp;&nbsp;&nbsp;0x0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#8d104d87acef6f7b27b2ad111861df81">LBM_EVENT_QUEUE_SIZE_WARNING</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#9bc366996c2e3fa52441096c2c322ca2">LBM_EVENT_QUEUE_DELAY_WARNING</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f0aeb1f5c969629a478e19f51913162e">LBM_EVENT_QUEUE_ENQUEUE_NOTIFICATION</a>&nbsp;&nbsp;&nbsp;0x3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#9b11d6d1f560c852821e0e71dee0a674">LBM_LOG_EMERG</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#68e312c699dc51992fb70a28ef775de5">LBM_LOG_ALERT</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#40934de7af6bbe51233bb81b2abd8ea4">LBM_LOG_CRIT</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#5924551ebcb0e0cc96ddacb76c60de24">LBM_LOG_ERR</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#bf896478100ba27f32ab0aa3bea3fe00">LBM_LOG_WARNING</a>&nbsp;&nbsp;&nbsp;5</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#95d263f41b71997ef7c073c3afb1eee9">LBM_LOG_NOTICE</a>&nbsp;&nbsp;&nbsp;6</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#4dda4ddf0e0916c80944fa9d626b5b21">LBM_LOG_INFO</a>&nbsp;&nbsp;&nbsp;7</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#e02fdb7032b05050cec7ab0d205562c8">LBM_LOG_DEBUG</a>&nbsp;&nbsp;&nbsp;8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#5ce6d6282cc249b1650e61304d02f595">LBM_DAEMON_EVENT_CONNECTED</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#77bf26d092500ee172a62df43b1a21a8">LBM_DAEMON_EVENT_CONNECT_ERROR</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#322412cb10f94f700ae2232d97d02530">LBM_DAEMON_EVENT_DISCONNECTED</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#3aded199e00f5f4f20b6f38fc2d4e179">LBM_DAEMON_EVENT_CONNECT_TIMEOUT</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6da60dbd4d5790ee0df30d6c3048f977">LBM_TRANSPORT_STAT_TCP</a>&nbsp;&nbsp;&nbsp;LBM_TRANSPORT_TYPE_TCP</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#32e0d3eee1fe69fa87e985f3343830b3">LBM_TRANSPORT_STAT_LBTRM</a>&nbsp;&nbsp;&nbsp;LBM_TRANSPORT_TYPE_LBTRM</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f2d3ee2ee236072c693d4854ea18fad2">LBM_TRANSPORT_STAT_DAEMON</a>&nbsp;&nbsp;&nbsp;0xFF</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#1f4acd28e4192be6809ce2cc496cb514">LBM_TRANSPORT_STAT_LBTRU</a>&nbsp;&nbsp;&nbsp;LBM_TRANSPORT_TYPE_LBTRU</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#64de821cc3a1afda47c5668996d16d9b">LBM_TRANSPORT_STAT_LBTIPC</a>&nbsp;&nbsp;&nbsp;LBM_TRANSPORT_TYPE_LBTIPC</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b8fc2e2fb0287dfa80713fb8fb6c23df">LBM_TRANSPORT_STAT_LBTRDMA</a>&nbsp;&nbsp;&nbsp;LBM_TRANSPORT_TYPE_LBTRDMA</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#45694a07474901f236317f2160276a2a">LBM_WILDCARD_RCV_PATTERN_TYPE_PCRE</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ec2a243ccda8dec97432e5f4c4520ae5">LBM_WILDCARD_RCV_PATTERN_TYPE_REGEX</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#e764ea8abf227789ef8d44c6dee9625f">LBM_WILDCARD_RCV_PATTERN_TYPE_APP_CB</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f9d73f2362f2d1bed196801a79afc993">LBM_SRC_EVENT_WAKEUP_FLAG_NORMAL</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#80c462e977454baadb0e3ef0c8255105">LBM_SRC_EVENT_WAKEUP_FLAG_MIM</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#18d855a3d5a9eb39a9148020eca733d9">LBM_SRC_EVENT_WAKEUP_FLAG_UIM</a>&nbsp;&nbsp;&nbsp;0x4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#e9bc7f5766b7c7eaf8829ee4c128cced">LBM_SRC_EVENT_WAKEUP_FLAG_REQUEST</a>&nbsp;&nbsp;&nbsp;0x8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#8281dbcdd348d03a6d7f7bc80bbbf650">LBM_SRC_EVENT_WAKEUP_FLAG_RESPONSE</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#8f49499d793faf9a36a19a4a522f4ff2">LBM_SRC_EVENT_UMQ_ULB_MESSAGE_TIMEOUT_EX_FLAG_TOTAL_LIFETIME_EXPIRED</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#10c3f354a4cd9d2ff3b03f58558d6b97">LBM_SRC_EVENT_UMQ_ULB_MESSAGE_TIMEOUT_EX_FLAG_EXPLICIT</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#7f795726e8119ace7fb061a1afea47e2">LBM_SRC_EVENT_UMQ_ULB_MESSAGE_TIMEOUT_EX_FLAG_DISCARD</a>&nbsp;&nbsp;&nbsp;0x4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f22450a211ef86eaa83aaa0f4c41876a">LBM_SRC_EVENT_UMQ_ULB_MESSAGE_TIMEOUT_EX_FLAG_MAX_REASSIGNS</a>&nbsp;&nbsp;&nbsp;0x8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#d1e214f4a013bcf2244772618c3ce44e">LBM_SRC_EVENT_UMQ_ULB_MESSAGE_REASSIGNED_EX_FLAG_EXPLICIT</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#802df02d3e81ef390217b22d123f8b9a">LBM_SRC_EVENT_FLIGHT_SIZE_NOTIFICATION_TYPE_UME</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#641ccdb2bad37d1dcf84dbded61a33cb">LBM_SRC_EVENT_FLIGHT_SIZE_NOTIFICATION_TYPE_ULB</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ead2957413a2955c6efa76d591455896">LBM_SRC_EVENT_FLIGHT_SIZE_NOTIFICATION_TYPE_UMQ</a>&nbsp;&nbsp;&nbsp;0x3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#117eda1a0792b41a8a6ffbab7becf834">LBM_SRC_EVENT_FLIGHT_SIZE_NOTIFICATION_STATE_OVER</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#df54f7b5bcae5127f6cf814945a62ab9">LBM_SRC_EVENT_FLIGHT_SIZE_NOTIFICATION_STATE_UNDER</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#8df58b9b0abb57cae51aa977a12e45b8">LBM_FLIGHT_SIZE_TYPE_UME</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#3b4465e642a1c4eb4dd48458ed98c314">LBM_FLIGHT_SIZE_TYPE_ULB</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#30c7a62d878cf9f9e4fcd366adc50eb4">LBM_FLIGHT_SIZE_TYPE_UMQ</a>&nbsp;&nbsp;&nbsp;0x3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#781e689ed6e1178938dc0b2e2bfabc06">LBM_SRC_SEND_EX_FLAG_UME_CLIENTD</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b5e0248995820580913a90b05ebd56ca">LBM_SRC_SEND_EX_FLAG_UMQ_CLIENTD</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b99586b3f3b469aa6f2e2da632fa5be0">LBM_SRC_SEND_EX_FLAG_SEQUENCE_NUMBER_INFO</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#e2b7b029ca6a3fcfc2cd67d809930a95">LBM_SRC_SEND_EX_FLAG_SEQUENCE_NUMBER_INFO_FRAGONLY</a>&nbsp;&nbsp;&nbsp;0x4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#71368905028cc0d6480c239a0228b49c">LBM_SRC_SEND_EX_FLAG_APPHDR_CHAIN</a>&nbsp;&nbsp;&nbsp;0x8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#3dced1476af472b3d4256a3d51683c4d">LBM_SRC_SEND_EX_FLAG_UMQ_MESSAGE_ID_INFO</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#148ccd9217cfe34e171c81c241f5375c">LBM_SRC_SEND_EX_FLAG_CHANNEL</a>&nbsp;&nbsp;&nbsp;0x20</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#01992618e0edcf2ca8aea4bc607c9d1e">LBM_SRC_SEND_EX_FLAG_UMQ_INDEX</a>&nbsp;&nbsp;&nbsp;0x40</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a04727ba812d6da49d6a4af74f0aac6f">LBM_SRC_SEND_EX_FLAG_UMQ_TOTAL_LIFETIME</a>&nbsp;&nbsp;&nbsp;0x80</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#5bf62d916b1acee97156dc8077ac3584">LBM_SRC_SEND_EX_FLAG_HF_OPTIONAL</a>&nbsp;&nbsp;&nbsp;0x100</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#169eb19b58d383875b718117b2def6e5">LBM_SRC_SEND_EX_FLAG_PROPERTIES</a>&nbsp;&nbsp;&nbsp;0x200</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#8fa0f4ed620fb82d08eec3f47db187be">LBM_SRC_SEND_EX_FLAG_HF_32</a>&nbsp;&nbsp;&nbsp;0x400</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c8dc3937fb55c66c86180c0ce2285318">LBM_SRC_SEND_EX_FLAG_HF_64</a>&nbsp;&nbsp;&nbsp;0x800</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6cad233ae9a9a1f4c48911c3e569ecee">LBM_MSG_PROPERTY_NONE</a>&nbsp;&nbsp;&nbsp;0x0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#de4e8a8380aead4cecd99d34074febd2">LBM_MSG_PROPERTY_BOOLEAN</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#3bc28e91b1571e511d7bf5f8c101cc43">LBM_MSG_PROPERTY_BYTE</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#cac3a9e4b1dc7d3d9f1d42acabbcd514">LBM_MSG_PROPERTY_SHORT</a>&nbsp;&nbsp;&nbsp;0x3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#77a1d3090e2e8e1dce799ae56859ce47">LBM_MSG_PROPERTY_INT</a>&nbsp;&nbsp;&nbsp;0x4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ac5202e17486cd42934756b8be785ad4">LBM_MSG_PROPERTY_LONG</a>&nbsp;&nbsp;&nbsp;0x5</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#179ee6d46f98f273b358bba2bdfba75c">LBM_MSG_PROPERTY_FLOAT</a>&nbsp;&nbsp;&nbsp;0x6</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#4bbd5d39680d349384d4e80079d602b2">LBM_MSG_PROPERTY_DOUBLE</a>&nbsp;&nbsp;&nbsp;0x7</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#bd04d3a94da9cc86cf2886b3f0849bb7">LBM_MSG_PROPERTY_STRING</a>&nbsp;&nbsp;&nbsp;0x8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ac271de581ec421ccf1bc4905ec4e52c">LBM_MSG_PROPERTIES_MAX_NAMELEN</a>&nbsp;&nbsp;&nbsp;250</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#18bc28f8841c79ad1532e699eb8aa426">LBM_CHAIN_ELEM_CHANNEL_NUMBER</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#683cfc4a78a744afc6a1e55fd3cbe458">LBM_CHAIN_ELEM_HF_SQN</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#4f25c3373d9f82d7e171df6b8b070801">LBM_CHAIN_ELEM_GW_INFO</a>&nbsp;&nbsp;&nbsp;0x3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#eed14db023c1109f428a1801616b01fe">LBM_CHAIN_ELEM_APPHDR</a>&nbsp;&nbsp;&nbsp;0x4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#37233effa75b0b79c0ad518010a96646">LBM_CHAIN_ELEM_USER_DATA</a>&nbsp;&nbsp;&nbsp;0x5</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#74bfca22086f34cee6fbe80ae46db358">LBM_CHAIN_ELEM_PROPERTIES_LENGTH</a>&nbsp;&nbsp;&nbsp;0x6</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#67fb27c8719fc6d535a1a6dbd9efcb06">LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_OLD</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#4a2bea66079c493cbcda44221eb84817">LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_NOACKS</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#356af56356f6619bc632ec3dc530dc95">LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_RPP</a>&nbsp;&nbsp;&nbsp;0x4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#1260065b954b5fd3d93dc375fdf8fa48">LBM_SRC_EVENT_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#4e0b6021726c4981d2e75ad11853af7a">LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_INTRAGROUP_STABLE</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#5209ab197cba9f57f03b8ae6a5f48585">LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_INTERGROUP_STABLE</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#379b0fa6121126b2f0e2d10904654142">LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_STABLE</a>&nbsp;&nbsp;&nbsp;0x4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#1a5d30c2598d27caf11355d276ea7d8c">LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_STORE</a>&nbsp;&nbsp;&nbsp;0x8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#5b5f204996c14a67f0e96847c3c49121">LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_WHOLE_MESSAGE_STABLE</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6432918a0f748a74ca565e1bfc90c5e6">LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_USER</a>&nbsp;&nbsp;&nbsp;0x20</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#07588ef8b95c9af845bdf5293961d23d">LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_UNIQUEACKS</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#d88a2ca8fd310da45f4eb38cc5c77d9f">LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_UREGID</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b669fba2eefaf6754ac963df27902099">LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_OOD</a>&nbsp;&nbsp;&nbsp;0x4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#149eecc4bad8748ef9a5a834e1272f5a">LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_EXACK</a>&nbsp;&nbsp;&nbsp;0x8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#7f14767a9e7acac796f11ab829ddd7d0">LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_WHOLE_MESSAGE_CONFIRMED</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6407f37e7d8b600732408d1ae4d0e9a5">LBM_SRC_EVENT_UME_MESSAGE_RECLAIMED_EX_FLAG_FORCED</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#10e26760ecc2f3b3b84a1fe71c2c2ae3">LBM_MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_OLD</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6006f0d0dcf4ccb6589cfbe1f3df2a28">LBM_MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_NOCACHE</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#e6eebed3b46d914bb37feddaac596db2">LBM_MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_RPP</a>&nbsp;&nbsp;&nbsp;0x4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#588a541d2af81ae40418a93501b8a236">LBM_MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#62fd6916bc53e965325d0e15df3aca47">LBM_MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_RXREQMAX</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#50deb1ea55d9025a31dbf6e4a429f6db">LBM_MSG_UME_DEREGISTRATION_SUCCESS_EX_FLAG_RPP</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#796234c441b154db2f88d433222c8223">LBM_CONTEXT_EVENT_UMQ_REGISTRATION_COMPLETE_EX_FLAG_QUORUM</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#30614c41c2a4ec374ee846bf87f0f5d1">LBM_SRC_EVENT_UMQ_REGISTRATION_COMPLETE_EX_FLAG_QUORUM</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f9f3a473d5fcd99707d5c291dfe1e8b7">LBM_SRC_EVENT_UMQ_MESSAGE_STABLE_EX_FLAG_INTRAGROUP_STABLE</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#d3602e1a062f6e505abcfa6eba2153b1">LBM_SRC_EVENT_UMQ_MESSAGE_STABLE_EX_FLAG_INTERGROUP_STABLE</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6e8dfa6aac8f88adc873651058c9f61f">LBM_SRC_EVENT_UMQ_MESSAGE_STABLE_EX_FLAG_STABLE</a>&nbsp;&nbsp;&nbsp;0x4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#4df886d1321f264f72fc5c17abc82e26">LBM_SRC_EVENT_UMQ_MESSAGE_STABLE_EX_FLAG_USER</a>&nbsp;&nbsp;&nbsp;0x8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f5b1c26869ce6144e5fba3fb65e6eb25">LBM_MSG_UMQ_REGISTRATION_COMPLETE_EX_FLAG_QUORUM</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#e21ffacef3953f86f1b4559c78d348f2">LBM_MSG_UMQ_REGISTRATION_COMPLETE_EX_FLAG_ULB</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#26ce01530072149fa87ea320a87b2d6b">LBM_MSG_UMQ_DEREGISTRATION_COMPLETE_EX_FLAG_ULB</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#0211c9dc0a470d7d5d88202d32d7272a">LBM_MSG_UMQ_INDEX_ASSIGNED_EX_FLAG_ULB</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#951a325a326d6ebd1e494c138238d138">LBM_MSG_UMQ_INDEX_ASSIGNED_EX_FLAG_REQUESTED</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#849bc0ca99de35c9e59d4f0202866b1f">LBM_MSG_UMQ_INDEX_RELEASED_EX_FLAG_ULB</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b7c5c80779193e392dbe64b8a04417ea">LBM_MSG_UMQ_INDEX_ASSIGNMENT_ELIGIBILITY_STOP_COMPLETE_EX_FLAG_ULB</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b998f932074057e2bca6bf7c471eb8bf">LBM_MSG_UMQ_INDEX_ASSIGNMENT_ELIGIBILITY_START_COMPLETE_EX_FLAG_ULB</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6c51a89970a7e1f98afc8c493bd9b86e">LBM_MSG_UMQ_REASSIGN_FLAG_DISCARD</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="27274185949c7a9d0959dfcb346d8383"></a><!-- doxytag: member="lbm.h::LBM_UME_LIVENESS_RECEIVER_UNRESPONSIVE_FLAG_TMO" ref="27274185949c7a9d0959dfcb346d8383" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_UME_LIVENESS_RECEIVER_UNRESPONSIVE_FLAG_TMO</b>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6f77734191e1fb254e92737f50685459"></a><!-- doxytag: member="lbm.h::LBM_UME_LIVENESS_RECEIVER_UNRESPONSIVE_FLAG_EOF" ref="6f77734191e1fb254e92737f50685459" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_UME_LIVENESS_RECEIVER_UNRESPONSIVE_FLAG_EOF</b>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#4ebecbc385d1e8724495408b628c868e">LBM_UMM_INFO_FLAGS_USE_SSL</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b2b27e1c9609d1981153cb46cd3c9baa"></a><!-- doxytag: member="lbm.h::LBM_TEXTMESSAGE" ref="b2b27e1c9609d1981153cb46cd3c9baa" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_TEXTMESSAGE</b>&nbsp;&nbsp;&nbsp;0;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d45256c1097eeb4b9ff4a10a8a794510"></a><!-- doxytag: member="lbm.h::LBM_BYTEMESSAGE" ref="d45256c1097eeb4b9ff4a10a8a794510" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_BYTEMESSAGE</b>&nbsp;&nbsp;&nbsp;1;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5fffaa3ab71604f23ecd1552016aeaf7"></a><!-- doxytag: member="lbm.h::LBM_MAPMESSAGE" ref="5fffaa3ab71604f23ecd1552016aeaf7" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_MAPMESSAGE</b>&nbsp;&nbsp;&nbsp;2;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="13f7c39c057e36964576dcf8ab159468"></a><!-- doxytag: member="lbm.h::LBM_MESSAGE" ref="13f7c39c057e36964576dcf8ab159468" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_MESSAGE</b>&nbsp;&nbsp;&nbsp;3;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2ff7b722aaa7a5ffc56f624a0755f786"></a><!-- doxytag: member="lbm.h::LBM_OBJECTMESSAGE" ref="2ff7b722aaa7a5ffc56f624a0755f786" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_OBJECTMESSAGE</b>&nbsp;&nbsp;&nbsp;4;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e634e8214a647e2bfcbfc927be989a96"></a><!-- doxytag: member="lbm.h::LBM_STREAMMESSAGE" ref="e634e8214a647e2bfcbfc927be989a96" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_STREAMMESSAGE</b>&nbsp;&nbsp;&nbsp;5;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d0a9ed9bca8a2e75d4e63322bc781f84"></a><!-- doxytag: member="lbm.h::LBM_JMSDeliveryMode" ref="d0a9ed9bca8a2e75d4e63322bc781f84" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_JMSDeliveryMode</b>&nbsp;&nbsp;&nbsp;&quot;JMSDeliveryMode&quot;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a7a2d38ca118d13a645939e7320774c8"></a><!-- doxytag: member="lbm.h::LBM_JMSExpiration" ref="a7a2d38ca118d13a645939e7320774c8" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_JMSExpiration</b>&nbsp;&nbsp;&nbsp;&quot;JMSExpiration&quot;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d4d45cdb39267000aa974a79890f146f"></a><!-- doxytag: member="lbm.h::LBM_JMSPriority" ref="d4d45cdb39267000aa974a79890f146f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_JMSPriority</b>&nbsp;&nbsp;&nbsp;&quot;JMSPriority&quot;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cb4a8da323f5c1850bcaa8dee90cb841"></a><!-- doxytag: member="lbm.h::LBM_JMSMessageID" ref="cb4a8da323f5c1850bcaa8dee90cb841" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_JMSMessageID</b>&nbsp;&nbsp;&nbsp;&quot;JMSMessageID&quot;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="31fc757e6feeef0b156b1362333e2d25"></a><!-- doxytag: member="lbm.h::LBM_JMSTimestamp" ref="31fc757e6feeef0b156b1362333e2d25" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_JMSTimestamp</b>&nbsp;&nbsp;&nbsp;&quot;JMSTimestamp&quot;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c24f362075ccebd992d9bfc2247bc3d5"></a><!-- doxytag: member="lbm.h::LBM_JMSCorrelationID" ref="c24f362075ccebd992d9bfc2247bc3d5" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_JMSCorrelationID</b>&nbsp;&nbsp;&nbsp;&quot;JMSCorrelationID&quot;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fc6bfcfb6f227b66543b86b00c222085"></a><!-- doxytag: member="lbm.h::LBM_JMSType" ref="fc6bfcfb6f227b66543b86b00c222085" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_JMSType</b>&nbsp;&nbsp;&nbsp;&quot;JMSType&quot;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0c05d6b15b8d4249811edc294a175923"></a><!-- doxytag: member="lbm.h::LBM_JMSRedelivered" ref="0c05d6b15b8d4249811edc294a175923" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_JMSRedelivered</b>&nbsp;&nbsp;&nbsp;&quot;JMSRedelivered&quot;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dd1c84d89d6b13e6f08fd63a48d35dae"></a><!-- doxytag: member="lbm.h::LBM_LBMMessageType" ref="dd1c84d89d6b13e6f08fd63a48d35dae" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_LBMMessageType</b>&nbsp;&nbsp;&nbsp;&quot;LBMMessageType&quot;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="855dc1943a58bc86f63b311c5b328199"></a><!-- doxytag: member="lbm.h::LBM_JMSTopicType" ref="855dc1943a58bc86f63b311c5b328199" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_JMSTopicType</b>&nbsp;&nbsp;&nbsp;&quot;JMSTopicType&quot;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5ab5f2e846499d8e501ce9c2c4fc2a26"></a><!-- doxytag: member="lbm.h::LBM_JMSReplyToName" ref="5ab5f2e846499d8e501ce9c2c4fc2a26" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_JMSReplyToName</b>&nbsp;&nbsp;&nbsp;&quot;JMSReplyToName&quot;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="30d87345472ca6984105427a5a26a023"></a><!-- doxytag: member="lbm.h::LBM_JMSReplyToWildcard" ref="30d87345472ca6984105427a5a26a023" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_JMSReplyToWildcard</b>&nbsp;&nbsp;&nbsp;&quot;JMSReplyToWildcard&quot;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2d753f44d498aa0026b8151938fd9b9e"></a><!-- doxytag: member="lbm.h::LBM_JMSReplyToType" ref="2d753f44d498aa0026b8151938fd9b9e" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_JMSReplyToType</b>&nbsp;&nbsp;&nbsp;&quot;JMSReplyToType&quot;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f7d862945bad2b578cc75fb1ec6b6b50"></a><!-- doxytag: member="lbm.h::LBM_EXTERNAL_STRUCT_FILL_SIZE" ref="f7d862945bad2b578cc75fb1ec6b6b50" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>LBM_EXTERNAL_STRUCT_FILL_SIZE</b>&nbsp;&nbsp;&nbsp;(512)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#3cf89159246e4b3c518ae90a3f460ff9">LBM_UMQ_INDEX_FLAG_NUMERIC</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="90a9c177ec57faac06f65cb13571b841"></a><!-- doxytag: member="lbm.h::LBM_UMQ_QUEUE_MSG_STATUS_UNKNOWN" ref="90a9c177ec57faac06f65cb13571b841" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#90a9c177ec57faac06f65cb13571b841">LBM_UMQ_QUEUE_MSG_STATUS_UNKNOWN</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queue message status; queue has no knowledge of the message. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c1ba1eca0a613a6d99c4307b006c0d64"></a><!-- doxytag: member="lbm.h::LBM_UMQ_QUEUE_MSG_STATUS_UNASSIGNED" ref="c1ba1eca0a613a6d99c4307b006c0d64" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c1ba1eca0a613a6d99c4307b006c0d64">LBM_UMQ_QUEUE_MSG_STATUS_UNASSIGNED</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queue message status; message is currently enqueued but not yet assigned. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8936000abf1190c32a613dcccdff7924"></a><!-- doxytag: member="lbm.h::LBM_UMQ_QUEUE_MSG_STATUS_ASSIGNED" ref="8936000abf1190c32a613dcccdff7924" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#8936000abf1190c32a613dcccdff7924">LBM_UMQ_QUEUE_MSG_STATUS_ASSIGNED</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queue message status; message is currently assigned to a receiver but not yet consumed. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f4b83e6b46d14665863e7f9891ec135c"></a><!-- doxytag: member="lbm.h::LBM_UMQ_QUEUE_MSG_STATUS_REASSIGNING" ref="f4b83e6b46d14665863e7f9891ec135c" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f4b83e6b46d14665863e7f9891ec135c">LBM_UMQ_QUEUE_MSG_STATUS_REASSIGNING</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queue message status; message is waiting to be re-assigned to a different receiver. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ad7023aaefa277f6149504ab79f3abac"></a><!-- doxytag: member="lbm.h::LBM_UMQ_QUEUE_MSG_STATUS_CONSUMED" ref="ad7023aaefa277f6149504ab79f3abac" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ad7023aaefa277f6149504ab79f3abac">LBM_UMQ_QUEUE_MSG_STATUS_CONSUMED</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Queue message status; message has been fully consumed and is no longer present in the queue. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#d48acd1ecb2e4429b8b0fd7f041c6428">LBM_ASYNC_OP_TYPE_CTX_UMQ_QUEUE_TOPIC_LIST</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#080d784d8bd2cb03d396aa6394289343">LBM_ASYNC_OP_TYPE_RCV_UMQ_QUEUE_MSG_LIST</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ae8a7e90c8ada5ef5e012eb18af8a432">LBM_ASYNC_OP_TYPE_RCV_UMQ_QUEUE_MSG_RETRIEVE</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#386dfee7ceddf177eb333f21f85b755d">LBM_ASYNC_OP_STATUS_IN_PROGRESS</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#d44e943d8314ce64e5b9e9183c1daad7">LBM_ASYNC_OP_STATUS_COMPLETE</a>&nbsp;&nbsp;&nbsp;128</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#d4076e6e838f9f8da91cc7f47526af83">LBM_ASYNC_OP_STATUS_ERROR</a>&nbsp;&nbsp;&nbsp;129</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#0e5bcc04f0c21960959f728dea59aeac">LBM_ASYNC_OP_STATUS_CANCELED</a>&nbsp;&nbsp;&nbsp;130</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#29916ecc9d06a54da09566123fabe253">LBM_ASYNC_OP_INVALID_HANDLE</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#86f86ebba51cabc4d9cc18dab73c97b0">LBM_ASYNC_OPERATION_CANCEL_FLAG_NONBLOCK</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#8a1c382c7c7f649bb31c58b072100d59">LBM_ASYNC_OPERATION_STATUS_FLAG_NONBLOCK</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#246de64eb8052dcaebe8e2df5c746c81">LBM_ASYNC_OP_INFO_FLAG_INLINE</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#1a656fc626c82c157958ca130e40f736">LBM_ASYNC_OP_INFO_FLAG_FIRST</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#55ea28122623c30d172e1530b00c1161">LBM_ASYNC_OP_INFO_FLAG_LAST</a>&nbsp;&nbsp;&nbsp;0x4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ef236f453e8dea50ddc88a3111ba692b">LBM_ASYNC_OP_INFO_FLAG_ONLY</a>&nbsp;&nbsp;&nbsp;(LBM_ASYNC_OP_INFO_FLAG_FIRST | LBM_ASYNC_OP_INFO_FLAG_LAST)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ede9b7b462cd83fd6e46346260a134ca">LBM_SRC_COST_FUNCTION_REJECT</a>&nbsp;&nbsp;&nbsp;0xffffffff</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1b72738e9fd3156224fd8441acb1e488"></a><!-- doxytag: member="lbm.h::LBM_CONFIG_OPTIONS_STR_LEN" ref="1b72738e9fd3156224fd8441acb1e488" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#1b72738e9fd3156224fd8441acb1e488">LBM_CONFIG_OPTIONS_STR_LEN</a>&nbsp;&nbsp;&nbsp;128</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Config option structure holding the option name and value via string types. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="21145cd6f47ee35f1e0970cf8e0b4775"></a><!-- doxytag: member="lbm.h::lbm_rcv_retrieve_all_transport_stats" ref="21145cd6f47ee35f1e0970cf8e0b4775" args="(r, n, s)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_rcv_retrieve_all_transport_stats</b>(r, n, s)&nbsp;&nbsp;&nbsp;lbm_rcv_retrieve_all_transport_stats_ex(r,n,sizeof(<a class="el" href="structlbm__rcv__transport__stats__t__stct.html">lbm_rcv_transport_stats_t</a>),s)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6fc3ae7b78d93319cd4282110e42b9d6"></a><!-- doxytag: member="lbm.h::lbm_context_retrieve_rcv_transport_stats" ref="6fc3ae7b78d93319cd4282110e42b9d6" args="(c, n, s)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_context_retrieve_rcv_transport_stats</b>(c, n, s)&nbsp;&nbsp;&nbsp;lbm_context_retrieve_rcv_transport_stats_ex(c,n,sizeof(<a class="el" href="structlbm__rcv__transport__stats__t__stct.html">lbm_rcv_transport_stats_t</a>),s)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="21632cb5bf674584a34b098afe6abd14"></a><!-- doxytag: member="lbm.h::lbm_context_retrieve_src_transport_stats" ref="21632cb5bf674584a34b098afe6abd14" args="(c, n, s)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_context_retrieve_src_transport_stats</b>(c, n, s)&nbsp;&nbsp;&nbsp;lbm_context_retrieve_src_transport_stats_ex(c,n,sizeof(<a class="el" href="structlbm__src__transport__stats__t__stct.html">lbm_src_transport_stats_t</a>),s)</td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bdb96b55cc467a75e1f9ec0036dbc14b"></a><!-- doxytag: member="lbm.h::lbm_uint_t" ref="bdb96b55cc467a75e1f9ec0036dbc14b" args="" -->
typedef unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_uint_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="72438fab15bf500af58d2a8a521e470d"></a><!-- doxytag: member="lbm.h::lbm_ulong_t" ref="72438fab15bf500af58d2a8a521e470d" args="" -->
typedef unsigned long int&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_ulong_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="46699a1cfc611df32e6cce3fb5100aae"></a><!-- doxytag: member="lbm.h::lbm_ushort_t" ref="46699a1cfc611df32e6cce3fb5100aae" args="" -->
typedef unsigned short int&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_ushort_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1a3446d822773f3a19f6dfd5b480410f"></a><!-- doxytag: member="lbm.h::lbm_uchar_t" ref="1a3446d822773f3a19f6dfd5b480410f" args="" -->
typedef unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_uchar_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="09c7963deb485135d5bb29c84cd7d3a9"></a><!-- doxytag: member="lbm.h::lbm_uint8_t" ref="09c7963deb485135d5bb29c84cd7d3a9" args="" -->
typedef uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_uint8_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="86897f2fdd66aa7021683a4e72a4537b"></a><!-- doxytag: member="lbm.h::lbm_uint16_t" ref="86897f2fdd66aa7021683a4e72a4537b" args="" -->
typedef uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_uint16_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5dfd61ade99cd24213125c293b15ef4a"></a><!-- doxytag: member="lbm.h::lbm_uint32_t" ref="5dfd61ade99cd24213125c293b15ef4a" args="" -->
typedef uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_uint32_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1e4dea682eee7238dec2b64989449abc"></a><!-- doxytag: member="lbm.h::lbm_uint64_t" ref="1e4dea682eee7238dec2b64989449abc" args="" -->
typedef uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_uint64_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c80aef6c36b7e5ae0984d81ab4af062a"></a><!-- doxytag: member="lbm.h::lbm_int64_t" ref="c80aef6c36b7e5ae0984d81ab4af062a" args="" -->
typedef int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_int64_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c2d647f3b4c6a31eb045441309fd9704"></a><!-- doxytag: member="lbm.h::lbm_handle_t" ref="c2d647f3b4c6a31eb045441309fd9704" args="" -->
typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_handle_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__iovec__t__stct.html">lbm_iovec_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#0cc1e47e9e1aec978aaded128bb7ce55">lbm_iovec_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure, struct iovec compatible, that holds information about buffers used for vectored sends.  <a href="#0cc1e47e9e1aec978aaded128bb7ce55"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__ipv4__address__mask__t__stct.html">lbm_ipv4_address_mask_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#0b66a5b33839617b2a822e4a20a8d535">lbm_ipv4_address_mask_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds an IPv4 address and a CIDR style netmask.  <a href="#0b66a5b33839617b2a822e4a20a8d535"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__timeval__t__stct.html">lbm_timeval_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#00b4a00d4c5a4892743027ea6cab128b">lbm_timeval_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds seconds and microseconds since midnight, Jan 1, 1970 UTC.  <a href="#00b4a00d4c5a4892743027ea6cab128b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__src__event__wakeup__t__stct.html">lbm_src_event_wakeup_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#4a090ffb298662b540d2fbd4f8add876">lbm_src_event_wakeup_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds source wakeup event data.  <a href="#4a090ffb298662b540d2fbd4f8add876"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__src__event__flight__size__notification__t__stct.html">lbm_src_event_flight_size_notification_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#1c4371e4c1113403ea0fb11bce39491f">lbm_src_event_flight_size_notification_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds flight size notification event data.  <a href="#1c4371e4c1113403ea0fb11bce39491f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__src__event__ume__registration__t__stct.html">lbm_src_event_ume_registration_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b7fc3babd8a74705e4308cd316aa936a">lbm_src_event_ume_registration_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds store registration information for the UMP source.  <a href="#b7fc3babd8a74705e4308cd316aa936a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__src__event__ume__registration__ex__t__stct.html">lbm_src_event_ume_registration_ex_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#008e15024174fd5d7645ced0d2e64d2c">lbm_src_event_ume_registration_ex_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds store registration information for the UMP source in an extended form.  <a href="#008e15024174fd5d7645ced0d2e64d2c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__src__event__ume__registration__complete__ex__t__stct.html">lbm_src_event_ume_registration_complete_ex_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6882015f7887a89297176d3af343679c">lbm_src_event_ume_registration_complete_ex_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for sources after registration is complete to all involved stores.  <a href="#6882015f7887a89297176d3af343679c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__src__event__ume__deregistration__ex__t__stct.html">lbm_src_event_ume_deregistration_ex_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#5ef1981e96c8f4a3f4c7b75aee02ffab">lbm_src_event_ume_deregistration_ex_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds store deregistration information for the UMP source in an extended form.  <a href="#5ef1981e96c8f4a3f4c7b75aee02ffab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__msg__ume__registration__t__stct.html">lbm_msg_ume_registration_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#96d698804703ba4a5af6270e3793e701">lbm_msg_ume_registration_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds store registration information for the UMP receiver.  <a href="#96d698804703ba4a5af6270e3793e701"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__msg__ume__registration__ex__t__stct.html">lbm_msg_ume_registration_ex_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#2a896740a179ab09f615c632776db385">lbm_msg_ume_registration_ex_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds store registration information for the UM receiver in an extended form.  <a href="#2a896740a179ab09f615c632776db385"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__msg__ume__registration__complete__ex__t__stct.html">lbm_msg_ume_registration_complete_ex_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#d9ba4ab7929365987c9f7ed17554d498">lbm_msg_ume_registration_complete_ex_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for receivers after registration is complete to all involved stores.  <a href="#d9ba4ab7929365987c9f7ed17554d498"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__msg__ume__deregistration__ex__t__stct.html">lbm_msg_ume_deregistration_ex_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6d5e0cfca8c0720107c6d592c32d5144">lbm_msg_ume_deregistration_ex_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds store deregistration information for the UM receiver in an extended form.  <a href="#6d5e0cfca8c0720107c6d592c32d5144"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__src__event__ume__ack__info__t__stct.html">lbm_src_event_ume_ack_info_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#cedfa758947867f55085a48150f9a17d">lbm_src_event_ume_ack_info_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds ACK information for a given message.  <a href="#cedfa758947867f55085a48150f9a17d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__src__event__ume__ack__ex__info__t__stct.html">lbm_src_event_ume_ack_ex_info_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#7b945939b994bf1e7163d55b2256f3fb">lbm_src_event_ume_ack_ex_info_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds ACK information for a given message in an extended form.  <a href="#7b945939b994bf1e7163d55b2256f3fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6ac51be9f09c67187adcc568ce4223ac"></a><!-- doxytag: member="lbm.h::lbm_flight_size_inflight_t" ref="6ac51be9f09c67187adcc568ce4223ac" args="" -->
typedef <a class="el" href="structlbm__flight__size__inflight__t__stct.html">lbm_flight_size_inflight_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6ac51be9f09c67187adcc568ce4223ac">lbm_flight_size_inflight_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for source total inflight messages and bytes. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="736ca2583e1da77265c8f6bc99f117a9"></a><!-- doxytag: member="lbm.h::lbm_src_channel_info_t" ref="736ca2583e1da77265c8f6bc99f117a9" args="" -->
typedef lbm_src_channel_info_t_stct&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_src_channel_info_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__umq__index__info__t__stct.html">lbm_umq_index_info_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f038a0415aaf7dc4285a944bc93e5ea2">lbm_umq_index_info_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information used for sending and receiving messages with UMQ indices.  <a href="#f038a0415aaf7dc4285a944bc93e5ea2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__msg__umq__index__assignment__eligibility__stop__complete__ex__t__stct.html">lbm_msg_umq_index_assignment_eligibility_stop_complete_ex_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#58ad1eb9891440c64aed45631e54be2c">lbm_msg_umq_index_assignment_eligibility_stop_complete_ex_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds index assignment information for receivers.  <a href="#58ad1eb9891440c64aed45631e54be2c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__msg__umq__index__assigned__ex__t__stct.html">lbm_msg_umq_index_assigned_ex_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ce36a383619fc391d14538c4ff0ff778">lbm_msg_umq_index_assigned_ex_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds beginning-of-index information for receivers.  <a href="#ce36a383619fc391d14538c4ff0ff778"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__msg__umq__index__released__ex__t__stct.html">lbm_msg_umq_index_released_ex_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#70be7bc53ea59eed65c220f7c0189f73">lbm_msg_umq_index_released_ex_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds end-of-index information for receivers.  <a href="#70be7bc53ea59eed65c220f7c0189f73"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__msg__umq__index__assignment__eligibility__start__complete__ex__t__stct.html">lbm_msg_umq_index_assignment_eligibility_start_complete_ex_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#fec7b685110ce840e10af3f1a6ed3744">lbm_msg_umq_index_assignment_eligibility_start_complete_ex_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds index assignment information for receivers.  <a href="#fec7b685110ce840e10af3f1a6ed3744"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8b5f5e773cf27c0b55f7685c3b8c223f"></a><!-- doxytag: member="lbm.h::lbm_apphdr_chain_t" ref="8b5f5e773cf27c0b55f7685c3b8c223f" args="" -->
typedef lbm_apphdr_chain_t_stct&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_apphdr_chain_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__umq__msg__total__lifetime__info__t__stct.html">lbm_umq_msg_total_lifetime_info_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b8b20fc8f822cdc1b8e78960b59d5739">lbm_umq_msg_total_lifetime_info_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds UMQ message total lifetime information.  <a href="#b8b20fc8f822cdc1b8e78960b59d5739"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d57314f4cc9f2543733a668fad940418"></a><!-- doxytag: member="lbm.h::lbm_hf_sequence_number_t" ref="d57314f4cc9f2543733a668fad940418" args="" -->
typedef <a class="el" href="unionlbm__hf__sequence__number__t__stct.html">lbm_hf_sequence_number_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#d57314f4cc9f2543733a668fad940418">lbm_hf_sequence_number_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure to hold a hot failover sequence number. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef lbm_uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#492725803c2f09e54bef51edf03caa78">lbm_umq_regid_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__umq__msgid__t__stct.html">lbm_umq_msgid_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6a09e48df4c9dc0df449988b57375c6d">lbm_umq_msgid_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for UMQ messages that allows the message to be identified uniquely.  <a href="#6a09e48df4c9dc0df449988b57375c6d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a2e4e24ab202162f672ea4e8c491c456"></a><!-- doxytag: member="lbm.h::lbm_umq_queue_application_set_t" ref="a2e4e24ab202162f672ea4e8c491c456" args="" -->
typedef lbm_umq_queue_application_set_t_stct&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_umq_queue_application_set_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2925e71ec6de6fbc4e062719d2241afb"></a><!-- doxytag: member="lbm.h::lbm_umq_queue_topic_t" ref="2925e71ec6de6fbc4e062719d2241afb" args="" -->
typedef <a class="el" href="structlbm__umq__queue__topic__t__stct.html">lbm_umq_queue_topic_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#2925e71ec6de6fbc4e062719d2241afb">lbm_umq_queue_topic_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds queue topic information and can be used as a handle to a queue topic. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="aa7a945411e63884f12918417e8d117c"></a><!-- doxytag: member="lbm.h::lbm_msg_t" ref="aa7a945411e63884f12918417e8d117c" args="" -->
typedef <a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_msg_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6897baf281a5b4729e05c873aacac420"></a><!-- doxytag: member="lbm.h::lbm_event_queue_t" ref="6897baf281a5b4729e05c873aacac420" args="" -->
typedef lbm_event_queue_t_stct&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_event_queue_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f4ae0671728c6941e2a991ec695d2ebb"></a><!-- doxytag: member="lbm.h::lbm_async_operation_handle_t" ref="f4ae0671728c6941e2a991ec695d2ebb" args="" -->
typedef lbm_uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f4ae0671728c6941e2a991ec695d2ebb">lbm_async_operation_handle_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Opaque handle to an asynchronous operation. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#2dc2a08b3bc5b1f0904551b177101c27">lbm_async_operation_function_cb</a> (<a class="el" href="structlbm__async__operation__info__t.html">lbm_async_operation_info_t</a> *opinfo, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">User-supplied application callback for asynchronous operation status and completion.  <a href="#2dc2a08b3bc5b1f0904551b177101c27"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9155c3d6d70b67c426089d53b3eacaac"></a><!-- doxytag: member="lbm.h::lbm_msg_properties_t" ref="9155c3d6d70b67c426089d53b3eacaac" args="" -->
typedef lbm_msg_properties_t_stct&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_msg_properties_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__src__send__ex__info__t__stct.html">lbm_src_send_ex_info_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#21504de56612c7c6e4be655402b47a37">lbm_src_send_ex_info_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for the extended send calls A structure used with UM sources that utilize the extended send calls to pass options.  <a href="#21504de56612c7c6e4be655402b47a37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__ume__rcv__regid__ex__func__info__t__stct.html">lbm_ume_rcv_regid_ex_func_info_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#55204ac3b6f89d64faa89286196b26a9">lbm_ume_rcv_regid_ex_func_info_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for UMP receiver registration ID application callbacks.  <a href="#55204ac3b6f89d64faa89286196b26a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__src__event__sequence__number__info__t__stct.html">lbm_src_event_sequence_number_info_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#207823d3c63aea90d4865b641839c259">lbm_src_event_sequence_number_info_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds sequence number information for a message sent by a source.  <a href="#207823d3c63aea90d4865b641839c259"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__ume__rcv__recovery__info__ex__func__info__t__stct.html">lbm_ume_rcv_recovery_info_ex_func_info_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#864aeb7e5113d0d496950cf75ae3cda9">lbm_ume_rcv_recovery_info_ex_func_info_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for UMP receiver recovery sequence number info application callbacks.  <a href="#864aeb7e5113d0d496950cf75ae3cda9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__src__event__umq__message__id__info__t__stct.html">lbm_src_event_umq_message_id_info_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6afbb8091fbcb687199349516d5f9f7e">lbm_src_event_umq_message_id_info_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds Message ID information for a message sent by a sending UMQ application.  <a href="#6afbb8091fbcb687199349516d5f9f7e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__context__event__umq__registration__ex__t__stct.html">lbm_context_event_umq_registration_ex_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a8eab1f96d8ab2216a7cbe95abd06a20">lbm_context_event_umq_registration_ex_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds queue registration information for the UMQ context in an extended form.  <a href="#a8eab1f96d8ab2216a7cbe95abd06a20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__context__event__umq__registration__complete__ex__t__stct.html">lbm_context_event_umq_registration_complete_ex_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#45a43eff8472d717cb984cad9b6c9bad">lbm_context_event_umq_registration_complete_ex_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for contexts after registration is complete to all involved queue instances.  <a href="#45a43eff8472d717cb984cad9b6c9bad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__src__event__umq__registration__complete__ex__t__stct.html">lbm_src_event_umq_registration_complete_ex_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c9fd57ff21d7cb28b4590e632749b65c">lbm_src_event_umq_registration_complete_ex_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for sources after registration is complete to all involved queue instances.  <a href="#c9fd57ff21d7cb28b4590e632749b65c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__msg__umq__registration__complete__ex__t__stct.html">lbm_msg_umq_registration_complete_ex_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#0c64df03275aad96fb201948e3fb26c6">lbm_msg_umq_registration_complete_ex_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for receivers after registration is complete to all involved queue instances.  <a href="#0c64df03275aad96fb201948e3fb26c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__src__event__umq__stability__ack__info__ex__t__stct.html">lbm_src_event_umq_stability_ack_info_ex_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#57ee4ae23bc7e04eaafbf701a44ac547">lbm_src_event_umq_stability_ack_info_ex_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds UMQ ACK information for a given message in an extended form.  <a href="#57ee4ae23bc7e04eaafbf701a44ac547"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__msg__umq__deregistration__complete__ex__t__stct.html">lbm_msg_umq_deregistration_complete_ex_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6125b2ab298fa345efc869b6e7ff4a06">lbm_msg_umq_deregistration_complete_ex_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for receivers after they de-register from a queue.  <a href="#6125b2ab298fa345efc869b6e7ff4a06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__src__event__umq__ulb__receiver__info__ex__t__stct.html">lbm_src_event_umq_ulb_receiver_info_ex_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f0c6681ab1fcaf8faf66e597859ee94a">lbm_src_event_umq_ulb_receiver_info_ex_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds UMQ ULB receiver information in an extended form.  <a href="#f0c6681ab1fcaf8faf66e597859ee94a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__src__event__umq__ulb__message__info__ex__t__stct.html">lbm_src_event_umq_ulb_message_info_ex_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#4a142e22ec153e2e9015f1b4364cdd71">lbm_src_event_umq_ulb_message_info_ex_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds UMQ ULB message information in an extended form.  <a href="#4a142e22ec153e2e9015f1b4364cdd71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef lbm_ulong_t(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#21ae55d313d8f4feb9e9a64f1c5a566c">lbm_str_hash_function_cb</a> (const char *str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback for user-supplied topic hash function.  <a href="#21ae55d313d8f4feb9e9a64f1c5a566c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef lbm_ulong_t(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c177f556e1e760198d10149bd6abbd8a">lbm_str_hash_function_cb_ex</a> (const char *str, size_t strlen, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback for user-supplied extended version of the topic hash function.  <a href="#c177f556e1e760198d10149bd6abbd8a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#849a5ac10cd71a981a8a781239bc09e9">lbm_src_notify_function_cb</a> (const char *topic_str, const char *src_str, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback to inform application of the presence of new sources for topics.  <a href="#849a5ac10cd71a981a8a781239bc09e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f9c6d7a8a5fb9eced362df6480fb52aa">lbm_wildcard_rcv_compare_function_cb</a> (const char *topic_str, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback for application-supplied wildcard matching.  <a href="#f9c6d7a8a5fb9eced362df6480fb52aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef lbm_uint_t(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f533113cc21d841ee498fa1b79e3faa8">lbm_ume_rcv_regid_function_cb</a> (const char *src_str, lbm_uint_t src_regid, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback to set the registration ID for a receiver for a specific source.  <a href="#f533113cc21d841ee498fa1b79e3faa8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef lbm_uint_t(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#8c069dbea00f437936404ea554182c7a">lbm_ume_rcv_regid_ex_function_cb</a> (<a class="el" href="structlbm__ume__rcv__regid__ex__func__info__t__stct.html">lbm_ume_rcv_regid_ex_func_info_t</a> *info, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback to set the registration ID for a receiver for a specific source, extended form.  <a href="#8c069dbea00f437936404ea554182c7a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#7304cc6156d5a8d6749176ad60112a44">lbm_ume_src_force_reclaim_function_cb</a> (const char *topic_str, lbm_uint_t seqnum, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback for notification of forced reclamation of retained messages for UMP sources.  <a href="#7304cc6156d5a8d6749176ad60112a44"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#092915cccebd4e51e8128588f4439f63">lbm_mim_unrecloss_function_cb</a> (const char *source_name, lbm_uint_t seqnum, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback in receiving application for notification of unrecoverable lost messages from a multicast immediate message sender.  <a href="#092915cccebd4e51e8128588f4439f63"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#cfa85f6293da6b9cdffcc595f2dfcf51">lbm_ume_rcv_recovery_info_ex_function_cb</a> (<a class="el" href="structlbm__ume__rcv__recovery__info__ex__func__info__t__stct.html">lbm_ume_rcv_recovery_info_ex_func_info_t</a> *info, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback to set the lowest sequence number to be requested during recovery, extended form.  <a href="#cfa85f6293da6b9cdffcc595f2dfcf51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void *(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c58e7da14fdce3af9f20478cf87da125">lbm_rcv_src_notification_create_function_cb</a> (const char *source_name, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback for notification of creation of sources for a topic.  <a href="#c58e7da14fdce3af9f20478cf87da125"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#3763fcb07ba3693804a63f6416e3e045">lbm_rcv_src_notification_delete_function_cb</a> (const char *source_name, void *clientd, void *source_clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback for notification of deletion of sources for a topic.  <a href="#3763fcb07ba3693804a63f6416e3e045"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d31ddaa5feb80449188afc5f7379245e"></a><!-- doxytag: member="lbm.h::lbm_str_hash_func_t" ref="d31ddaa5feb80449188afc5f7379245e" args="" -->
typedef lbm_str_hash_func_t_stct&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_str_hash_func_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__str__hash__func__ex__t__stct.html">lbm_str_hash_func_ex_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#55fedf757c6c5bc6df031fc1446d21bb">lbm_str_hash_func_ex_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the hash function callback information.  <a href="#55fedf757c6c5bc6df031fc1446d21bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__src__notify__func__t__stct.html">lbm_src_notify_func_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6fd5cb88fa3780abcb236951d236ffce">lbm_src_notify_func_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the callback for source notifications.  <a href="#6fd5cb88fa3780abcb236951d236ffce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__wildcard__rcv__compare__func__t__stct.html">lbm_wildcard_rcv_compare_func_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#7b6a386398e2006a07c3387d444f9ec1">lbm_wildcard_rcv_compare_func_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the application callback pattern type information for wildcard receivers.  <a href="#7b6a386398e2006a07c3387d444f9ec1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__ume__rcv__regid__func__t__stct.html">lbm_ume_rcv_regid_func_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#570a021e283e9175826e579580dd79fc">lbm_ume_rcv_regid_func_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the application callback for registration ID setting.  <a href="#570a021e283e9175826e579580dd79fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__ume__rcv__regid__ex__func__t__stct.html">lbm_ume_rcv_regid_ex_func_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#1145cdaf45b6f93b335d4fd97cbc68e9">lbm_ume_rcv_regid_ex_func_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the application callback for registration ID setting, extended form.  <a href="#1145cdaf45b6f93b335d4fd97cbc68e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__ume__src__force__reclaim__func__t__stct.html">lbm_ume_src_force_reclaim_func_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#7a7b4983b4abbbafee7175490f7af9d2">lbm_ume_src_force_reclaim_func_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the application callback for forced reclamation notifications.  <a href="#7a7b4983b4abbbafee7175490f7af9d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__mim__unrecloss__func__t__stct.html">lbm_mim_unrecloss_func_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#5fdd36ef808e7589c75fa9e7406cf5bf">lbm_mim_unrecloss_func_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the application callback for multicast immediate message unrecoverable loss notification.  <a href="#5fdd36ef808e7589c75fa9e7406cf5bf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__ume__rcv__recovery__info__ex__func__t__stct.html">lbm_ume_rcv_recovery_info_ex_func_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c318ae4d0d80e5595ce572558102c7b5">lbm_ume_rcv_recovery_info_ex_func_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the application callback for recovery sequence number information, extended form.  <a href="#c318ae4d0d80e5595ce572558102c7b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__ume__store__entry__t__stct.html">lbm_ume_store_entry_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a86a12d5efc42a997eb6b61334241bc0">lbm_ume_store_entry_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for a UMP store for configuration purposes.  <a href="#a86a12d5efc42a997eb6b61334241bc0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__ucast__resolver__entry__t__stct.html">lbm_ucast_resolver_entry_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#3ce940fe5841daa6e761bc1e9b0a7c6f">lbm_ucast_resolver_entry_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for a unicast resolver daemon for configuration purposes.  <a href="#3ce940fe5841daa6e761bc1e9b0a7c6f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__ume__store__name__entry__t__stct.html">lbm_ume_store_name_entry_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b6e8607b85d13bf38275a8632d7c801a">lbm_ume_store_name_entry_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for a UMP store by name for configuration purposes.  <a href="#b6e8607b85d13bf38275a8632d7c801a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__ume__store__group__entry__t__stct.html">lbm_ume_store_group_entry_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6322c18b4e126e9ad594401cbba9cf13">lbm_ume_store_group_entry_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for a UMP store group for configuration purposes.  <a href="#6322c18b4e126e9ad594401cbba9cf13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__rcv__src__notification__func__t__stct.html">lbm_rcv_src_notification_func_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#45be527ef7ef03b53afd4b193558107f">lbm_rcv_src_notification_func_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the application callback for source status notifications for receivers.  <a href="#45be527ef7ef03b53afd4b193558107f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structume__liveness__receiving__context__t__stct.html">ume_liveness_receiving_context_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a9087bc433e8c17ecc50195a8094ad9c">ume_liveness_receiving_context_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the information about a receiving context.  <a href="#a9087bc433e8c17ecc50195a8094ad9c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void *(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f1c3a6d1eb8b5ef6e3539389fabe6d91">lbm_ume_ctx_rcv_ctx_notification_create_function_cb</a> (const <a class="el" href="structume__liveness__receiving__context__t__stct.html">ume_liveness_receiving_context_t</a> *rcv, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback for notification of detection of a receiving application.  <a href="#f1c3a6d1eb8b5ef6e3539389fabe6d91"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c73a46984b624d7a1b8aa3decb476bdb">lbm_ume_ctx_rcv_ctx_notification_delete_function_cb</a> (const <a class="el" href="structume__liveness__receiving__context__t__stct.html">ume_liveness_receiving_context_t</a> *rcv, void *clientd, void *source_clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback for notification of unresponsiveness of a receiving application.  <a href="#c73a46984b624d7a1b8aa3decb476bdb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__ume__ctx__rcv__ctx__notification__func__t__stct.html">lbm_ume_ctx_rcv_ctx_notification_func_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a192b884ef005240730d1f79af456bcc">lbm_ume_ctx_rcv_ctx_notification_func_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the application callback for receiving context status notifications for source context.  <a href="#a192b884ef005240730d1f79af456bcc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__umq__queue__entry__t__stct.html">lbm_umq_queue_entry_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#7405e170505e0acb7325cb20f1a3c800">lbm_umq_queue_entry_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for a UMQ queue registration ID for configuration purposes.  <a href="#7405e170505e0acb7325cb20f1a3c800"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__umq__ulb__receiver__type__entry__t__stct.html">lbm_umq_ulb_receiver_type_entry_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6699be947ebb422869633f68f1191c21">lbm_umq_ulb_receiver_type_entry_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for a UMQ ULB sources receiver type associations with application sets.  <a href="#6699be947ebb422869633f68f1191c21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__umq__ulb__application__set__attr__t__stct.html">lbm_umq_ulb_application_set_attr_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#34f1be95e2447180c700d059e9e6bfa6">lbm_umq_ulb_application_set_attr_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for a UMQ ULB sources application set attributes.  <a href="#34f1be95e2447180c700d059e9e6bfa6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__umq__ulb__receiver__type__attr__t__stct.html">lbm_umq_ulb_receiver_type_attr_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ad05190303cdd73c93b04913a917d717">lbm_umq_ulb_receiver_type_attr_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds information for a UMQ ULB sources receiver type attributes.  <a href="#ad05190303cdd73c93b04913a917d717"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9f6ec97839a8f264eb4059de01174f3c"></a><!-- doxytag: member="lbm.h::lbm_context_t" ref="9f6ec97839a8f264eb4059de01174f3c" args="" -->
typedef lbm_context_t_stct&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_context_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6528467874659f28e2eccf1e1caf676b">lbm_context_src_cb_proc</a> (lbm_context_t *ctx, int event, void *ed, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application context-level callback for events associated with context sources (immediate mode sources and responses).  <a href="#6528467874659f28e2eccf1e1caf676b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__context__src__event__func__t__stct.html">lbm_context_src_event_func_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#9b7832bd627106205ba58ac151917b18">lbm_context_src_event_func_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the application callback for context-level source events.  <a href="#9b7832bd627106205ba58ac151917b18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#12c823d52cadbbfc9032c5338c077ceb">lbm_context_event_cb_proc</a> (lbm_context_t *ctx, int event, void *ed, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application context-level callback for events associated with contexts.  <a href="#12c823d52cadbbfc9032c5338c077ceb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__context__event__func__t__stct.html">lbm_context_event_func_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#2ad9c4d58e9129102d7d780b611c58b4">lbm_context_event_func_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the application callback for context-level events.  <a href="#2ad9c4d58e9129102d7d780b611c58b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="54cfbb23ab41a8d22968f68df015e246"></a><!-- doxytag: member="lbm.h::lbm_serialized_response_t" ref="54cfbb23ab41a8d22968f68df015e246" args="" -->
typedef <a class="el" href="structlbm__serialized__response__t__stct.html">lbm_serialized_response_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#54cfbb23ab41a8d22968f68df015e246">lbm_serialized_response_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds a serialized UM response object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0413daba8bb78e93c1a1df9b32e191e3"></a><!-- doxytag: member="lbm.h::lbm_buff_t" ref="0413daba8bb78e93c1a1df9b32e191e3" args="" -->
typedef lbm_buff_t_stct&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_buff_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="379731fbc3d8e9bcc40a7f070cf2e14b"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_t" ref="379731fbc3d8e9bcc40a7f070cf2e14b" args="" -->
typedef lbm_wildcard_rcv_t_stct&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_wildcard_rcv_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2607e5c20a3a6bcee11a5ceaee82873a"></a><!-- doxytag: member="lbm.h::lbm_hf_rcv_t" ref="2607e5c20a3a6bcee11a5ceaee82873a" args="" -->
typedef lbm_hf_rcv_t_stct&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_hf_rcv_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7c6b4856985572c212bea283c01f7c18"></a><!-- doxytag: member="lbm.h::lbm_hfx_attr_t" ref="7c6b4856985572c212bea283c01f7c18" args="" -->
typedef lbm_hfx_attr_t_stct&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_hfx_attr_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a8e1d6704480545f52007a436def4440"></a><!-- doxytag: member="lbm.h::lbm_hfx_t" ref="a8e1d6704480545f52007a436def4440" args="" -->
typedef lbm_hfx_t_stct&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_hfx_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="86547369b7448cec0f4f09b24b226126"></a><!-- doxytag: member="lbm.h::lbm_hfx_rcv_t" ref="86547369b7448cec0f4f09b24b226126" args="" -->
typedef lbm_hfx_rcv_t_stct&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_hfx_rcv_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3f0c8cba0e6f00fe7ae0ed717405e46d"></a><!-- doxytag: member="lbm.h::lbm_topic_t" ref="3f0c8cba0e6f00fe7ae0ed717405e46d" args="" -->
typedef lbm_topic_t_stct&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_topic_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="717ff27bb10ae7800330c21d810dffb8"></a><!-- doxytag: member="lbm.h::lbm_src_t" ref="717ff27bb10ae7800330c21d810dffb8" args="" -->
typedef lbm_src_t_stct&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_src_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0a4af6b8247cc5a0a24a8578fb6e83bd"></a><!-- doxytag: member="lbm.h::lbm_rcv_t" ref="0a4af6b8247cc5a0a24a8578fb6e83bd" args="" -->
typedef lbm_rcv_t_stct&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_rcv_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f90e926123efefbb78ff0d6388ec9b90"></a><!-- doxytag: member="lbm.h::lbm_request_t" ref="f90e926123efefbb78ff0d6388ec9b90" args="" -->
typedef lbm_request_t_stct&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_request_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="12edbe3ce23f5884ef5dba99ff9f247c"></a><!-- doxytag: member="lbm.h::lbm_response_t" ref="12edbe3ce23f5884ef5dba99ff9f247c" args="" -->
typedef lbm_response_t_stct&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_response_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__msg__fragment__info__t__stct.html">lbm_msg_fragment_info_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#5e2b10a2d5dd362cf4852ca9b99302a7">lbm_msg_fragment_info_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds fragment information for UM messages when appropriate.  <a href="#5e2b10a2d5dd362cf4852ca9b99302a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__msg__gateway__info__t__stct.html">lbm_msg_gateway_info_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a7855ba983aeb84b6e00a38c827e5c0d">lbm_msg_gateway_info_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds originating information for UM messages which arrived via a gateway.  <a href="#a7855ba983aeb84b6e00a38c827e5c0d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__msg__channel__info__t__stct.html">lbm_msg_channel_info_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#92eeef15a938f250c05c436c52960055">lbm_msg_channel_info_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that represents UMS Spectrum channel information.  <a href="#92eeef15a938f250c05c436c52960055"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="40d24279afe3a87f1660fbb0086a4def"></a><!-- doxytag: member="lbm.h::lbm_ume_rcv_ack_t" ref="40d24279afe3a87f1660fbb0086a4def" args="" -->
typedef lbm_ume_rcv_ack_t_stct&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_ume_rcv_ack_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#7947fbc8b37e649ff36cc9ca66ef2dc7">lbm_immediate_msg_cb_proc</a> (lbm_context_t *ctx, <a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *msg, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback for non-topic immediate-mode received messages.  <a href="#7947fbc8b37e649ff36cc9ca66ef2dc7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__context__rcv__immediate__msgs__func__t__stct.html">lbm_context_rcv_immediate_msgs_func_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b9916750784e7d597e8e19580b9a0fe1">lbm_context_rcv_immediate_msgs_func_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the application callback for receiving topic-less immediate mode messages.  <a href="#b9916750784e7d597e8e19580b9a0fe1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__transport__source__info__t__stct.html">lbm_transport_source_info_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#07f7bc3e6e4fe05c89ff2c3e4e6aa489">lbm_transport_source_info_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds formatted and parsed transport source strings.  <a href="#07f7bc3e6e4fe05c89ff2c3e4e6aa489"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef lbm_uint32_t(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#3ee96b453b592c6f94c6fb65fcb5adcb">lbm_src_cost_function_cb</a> (const char *topic, const <a class="el" href="structlbm__transport__source__info__t__stct.html">lbm_transport_source_info_t</a> *transport, lbm_uint32_t hop_count, lbm_uint32_t cost, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback to evaluate the cost of a newly discovered source.  <a href="#3ee96b453b592c6f94c6fb65fcb5adcb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="193a404edca104c3852b6c44d8f04ce5"></a><!-- doxytag: member="lbm.h::lbm_src_cost_func_t" ref="193a404edca104c3852b6c44d8f04ce5" args="" -->
typedef <a class="el" href="structlbm__src__cost__func__t__stct.html">lbm_src_cost_func_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#193a404edca104c3852b6c44d8f04ce5">lbm_src_cost_func_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the "source_cost_evaluation_function" context attribute. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cf249ec7a22d6a0eb9fc42d6375bda5a"></a><!-- doxytag: member="lbm.h::lbm_context_attr_t" ref="cf249ec7a22d6a0eb9fc42d6375bda5a" args="" -->
typedef lbm_context_attr_t_stct&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_context_attr_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="dfe063aed799baf3675c62c516ea92d2"></a><!-- doxytag: member="lbm.h::lbm_config_option_t" ref="dfe063aed799baf3675c62c516ea92d2" args="" -->
typedef lbm_config_option_stct_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_config_option_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="30c33f443cf2d228f4772d534ce3ee88"></a><!-- doxytag: member="lbm.h::lbm_src_topic_attr_t" ref="30c33f443cf2d228f4772d534ce3ee88" args="" -->
typedef lbm_src_topic_attr_t_stct&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_src_topic_attr_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f433822d81d21550902df6aacfc9d28d"></a><!-- doxytag: member="lbm.h::lbm_rcv_topic_attr_t" ref="f433822d81d21550902df6aacfc9d28d" args="" -->
typedef lbm_rcv_topic_attr_t_stct&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_rcv_topic_attr_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#759437ce7a508ce80e7ddad3df6c63b8">lbm_wildcard_rcv_create_function_cb</a> (const char *topic_str, lbm_rcv_topic_attr_t *attr, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback for wildcard receiver creation.  <a href="#759437ce7a508ce80e7ddad3df6c63b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__wildcard__rcv__create__func__t__stct.html">lbm_wildcard_rcv_create_func_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#e65a28c201d693e7b51e8906bd39d260">lbm_wildcard_rcv_create_func_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the receiver creation callback information for wildcard receivers.  <a href="#e65a28c201d693e7b51e8906bd39d260"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#222399ef16d02322f7eac8dbe865c8fc">lbm_wildcard_rcv_delete_function_cb</a> (const char *topic_str, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback for wildcard receiver deletion.  <a href="#222399ef16d02322f7eac8dbe865c8fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__wildcard__rcv__delete__func__t__stct.html">lbm_wildcard_rcv_delete_func_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f9e0c6fb332c40bfcd999e13fa60cb26">lbm_wildcard_rcv_delete_func_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the receiver deletion callback information for wildcard receivers.  <a href="#f9e0c6fb332c40bfcd999e13fa60cb26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fce0b32ac68ebedbdbcb775a5e7c2f8e"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_attr_t" ref="fce0b32ac68ebedbdbcb775a5e7c2f8e" args="" -->
typedef lbm_wildcard_rcv_attr_t_stct&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_wildcard_rcv_attr_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f1c89799af2c5de8186638d54fc21ac1"></a><!-- doxytag: member="lbm.h::lbm_src_transport_stats_tcp_t" ref="f1c89799af2c5de8186638d54fc21ac1" args="" -->
typedef <a class="el" href="structlbm__src__transport__stats__tcp__t__stct.html">lbm_src_transport_stats_tcp_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f1c89799af2c5de8186638d54fc21ac1">lbm_src_transport_stats_tcp_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds datagram statistics for source TCP transports. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d7cd86fcb1fc5cd16760106b11ba9e07"></a><!-- doxytag: member="lbm.h::lbm_src_transport_stats_lbtrm_t" ref="d7cd86fcb1fc5cd16760106b11ba9e07" args="" -->
typedef <a class="el" href="structlbm__src__transport__stats__lbtrm__t__stct.html">lbm_src_transport_stats_lbtrm_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#d7cd86fcb1fc5cd16760106b11ba9e07">lbm_src_transport_stats_lbtrm_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds datagram statistics for source LBT-RM transports. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__src__transport__stats__daemon__t__stct.html">lbm_src_transport_stats_daemon_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#3d6965a7fc6ab72db6e416b06eeefaab">lbm_src_transport_stats_daemon_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds statistics for source daemon mode transport (deprecated).  <a href="#3d6965a7fc6ab72db6e416b06eeefaab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0724bc12b245818ba1f6268ffb24ac13"></a><!-- doxytag: member="lbm.h::lbm_src_transport_stats_lbtru_t" ref="0724bc12b245818ba1f6268ffb24ac13" args="" -->
typedef <a class="el" href="structlbm__src__transport__stats__lbtru__t__stct.html">lbm_src_transport_stats_lbtru_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#0724bc12b245818ba1f6268ffb24ac13">lbm_src_transport_stats_lbtru_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds datagram statistics for source LBT-RU transports. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="703353b0cf30dbe1977c3770b6e404f5"></a><!-- doxytag: member="lbm.h::lbm_src_transport_stats_lbtipc_t" ref="703353b0cf30dbe1977c3770b6e404f5" args="" -->
typedef <a class="el" href="structlbm__src__transport__stats__lbtipc__t__stct.html">lbm_src_transport_stats_lbtipc_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#703353b0cf30dbe1977c3770b6e404f5">lbm_src_transport_stats_lbtipc_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds datagram statistics for source LBT-IPC transports. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="19a16ccb01fd58fa6acd0c46923b1ee3"></a><!-- doxytag: member="lbm.h::lbm_src_transport_stats_lbtrdma_t" ref="19a16ccb01fd58fa6acd0c46923b1ee3" args="" -->
typedef <a class="el" href="structlbm__src__transport__stats__lbtrdma__t__stct.html">lbm_src_transport_stats_lbtrdma_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#19a16ccb01fd58fa6acd0c46923b1ee3">lbm_src_transport_stats_lbtrdma_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds datagram statistics for source LBT-RDMA transports. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__src__transport__stats__t__stct.html">lbm_src_transport_stats_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#0a0c54fd8e9a7008f1db0126373fca92">lbm_src_transport_stats_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds statistics for source transports.  <a href="#0a0c54fd8e9a7008f1db0126373fca92"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="23fc715ae2b135a2cc06d4bf86fc8610"></a><!-- doxytag: member="lbm.h::lbm_rcv_transport_stats_tcp_t" ref="23fc715ae2b135a2cc06d4bf86fc8610" args="" -->
typedef <a class="el" href="structlbm__rcv__transport__stats__tcp__t__stct.html">lbm_rcv_transport_stats_tcp_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#23fc715ae2b135a2cc06d4bf86fc8610">lbm_rcv_transport_stats_tcp_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds datagram statistics for receiver TCP transports. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ab803d1b77bef15f45b8ddae552dcf37"></a><!-- doxytag: member="lbm.h::lbm_rcv_transport_stats_lbtrm_t" ref="ab803d1b77bef15f45b8ddae552dcf37" args="" -->
typedef <a class="el" href="structlbm__rcv__transport__stats__lbtrm__t__stct.html">lbm_rcv_transport_stats_lbtrm_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ab803d1b77bef15f45b8ddae552dcf37">lbm_rcv_transport_stats_lbtrm_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds datagram statistics for receiver LBT-RM transports. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__rcv__transport__stats__daemon__t__stct.html">lbm_rcv_transport_stats_daemon_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a1aa4094d297eacd2752ab472b7a8956">lbm_rcv_transport_stats_daemon_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds statistics for receiver daemon mode transport (deprecated).  <a href="#a1aa4094d297eacd2752ab472b7a8956"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7eb0cd77073c3cce63b655b084a02568"></a><!-- doxytag: member="lbm.h::lbm_rcv_transport_stats_lbtru_t" ref="7eb0cd77073c3cce63b655b084a02568" args="" -->
typedef <a class="el" href="structlbm__rcv__transport__stats__lbtru__t__stct.html">lbm_rcv_transport_stats_lbtru_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#7eb0cd77073c3cce63b655b084a02568">lbm_rcv_transport_stats_lbtru_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds datagram statistics for receiver LBT-RU transports. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2c2ccec0f5e04ab84bca248fe641c5e8"></a><!-- doxytag: member="lbm.h::lbm_rcv_transport_stats_lbtipc_t" ref="2c2ccec0f5e04ab84bca248fe641c5e8" args="" -->
typedef <a class="el" href="structlbm__rcv__transport__stats__lbtipc__t__stct.html">lbm_rcv_transport_stats_lbtipc_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#2c2ccec0f5e04ab84bca248fe641c5e8">lbm_rcv_transport_stats_lbtipc_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds datagram statistics for receiver LBT-IPC transports. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="963b577cbf87c4f4b032ed717e644937"></a><!-- doxytag: member="lbm.h::lbm_rcv_transport_stats_lbtrdma_t" ref="963b577cbf87c4f4b032ed717e644937" args="" -->
typedef <a class="el" href="structlbm__rcv__transport__stats__lbtrdma__t__stct.html">lbm_rcv_transport_stats_lbtrdma_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#963b577cbf87c4f4b032ed717e644937">lbm_rcv_transport_stats_lbtrdma_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds datagram statistics for receiver LBT-RDMA transports. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__rcv__transport__stats__t__stct.html">lbm_rcv_transport_stats_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#9bdc2628dece44f0675b0bdebfb3d52c">lbm_rcv_transport_stats_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds statistics for receiver transports.  <a href="#9bdc2628dece44f0675b0bdebfb3d52c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="619319568f28aa3c59e4690da5f749be"></a><!-- doxytag: member="lbm.h::lbm_event_queue_attr_t" ref="619319568f28aa3c59e4690da5f749be" args="" -->
typedef lbm_event_queue_attr_t_stct&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_event_queue_attr_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__event__queue__stats__t__stct.html">lbm_event_queue_stats_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a533d6a23589618291f552e988a426f6">lbm_event_queue_stats_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds statistics for an event queue.  <a href="#a533d6a23589618291f552e988a426f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structlbm__context__stats__t__stct.html">lbm_context_stats_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b86e72a3f715d7c8ddc49c6431455839">lbm_context_stats_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds statistics for a context.  <a href="#b86e72a3f715d7c8ddc49c6431455839"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#147d905636bb3b870ba5c0096c3f66b9">lbm_timer_cb_proc</a> (lbm_context_t *ctx, const void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback for timer events.  <a href="#147d905636bb3b870ba5c0096c3f66b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#e2d650dd4830971ca0b6197298eddcdd">lbm_rcv_cb_proc</a> (lbm_rcv_t *rcv, <a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *msg, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback for receiver events.  <a href="#e2d650dd4830971ca0b6197298eddcdd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#0aa2a7e14eca4d75925063cac2ecd879">lbm_fd_cb_proc</a> (lbm_context_t *ctx, lbm_handle_t handle, lbm_ulong_t ev, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback for events associated with an application file descriptor or socket.  <a href="#0aa2a7e14eca4d75925063cac2ecd879"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#7503c005ce424fa049494e37b708d396">lbm_src_cb_proc</a> (lbm_src_t *src, int event, void *ed, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback for events associated with a source.  <a href="#7503c005ce424fa049494e37b708d396"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f3ef4385bc929e8a7ff94acbeb1eef75">lbm_request_cb_proc</a> (lbm_request_t *req, <a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *msg, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback for responses returned when a request is sent.  <a href="#f3ef4385bc929e8a7ff94acbeb1eef75"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#1b4b56862044a11671aebac3ecd15b3a">lbm_event_queue_monitor_proc</a> (lbm_event_queue_t *evq, int event, size_t evq_size, lbm_ulong_t event_delay_usec, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback for event queue monitor events.  <a href="#1b4b56862044a11671aebac3ecd15b3a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#72ac99d9f07d98bfe2c7c5856d37c2d0">lbm_log_cb_proc</a> (int level, const char *message, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback for message logging.  <a href="#72ac99d9f07d98bfe2c7c5856d37c2d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#3d21707bec0da738e48a6166a56f3f06">lbm_daemon_event_cb_proc</a> (lbm_context_t *ctx, int event, const char *info, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback for daemon events.  <a href="#3d21707bec0da738e48a6166a56f3f06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#8f700b98f4bbfb65ab0f12dc71a55083">lbm_event_queue_cancel_cb_proc</a> (int dispatch_thrd, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback for lbm_*_delete_ex().  <a href="#8f700b98f4bbfb65ab0f12dc71a55083"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9e019e7c96360ebe45b985a3efbf8083"></a><!-- doxytag: member="lbm.h::lbm_event_queue_cancel_cb_info_t" ref="9e019e7c96360ebe45b985a3efbf8083" args="" -->
typedef <a class="el" href="structlbm__event__queue__cancel__cb__info__t__stct.html">lbm_event_queue_cancel_cb_info_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#9e019e7c96360ebe45b985a3efbf8083">lbm_event_queue_cancel_cb_info_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure passed to cancel/delete functions so that a cancel callback may be called. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c26b2f61ff3e92ff1e1b44f82bbf193b">lbm_flight_size_set_inflight_cb_proc</a> (int inflight, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback for lbm_*_flight_size_set_inflight().  <a href="#c26b2f61ff3e92ff1e1b44f82bbf193b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#75319e63d9fa4e0f006918b91672f6b5">lbm_flight_size_set_inflight_ex_cb_proc</a> (<a class="el" href="structlbm__flight__size__inflight__t__stct.html">lbm_flight_size_inflight_t</a> *inflight, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application callback for lbm_ume_flight_size_set_inflight_ex(). Change the inflight parameter messages and bytes to update the current settings.  <a href="#75319e63d9fa4e0f006918b91672f6b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="73c7309003ea3c7588b7997e325b35f4"></a><!-- doxytag: member="lbm.h::lbm_apphdr_chain_iter_t" ref="73c7309003ea3c7588b7997e325b35f4" args="" -->
typedef lbm_apphdr_chain_iter_t_stct&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_apphdr_chain_iter_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5ea92c8be5a30771d27a5c5ba7ba9cd3"></a><!-- doxytag: member="lbm.h::lbm_apphdr_chain_elem_t" ref="5ea92c8be5a30771d27a5c5ba7ba9cd3" args="" -->
typedef <a class="el" href="structlbm__apphdr__chain__elem__t__stct.html">lbm_apphdr_chain_elem_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#5ea92c8be5a30771d27a5c5ba7ba9cd3">lbm_apphdr_chain_elem_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that represents an element in an app header chain. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f0d0113ae763fbeea6213cb91d90cf80"></a><!-- doxytag: member="lbm.h::lbm_msg_properties_iter_t" ref="f0d0113ae763fbeea6213cb91d90cf80" args="" -->
typedef <a class="el" href="structlbm__msg__properties__iter__t__stct.html">lbm_msg_properties_iter_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f0d0113ae763fbeea6213cb91d90cf80">lbm_msg_properties_iter_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A struct used for iterating over properties pointed to by an lbm_msg_properties_t. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7d96568c7653ad7daa00c2ee336242c1"></a><!-- doxytag: member="lbm.h::lbm_umq_msg_selector_t" ref="7d96568c7653ad7daa00c2ee336242c1" args="" -->
typedef lbm_umq_msg_selector_t_stct&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_umq_msg_selector_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d0a4e308a2fbc62073eceee6869cf715"></a><!-- doxytag: member="lbm.h::lbm_cred_callback_fn" ref="d0a4e308a2fbc62073eceee6869cf715" args="(const char *name, size_t name_len, const char *passwd, size_t passwd_len, void *clientd)" -->
typedef int(*)&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_cred_callback_fn</b> (const char *name, size_t name_len, const char *passwd, size_t passwd_len, void *clientd)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bcb0f0efe7b2a8162b328ba401b06ee3"></a><!-- doxytag: member="lbm.h::lbm_umm_info_t" ref="bcb0f0efe7b2a8162b328ba401b06ee3" args="" -->
typedef <a class="el" href="structlbm__umm__info__t__stct.html">lbm_umm_info_t_stct</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#bcb0f0efe7b2a8162b328ba401b06ee3">lbm_umm_info_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure for specifying UMM daemon connection options. <br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <b>LBM_OK</b> =  0, 
<b>LBM_FAILURE</b> =  -1
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ed1a3a43104b67af66a8f3513f8f2a75">lbm_version</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the version string compiled into UM.  <a href="#ed1a3a43104b67af66a8f3513f8f2a75"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b9a61cde092850b61acc474f9b45d7a0">lbm_context_dump</a> (lbm_context_t *ctx, int *size, lbm_config_option_t *opts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves all context attribute options.  <a href="#b9a61cde092850b61acc474f9b45d7a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#43f6029ad772e29b61c2a5c78f961073">lbm_context_attr_dump</a> (lbm_context_attr_t *cattr, int *size, lbm_config_option_t *opts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves all context attribute options.  <a href="#43f6029ad772e29b61c2a5c78f961073"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a59c23a0e0800eed74e5c3c3b8a668ae">lbm_context_attr_option_size</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of options that are of type "context".  <a href="#a59c23a0e0800eed74e5c3c3b8a668ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#066c0eb289bf4afcefac86a1109fca1e">lbm_context_attr_create</a> (lbm_context_attr_t **attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and fill a UM context attribute object with the current default values.  <a href="#066c0eb289bf4afcefac86a1109fca1e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#04c6b79859bc07f4cc6c9008242e77f7">lbm_context_attr_create_default</a> (lbm_context_attr_t **attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and fill a UM context attribute object with the initial default values.  <a href="#04c6b79859bc07f4cc6c9008242e77f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#04d99cc97d32f359888c5befcc50512e">lbm_context_attr_create_from_xml</a> (lbm_context_attr_t **attr, const char *context_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and fill a UM context attribute object with the current default values for the given context name.  <a href="#04d99cc97d32f359888c5befcc50512e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#3a97ec59981f5b863b0b40faf82eceb8">lbm_context_attr_set_from_xml</a> (lbm_context_attr_t *attr, const char *context_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill a UM context attribute object with the current default values for the given context name.  <a href="#3a97ec59981f5b863b0b40faf82eceb8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#9c0a3c1f4a8854d8ec5585392c817c85">lbm_context_attr_delete</a> (lbm_context_attr_t *attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a UM context attribute object.  <a href="#9c0a3c1f4a8854d8ec5585392c817c85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6dc1f21c3be74fbed3f96800cfd6a0b0">lbm_context_attr_dup</a> (lbm_context_attr_t **attr, const lbm_context_attr_t *original)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Duplicate a UM context attribute object.  <a href="#6dc1f21c3be74fbed3f96800cfd6a0b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b67f641d5a0ad1a9fe53d415da58d961">lbm_context_attr_setopt</a> (lbm_context_attr_t *attr, const char *optname, const void *optval, size_t optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option for the given UM context attribute.  <a href="#b67f641d5a0ad1a9fe53d415da58d961"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f45c2cec5557da4057a0c96f305d6a40">lbm_context_attr_str_setopt</a> (lbm_context_attr_t *attr, const char *optname, const char *optval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option for the given UM context attribute using a string.  <a href="#f45c2cec5557da4057a0c96f305d6a40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#0e578b4f0005589f6558d15e55be8483">lbm_context_attr_getopt</a> (lbm_context_attr_t *attr, const char *optname, void *optval, size_t *optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the value of an option for the given UM context attribute.  <a href="#0e578b4f0005589f6558d15e55be8483"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#2db2f7a5a7195106d49089f21a2ecced">lbm_context_attr_str_getopt</a> (lbm_context_attr_t *attr, const char *optname, char *optval, size_t *optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the textual value of an option for the given UM context attribute.  <a href="#2db2f7a5a7195106d49089f21a2ecced"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#8058947690bd0995bc2c59d4a61b462f">lbm_context_create</a> (lbm_context_t **ctxp, const lbm_context_attr_t *attr, <a class="el" href="lbm_8h.html#3d21707bec0da738e48a6166a56f3f06">lbm_daemon_event_cb_proc</a> proc, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and initialize an lbm_context_t object.  <a href="#8058947690bd0995bc2c59d4a61b462f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#32329ebe3c2179efdada11a8766cfa79">lbm_context_reactor_only_create</a> (lbm_context_t **ctxp, const lbm_context_attr_t *attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and initialize an lbm_context_t object suitable for FD and timers only.  <a href="#32329ebe3c2179efdada11a8766cfa79"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#962bfceb336c65191ba08497ac70602b">lbm_context_delete</a> (lbm_context_t *ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a UM context object.  <a href="#962bfceb336c65191ba08497ac70602b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#4018719af554eac487e60172d35e871a">lbm_context_delete_ex</a> (lbm_context_t *ctx, <a class="el" href="structlbm__event__queue__cancel__cb__info__t__stct.html">lbm_event_queue_cancel_cb_info_t</a> *cbinfo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a UM context object with an application callback indicating when the context is fully deleted. This extended version of the context delete function requires the configuration option queue_cancellation_callbacks_enabled be set to 1.  <a href="#4018719af554eac487e60172d35e871a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#e6dd7c56acf916ef66658cc1ebc7a525">lbm_context_topic_resolution_request</a> (lbm_context_t *ctx, lbm_ushort_t flags, lbm_ulong_t interval_msec, lbm_ulong_t duration_sec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request Topic Advertisements (sources), Topic Queries (receivers), and/or Wildcard Topic Queries (wildcard receivers) in the configured topic resolution address domain. Since Advertisements and Queries can become quiescent after a period defined by the Topic Resolution configuration attributes, this function will schedule Topic Resolution Requests at the given interval and duration. Contexts that receive these requests will respond with one advertisement per source and/or one query per receiver as appropriate. These requests will be ignored for topics that are not quiescent. Note that requests are only sent on the outgoing address and are only received on the incoming address. Responses to the request will similarly be sent only on the outgoing address.  <a href="#e6dd7c56acf916ef66658cc1ebc7a525"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#7debaa78e85dac5ce8db71a5e1935b65">lbm_context_setopt</a> (lbm_context_t *ctx, const char *optname, const void *optval, size_t optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option value within the given <em>ctx</em>.  <a href="#7debaa78e85dac5ce8db71a5e1935b65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6ac71262b2016486e02c217536503744">lbm_context_str_setopt</a> (lbm_context_t *ctx, const char *optname, const char *optval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option value within the given <em>ctx</em>.  <a href="#6ac71262b2016486e02c217536503744"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#4e8a7c286aecb0dfa9a216149d8bcae8">lbm_context_getopt</a> (lbm_context_t *ctx, const char *optname, void *optval, size_t *optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve an option value within the given <em>ctx</em>.  <a href="#4e8a7c286aecb0dfa9a216149d8bcae8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#50146c00b603ee92376958034df8d3b4">lbm_context_str_getopt</a> (lbm_context_t *ctx, const char *optname, char *optval, size_t *optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the textual option value within the given <em>ctx</em>.  <a href="#50146c00b603ee92376958034df8d3b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#374f135dddf7794130509f97b1e96cf8">lbm_context_rcv_immediate_msgs</a> (lbm_context_t *ctx, <a class="el" href="lbm_8h.html#7947fbc8b37e649ff36cc9ca66ef2dc7">lbm_immediate_msg_cb_proc</a> proc, void *clientd, lbm_event_queue_t *evq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the callback procedure and delivery method for non-topic immediate messages.  <a href="#374f135dddf7794130509f97b1e96cf8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#bdefbb3bd3ff3a3b2ec6e20ca2f5dc19">lbm_context_rcv_immediate_topic_msgs</a> (lbm_context_t *ctx, <a class="el" href="lbm_8h.html#7947fbc8b37e649ff36cc9ca66ef2dc7">lbm_immediate_msg_cb_proc</a> proc, void *clientd, lbm_event_queue_t *evq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the callback procedure and delivery method for immediate messages to a topic for which there is no receiver.  <a href="#bdefbb3bd3ff3a3b2ec6e20ca2f5dc19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#32682ab7b6432a84e5d3e26c30ad6c9c">lbm_context_set_name</a> (lbm_context_t *ctx, const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the name associated with a context.  <a href="#32682ab7b6432a84e5d3e26c30ad6c9c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#560203dca8edb43c74db155bb958e6ae">lbm_context_get_name</a> (lbm_context_t *ctx, char *name, size_t *size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name associated with a context.  <a href="#560203dca8edb43c74db155bb958e6ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c81ce10cac5b109e1f96ecff8cbf5772">lbm_license_file</a> (const char *licfile)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the UM license from the contents of a disk file. This function will only be effective if it is called before any other UM API function.  <a href="#c81ce10cac5b109e1f96ecff8cbf5772"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#69282fd2de2f3d773e94c610aa67ebbe">lbm_license_str</a> (const char *licstr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the UM license from a string. This function will only be effective if it is called before any other UM API function.  <a href="#69282fd2de2f3d773e94c610aa67ebbe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ecac05969bba0d6057589ca03dfe60a2">lbm_config</a> (const char *fname)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set one or more options from the contents of a disk file. This function will only be effective if it is called before any other UM API function.  <a href="#ecac05969bba0d6057589ca03dfe60a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b1dc9d6fa0a9af0399a61a8d6029cf73">lbm_config_xml_file</a> (const char *url, const char *application_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a UM XML configuration file.  <a href="#b1dc9d6fa0a9af0399a61a8d6029cf73"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c3cb9ed202d10200b9e621f499556159">lbm_config_xml_string</a> (const char *xml_data, const char *application_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load UM XML configuration data.  <a href="#c3cb9ed202d10200b9e621f499556159"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ae14099b91f2919f424e81f20ca10951">lbm_log</a> (<a class="el" href="lbm_8h.html#72ac99d9f07d98bfe2c7c5856d37c2d0">lbm_log_cb_proc</a> proc, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a callback function to be called for UM log messages (warnings, notices, etc.).  <a href="#ae14099b91f2919f424e81f20ca10951"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#aa36f4dcd32603a33c0a2c129dd2c3aa">lbm_logf</a> (int level, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Log a message. This is an entry to the UM logging mechanism.  <a href="#aa36f4dcd32603a33c0a2c129dd2c3aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#22a4650d3a5b649c84a0c05adedcc055">lbm_errmsg</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an ASCII string containing the error message last encountered by this thread.  <a href="#22a4650d3a5b649c84a0c05adedcc055"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f3a827eb26d87be5b1a6b9fd3a4b63aa">lbm_errnum</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the error number last encountered by this thread.  <a href="#f3a827eb26d87be5b1a6b9fd3a4b63aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ca04dc5f9048bc27f1db54b93cd73932">lbm_win32_static_thread_attach</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instructs UM that a new thread will be calling UM functions.  <a href="#ca04dc5f9048bc27f1db54b93cd73932"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#62c79b9485498ad5bb2f240e1705d8ce">lbm_win32_static_thread_detach</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instructs UM that a new thread is done calling UM functions.  <a href="#62c79b9485498ad5bb2f240e1705d8ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6ddbee95ee1eb4e6b98b177f84157f8a">lbm_schedule_timer</a> (lbm_context_t *ctx, <a class="el" href="lbm_8h.html#147d905636bb3b870ba5c0096c3f66b9">lbm_timer_cb_proc</a> proc, void *clientd, lbm_event_queue_t *evq, lbm_ulong_t delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Schedule a timer that calls <em>proc</em> when it expires.  <a href="#6ddbee95ee1eb4e6b98b177f84157f8a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#24835c6842e7973ceff9fd60fb3239c9">lbm_schedule_timer_recurring</a> (lbm_context_t *ctx, <a class="el" href="lbm_8h.html#147d905636bb3b870ba5c0096c3f66b9">lbm_timer_cb_proc</a> proc, void *clientd, lbm_event_queue_t *evq, lbm_ulong_t delay)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Schedule a recurring timer that calls <em>proc</em> when it expires.  <a href="#24835c6842e7973ceff9fd60fb3239c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ac8fc2f828cdcd6a44282c950ee01fb0">lbm_cancel_timer</a> (lbm_context_t *ctx, int id, void **clientdp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel a previously scheduled timer identified by <em>id</em>.  <a href="#ac8fc2f828cdcd6a44282c950ee01fb0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#cd48cd37dda3e76c9daa7b7a939846e4">lbm_cancel_timer_ex</a> (lbm_context_t *ctx, int id, void **clientdp, <a class="el" href="structlbm__event__queue__cancel__cb__info__t__stct.html">lbm_event_queue_cancel_cb_info_t</a> *cbinfo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extended cancel a previously scheduled timer identified by <em>id</em>.  <a href="#cd48cd37dda3e76c9daa7b7a939846e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#d9416b1f0b474b5d4c4f39bb3c4bda77">lbm_context_process_events</a> (lbm_context_t *ctx, lbm_ulong_t msec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process internal events in the given UM context object.  <a href="#d9416b1f0b474b5d4c4f39bb3c4bda77"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#d3d4137ff9ac0a1d4431c9d75ee3708c">lbm_context_unblock</a> (lbm_context_t *ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unblock a sequential mode UM context.  <a href="#d3d4137ff9ac0a1d4431c9d75ee3708c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#8729a284ef9f01f329fbf0edbc147227">lbm_context_process_lbtipc_messages</a> (lbm_context_t *ctx, lbm_ulong_t msec, lbm_ulong_t loop_count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process LBT-IPC messages received.  <a href="#8729a284ef9f01f329fbf0edbc147227"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#00e558f182c07f4187de00ce6132ad20">lbm_context_lbtipc_unblock</a> (lbm_context_t *ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unblock a sequential mode LBT-IPC processing loop.  <a href="#00e558f182c07f4187de00ce6132ad20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#50d8ea5a6ebb5f1f0c6c5d9155c09657">lbm_register_fd</a> (lbm_context_t *ctx, lbm_handle_t handle, <a class="el" href="lbm_8h.html#0aa2a7e14eca4d75925063cac2ecd879">lbm_fd_cb_proc</a> proc, void *clientd, lbm_event_queue_t *evq, lbm_ulong_t ev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a file descriptor/socket for events that calls <em>proc</em> when a given event occurs.  <a href="#50d8ea5a6ebb5f1f0c6c5d9155c09657"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ea6845ad513f07a994d23d3c50201436">lbm_cancel_fd</a> (lbm_context_t *ctx, lbm_handle_t handle, lbm_ulong_t ev)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel a previously registered file descriptor/socket event.  <a href="#ea6845ad513f07a994d23d3c50201436"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#55bed50f2627d24371ab9acae1f27f33">lbm_cancel_fd_ex</a> (lbm_context_t *ctx, lbm_handle_t handle, lbm_ulong_t ev, <a class="el" href="structlbm__event__queue__cancel__cb__info__t__stct.html">lbm_event_queue_cancel_cb_info_t</a> *cbinfo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extended cancel a previously registered file descriptor/socket event.  <a href="#55bed50f2627d24371ab9acae1f27f33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#33d3ee1d815f4a51b68653d8a063f87f">lbm_src_topic_dump</a> (lbm_src_t *src, int *size, lbm_config_option_t *opts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves all source topic attribute options.  <a href="#33d3ee1d815f4a51b68653d8a063f87f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#1d7722b39132940193205d6287c0a7f7">lbm_src_topic_attr_dump</a> (lbm_src_topic_attr_t *sattr, int *size, lbm_config_option_t *opts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves all source topic attribute options.  <a href="#1d7722b39132940193205d6287c0a7f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#9166df450621e271b833e0727a0fca0e">lbm_src_topic_attr_option_size</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of options that are of type "topic".  <a href="#9166df450621e271b833e0727a0fca0e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#1ba60407fa2bde0997aab6d5a5d2da1a">lbm_src_topic_alloc</a> (lbm_topic_t **topicp, lbm_context_t *ctx, const char *symbol, const lbm_src_topic_attr_t *attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Turn a Topic string into a UM topic object usable by sources.  <a href="#1ba60407fa2bde0997aab6d5a5d2da1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#d6ed0c9ec2565764a31f2db09a0e43c3">lbm_src_topic_attr_create</a> (lbm_src_topic_attr_t **attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and fill a UM source topic attribute object with the current default values.  <a href="#d6ed0c9ec2565764a31f2db09a0e43c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c299cf26605e18261b812a43012b1c24">lbm_src_topic_attr_create_default</a> (lbm_src_topic_attr_t **attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and fill a UM source topic attribute object with the initial default values.  <a href="#c299cf26605e18261b812a43012b1c24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#dc12814cac6280b5bd48bfde41d7c88a">lbm_src_topic_attr_create_from_xml</a> (lbm_src_topic_attr_t **attr, const char *context_name, const char *topicname)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and fill a UM source topic attribute object with the current default values for the given topic name.  <a href="#dc12814cac6280b5bd48bfde41d7c88a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c69fa2e963794dfea2dd2553d43053d4">lbm_src_topic_attr_set_from_xml</a> (lbm_src_topic_attr_t *attr, const char *context_name, const char *topicname)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill a UM source topic attribute object with the current default values for the given topic name.  <a href="#c69fa2e963794dfea2dd2553d43053d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#cb24cc75476206c155b00c4994aece85">lbm_src_topic_attr_delete</a> (lbm_src_topic_attr_t *attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a source topic attribute object.  <a href="#cb24cc75476206c155b00c4994aece85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c91185a9190cfe07d9ac247ed3be8379">lbm_src_topic_attr_dup</a> (lbm_src_topic_attr_t **attr, const lbm_src_topic_attr_t *original)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Duplicate a UM source topic attribute object.  <a href="#c91185a9190cfe07d9ac247ed3be8379"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#96ea052dce2e6376684cbf2003407cbf">lbm_src_topic_attr_setopt</a> (lbm_src_topic_attr_t *attr, const char *optname, const void *optval, size_t optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option value within the given source topic attribute.  <a href="#96ea052dce2e6376684cbf2003407cbf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#422f330bf7ef3efdd7a9f17caabccb24">lbm_src_topic_attr_str_setopt</a> (lbm_src_topic_attr_t *attr, const char *optname, const char *optval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option value within the given source topic attribute.  <a href="#422f330bf7ef3efdd7a9f17caabccb24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#434a1c5f20dc79c81a2df6d8fa47859f">lbm_src_topic_attr_getopt</a> (lbm_src_topic_attr_t *attr, const char *optname, void *optval, size_t *optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve an option value within the given source topic attribute.  <a href="#434a1c5f20dc79c81a2df6d8fa47859f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#38757fa8dda179e00b62d3e8029391c4">lbm_src_topic_attr_str_getopt</a> (lbm_src_topic_attr_t *attr, const char *optname, char *optval, size_t *optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a textual option value within the given source topic attribute.  <a href="#38757fa8dda179e00b62d3e8029391c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#3de8a6a659896f76475c453683db4e18">lbm_rcv_topic_lookup</a> (lbm_topic_t **topicp, lbm_context_t *ctx, const char *symbol, const lbm_rcv_topic_attr_t *attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Turn a Topic string into a UM topic object usable by receivers.  <a href="#3de8a6a659896f76475c453683db4e18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#401a14b61ff1e465cc0d3cd8acade13f">lbm_rcv_topic_dump</a> (lbm_rcv_t *rcv, int *size, lbm_config_option_t *opts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves all receiver topic attribute options.  <a href="#401a14b61ff1e465cc0d3cd8acade13f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#7a8f94b03c37c4481044d3c6b250bdb3">lbm_rcv_topic_attr_dump</a> (lbm_rcv_topic_attr_t *rattr, int *size, lbm_config_option_t *opts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves all receiver topic attribute options.  <a href="#7a8f94b03c37c4481044d3c6b250bdb3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#cf137258cb4a6633caeab1c4a3755be3">lbm_rcv_topic_attr_option_size</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of options that are of type "source topic".  <a href="#cf137258cb4a6633caeab1c4a3755be3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#7570d49deff46d63d636956e7a0dd2c4">lbm_rcv_topic_attr_create</a> (lbm_rcv_topic_attr_t **attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and fill a UM receiver topic attribute object with the current default values.  <a href="#7570d49deff46d63d636956e7a0dd2c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a0b62bc911b175ff51236ecf101d0d93">lbm_rcv_topic_attr_create_default</a> (lbm_rcv_topic_attr_t **attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and fill a UM receiver topic attribute object with the initial default values.  <a href="#a0b62bc911b175ff51236ecf101d0d93"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#0427c06f6d62e7401d9a7d1f09c79a2c">lbm_rcv_topic_attr_create_from_xml</a> (lbm_rcv_topic_attr_t **attr, const char *context_name, const char *topicname)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and fill a UM receiver topic attribute object with the current default values for the given topic name.  <a href="#0427c06f6d62e7401d9a7d1f09c79a2c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#3edb4ccb0e392da57bc7a46fe21e7007">lbm_rcv_topic_attr_set_from_xml</a> (lbm_rcv_topic_attr_t *attr, const char *context_name, const char *topicname)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill a UM receiver topic attribute object with the current default values for the given topic name.  <a href="#3edb4ccb0e392da57bc7a46fe21e7007"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f70d14c26efadade6ad1e22d254f4e1b">lbm_rcv_topic_attr_delete</a> (lbm_rcv_topic_attr_t *attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a receiver topic attribute object.  <a href="#f70d14c26efadade6ad1e22d254f4e1b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a5a904ef90068238358b66562ec30f44">lbm_rcv_topic_attr_dup</a> (lbm_rcv_topic_attr_t **attr, const lbm_rcv_topic_attr_t *original)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Duplicate a UM receiver topic attribute object.  <a href="#a5a904ef90068238358b66562ec30f44"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#1afc75f0fb3601d072b3463e7acf16a6">lbm_rcv_topic_attr_setopt</a> (lbm_rcv_topic_attr_t *attr, const char *optname, const void *optval, size_t optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option value within the given receiver topic attribute.  <a href="#1afc75f0fb3601d072b3463e7acf16a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#fabe075e34f7f712f09f710df87d9164">lbm_rcv_topic_attr_str_setopt</a> (lbm_rcv_topic_attr_t *attr, const char *optname, const char *optval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option value within the given receiver topic attribute.  <a href="#fabe075e34f7f712f09f710df87d9164"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6486a4096cbe232967c5f4a3d1d859cb">lbm_rcv_topic_attr_getopt</a> (lbm_rcv_topic_attr_t *attr, const char *optname, void *optval, size_t *optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve an option value within the given receiver topic attribute.  <a href="#6486a4096cbe232967c5f4a3d1d859cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ba79f39d27fb6fd38d8bc6985a33c8ec">lbm_rcv_topic_attr_str_getopt</a> (lbm_rcv_topic_attr_t *attr, const char *optname, char *optval, size_t *optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a textual option value within the given receiver topic attribute.  <a href="#ba79f39d27fb6fd38d8bc6985a33c8ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#73298f53aa9c5572cd0b1e68a4ec435a">lbm_src_channel_create</a> (lbm_src_channel_info_t **chnp, lbm_src_t *src, lbm_uint32_t channel_num)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a channel info object to send messages with the given <em>channel_num</em>.  <a href="#73298f53aa9c5572cd0b1e68a4ec435a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#d49d9550c5927c8633f11461b9f60104">lbm_src_channel_delete</a> (lbm_src_channel_info_t *chn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release the resources associated with a source channel.  <a href="#d49d9550c5927c8633f11461b9f60104"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b8dd76271bf9df7a5f88476d431f523e">lbm_src_create</a> (lbm_src_t **srcp, lbm_context_t *ctx, lbm_topic_t *topic, <a class="el" href="lbm_8h.html#7503c005ce424fa049494e37b708d396">lbm_src_cb_proc</a> proc, void *clientd, lbm_event_queue_t *evq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a UM source that will send messages to the given <em>topic</em>.  <a href="#b8dd76271bf9df7a5f88476d431f523e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#1ffd0581c0ee8993f12094149f9a960b">lbm_event_queue_dump</a> (lbm_event_queue_t *evq, int *size, lbm_config_option_t *opts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves all event queue attribute options.  <a href="#1ffd0581c0ee8993f12094149f9a960b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#09bc0d170eadffe1eb1c30d421074125">lbm_event_queue_attr_dump</a> (lbm_event_queue_attr_t *eattr, int *size, lbm_config_option_t *opts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves all event queue attribute options.  <a href="#09bc0d170eadffe1eb1c30d421074125"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#9dfe270c08d183e0f18544d32aa63d9a">lbm_event_queue_attr_option_size</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of options that are of type "event queue".  <a href="#9dfe270c08d183e0f18544d32aa63d9a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a7491c50fefbc2b70f8035fce7ac1477">lbm_rcv_create</a> (lbm_rcv_t **rcvp, lbm_context_t *ctx, lbm_topic_t *topic, <a class="el" href="lbm_8h.html#e2d650dd4830971ca0b6197298eddcdd">lbm_rcv_cb_proc</a> proc, void *clientd, lbm_event_queue_t *evq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a UM receiver that will receive messages sent to the given <em>topic</em>.  <a href="#a7491c50fefbc2b70f8035fce7ac1477"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a8304114445d291e6f16472d733ab250">lbm_rcv_subscribe_channel</a> (lbm_rcv_t *rcv, lbm_uint32_t channel, <a class="el" href="lbm_8h.html#e2d650dd4830971ca0b6197298eddcdd">lbm_rcv_cb_proc</a> proc, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subscribe to a channel, with an optional callback and clientd data pointer.  <a href="#a8304114445d291e6f16472d733ab250"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ac3f8d58d98db9b2471982a44e157ae9">lbm_rcv_unsubscribe_channel</a> (lbm_rcv_t *rcv, lbm_uint32_t channel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Discontinue an existing channel subscription.  <a href="#ac3f8d58d98db9b2471982a44e157ae9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#53023d43207f2d4b0a37143e96383a96">lbm_rcv_unsubscribe_channel_ex</a> (lbm_rcv_t *rcv, lbm_uint32_t channel, <a class="el" href="structlbm__event__queue__cancel__cb__info__t__stct.html">lbm_event_queue_cancel_cb_info_t</a> *cbinfo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Discontinue an existing channel subscription with an application callback indicating when all messages on the channel have been delivered. This extended version of the unsubscribe function requires the configuration option queue_cancellation_callbacks_enabled be set to 1.  <a href="#53023d43207f2d4b0a37143e96383a96"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a9d6c40859030a0c99d06f1f4da202b3">lbm_wildcard_rcv_subscribe_channel</a> (lbm_wildcard_rcv_t *wrcv, lbm_uint32_t channel, <a class="el" href="lbm_8h.html#e2d650dd4830971ca0b6197298eddcdd">lbm_rcv_cb_proc</a> proc, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subscribe to a channel, with an optional callback and clientd data pointer.  <a href="#a9d6c40859030a0c99d06f1f4da202b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#e05194988e175999e68b15874e342483">lbm_wildcard_rcv_unsubscribe_channel</a> (lbm_wildcard_rcv_t *wrcv, lbm_uint32_t channel)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Discontinue an existing channel subscription.  <a href="#e05194988e175999e68b15874e342483"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#feea1f5c5958a3df406ccf5c30014d72">lbm_wildcard_rcv_unsubscribe_channel_ex</a> (lbm_wildcard_rcv_t *wrcv, lbm_uint32_t channel, <a class="el" href="structlbm__event__queue__cancel__cb__info__t__stct.html">lbm_event_queue_cancel_cb_info_t</a> *cbinfo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Discontinue an existing channel subscription with an application callback indicating when all messages on the channel have been delivered. This extended version of the unsubscribe function requires the configuration option queue_cancellation_callbacks_enabled be set to 1.  <a href="#feea1f5c5958a3df406ccf5c30014d72"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#29d45db8f76835b4ae78f4568c25712f">lbm_src_delete</a> (lbm_src_t *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a UM source object.  <a href="#29d45db8f76835b4ae78f4568c25712f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a714727708c894e3cfcf9c41c265c986">lbm_src_delete_ex</a> (lbm_src_t *src, <a class="el" href="structlbm__event__queue__cancel__cb__info__t__stct.html">lbm_event_queue_cancel_cb_info_t</a> *cbinfo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extended delete a UM source object.  <a href="#a714727708c894e3cfcf9c41c265c986"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL lbm_context_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#1fe217c6b1ecc8b796e8e1977a1a0f7a">lbm_context_from_src</a> (lbm_src_t *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the UM context object associated with a UM source object.  <a href="#1fe217c6b1ecc8b796e8e1977a1a0f7a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL lbm_topic_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#7b90c3d7df0e7833af4136e584439b90">lbm_topic_from_src</a> (lbm_src_t *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the UM topic object associated with a UM source object.  <a href="#7b90c3d7df0e7833af4136e584439b90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL lbm_event_queue_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#2326c9d45600ea1265eb1338fd05193c">lbm_event_queue_from_src</a> (lbm_src_t *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the UM event queue object associated with a UM source object.  <a href="#2326c9d45600ea1265eb1338fd05193c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#8d5e8713f5ae776330b23a1e371f934d">lbm_rcv_delete</a> (lbm_rcv_t *rcv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a UM receiver object.  <a href="#8d5e8713f5ae776330b23a1e371f934d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#eb6fc66ee4fdd7f4c9d439af54d45f68">lbm_rcv_delete_ex</a> (lbm_rcv_t *rcv, <a class="el" href="structlbm__event__queue__cancel__cb__info__t__stct.html">lbm_event_queue_cancel_cb_info_t</a> *cbinfo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extended delete a UM receiver object.  <a href="#eb6fc66ee4fdd7f4c9d439af54d45f68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL lbm_context_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#fdb049743c04a16a1e2dd8c6fe121148">lbm_context_from_rcv</a> (lbm_rcv_t *rcv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the UM context object associated with a UM receiver object.  <a href="#fdb049743c04a16a1e2dd8c6fe121148"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL lbm_event_queue_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c1d492d2d5abdce67cca76d50d7940d6">lbm_event_queue_from_rcv</a> (lbm_rcv_t *rcv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the UM event queue object associated with a UM receiver object.  <a href="#c1d492d2d5abdce67cca76d50d7940d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#561190e0b26353f112b3bcb499c057f7">lbm_src_setopt</a> (lbm_src_t *src, const char *optname, const void *optval, size_t optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option value within the given <em>src</em>.  <a href="#561190e0b26353f112b3bcb499c057f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#4f78f4100b2a9c80ea90b60bdebe5176">lbm_src_str_setopt</a> (lbm_src_t *src, const char *optname, const char *optval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option value within the given <em>src</em>.  <a href="#4f78f4100b2a9c80ea90b60bdebe5176"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6cd6a5f1384b97fca390c711d1261ed5">lbm_src_getopt</a> (lbm_src_t *src, const char *optname, void *optval, size_t *optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve an option value within the given <em>src</em>.  <a href="#6cd6a5f1384b97fca390c711d1261ed5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#bd4b0baffdf68ba0f0e2cb006fa9b0b4">lbm_src_str_getopt</a> (lbm_src_t *src, const char *optname, char *optval, size_t *optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a textual option value within the given <em>src</em>.  <a href="#bd4b0baffdf68ba0f0e2cb006fa9b0b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#fc63f0e557452ac8a8b184c72893a279">lbm_rcv_setopt</a> (lbm_rcv_t *rcv, const char *optname, const void *optval, size_t optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option value within the given <em>rcv</em>.  <a href="#fc63f0e557452ac8a8b184c72893a279"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b592a69f45ea303ab21e9290953b57b4">lbm_rcv_str_setopt</a> (lbm_rcv_t *rcv, const char *optname, const char *optval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option value within the given <em>rcv</em>.  <a href="#b592a69f45ea303ab21e9290953b57b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#767c9e2d97255433a787e336498edf59">lbm_rcv_getopt</a> (lbm_rcv_t *rcv, const char *optname, void *optval, size_t *optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve an option value within the given <em>rcv</em>.  <a href="#767c9e2d97255433a787e336498edf59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#16cdcbe8c78428c6ac7b447ec89f2a78">lbm_rcv_str_getopt</a> (lbm_rcv_t *rcv, const char *optname, char *optval, size_t *optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a textual option value within the given <em>rcv</em>.  <a href="#16cdcbe8c78428c6ac7b447ec89f2a78"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#91f4b9cb04fe1323ec56833211cc5cb7">lbm_src_send</a> (lbm_src_t *src, const char *msg, size_t len, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a message to the topic associated with a UM source.  <a href="#91f4b9cb04fe1323ec56833211cc5cb7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#091b5806bf18d10ebd0d9117e0c70229">lbm_src_send_ex</a> (lbm_src_t *src, const char *msg, size_t len, int flags, <a class="el" href="structlbm__src__send__ex__info__t__stct.html">lbm_src_send_ex_info_t</a> *info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extended send of a message to the topic associated with a UM source.  <a href="#091b5806bf18d10ebd0d9117e0c70229"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#fec0ee6822fe721f21c67536660506ea">lbm_src_flush</a> (lbm_src_t *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send messages from both the explicit and implicit batches ASAP.  <a href="#fec0ee6822fe721f21c67536660506ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f28189e64ef0ee10d3444e418443aaa9">lbm_src_sendv</a> (lbm_src_t *src, const <a class="el" href="structlbm__iovec__t__stct.html">lbm_iovec_t</a> *iov, int num, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a set of messages to the topic associated with a UM source.  <a href="#f28189e64ef0ee10d3444e418443aaa9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#4d883eaaa22baf81abf21d495f471c8b">lbm_src_sendv_ex</a> (lbm_src_t *src, const <a class="el" href="structlbm__iovec__t__stct.html">lbm_iovec_t</a> *iov, int num, int flags, <a class="el" href="structlbm__src__send__ex__info__t__stct.html">lbm_src_send_ex_info_t</a> *info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extended send of a set of messages to the topic associated with a UM source.  <a href="#4d883eaaa22baf81abf21d495f471c8b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#1abe9c827de0247d804d17e821d68eb1">lbm_rcv_msg_source_clientd</a> (lbm_rcv_t *rcv, const char *source, void *source_clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the pointer value to set in the messages received for the given receiver from a specific source.  <a href="#1abe9c827de0247d804d17e821d68eb1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#976eeac5bd741e2c320a1f341a22af1a">lbm_src_retrieve_transport_stats</a> (lbm_src_t *src, <a class="el" href="structlbm__src__transport__stats__t__stct.html">lbm_src_transport_stats_t</a> *stats)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the transport statistics for the transport used by the given source.  <a href="#976eeac5bd741e2c320a1f341a22af1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ea2efde8ec7b0bc2e5bf81b9fdecfb1c">lbm_src_reset_transport_stats</a> (lbm_src_t *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the transport statistics for the transport used by the given source.  <a href="#ea2efde8ec7b0bc2e5bf81b9fdecfb1c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#4094c703f97a7ebe340b985b2ed1ac2b">lbm_rcv_retrieve_transport_stats</a> (lbm_rcv_t *rcv, const char *source, <a class="el" href="structlbm__rcv__transport__stats__t__stct.html">lbm_rcv_transport_stats_t</a> *stats)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the transport statistics for the transport used by the given receiver from a specific source.  <a href="#4094c703f97a7ebe340b985b2ed1ac2b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#052109723d62dcfc0e5561891cc7b0d6">lbm_rcv_reset_transport_stats</a> (lbm_rcv_t *rcv, const char *source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the transport statistics for the transport used by the given receiver from a specific source.  <a href="#052109723d62dcfc0e5561891cc7b0d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f49cc8ea36d829820466790d9857f9de">lbm_rcv_retrieve_all_transport_stats</a> (lbm_rcv_t *rcv, int *num, <a class="el" href="structlbm__rcv__transport__stats__t__stct.html">lbm_rcv_transport_stats_t</a> *stats)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the transport stats for all the sources seen by the given receiver.  <a href="#f49cc8ea36d829820466790d9857f9de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fcb8a49677528af2862b3c5b707a7c14"></a><!-- doxytag: member="lbm.h::lbm_rcv_retrieve_all_transport_stats_ex" ref="fcb8a49677528af2862b3c5b707a7c14" args="(lbm_rcv_t *rcv, int *num, int size, lbm_rcv_transport_stats_t *stats)" -->
LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_rcv_retrieve_all_transport_stats_ex</b> (lbm_rcv_t *rcv, int *num, int size, <a class="el" href="structlbm__rcv__transport__stats__t__stct.html">lbm_rcv_transport_stats_t</a> *stats)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#8624a19b3cab06cadb9540b5795d688b">lbm_rcv_reset_all_transport_stats</a> (lbm_rcv_t *rcv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the transport stats for all the sources seen by the given receiver.  <a href="#8624a19b3cab06cadb9540b5795d688b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#147a3639e45780731e3a2a37adb529f2">lbm_context_retrieve_rcv_transport_stats</a> (lbm_context_t *ctx, int *num, <a class="el" href="structlbm__rcv__transport__stats__t__stct.html">lbm_rcv_transport_stats_t</a> *stats)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the transport stats for all receivers in a given context.  <a href="#147a3639e45780731e3a2a37adb529f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c86fe14bb00a3747d0ed9ae3611fa1b8"></a><!-- doxytag: member="lbm.h::lbm_context_retrieve_rcv_transport_stats_ex" ref="c86fe14bb00a3747d0ed9ae3611fa1b8" args="(lbm_context_t *ctx, int *num, int size, lbm_rcv_transport_stats_t *stats)" -->
LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_context_retrieve_rcv_transport_stats_ex</b> (lbm_context_t *ctx, int *num, int size, <a class="el" href="structlbm__rcv__transport__stats__t__stct.html">lbm_rcv_transport_stats_t</a> *stats)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#9920a312bc7b52f20133ddbdd430a075">lbm_context_reset_rcv_transport_stats</a> (lbm_context_t *ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the transport stats for all receivers in a given context.  <a href="#9920a312bc7b52f20133ddbdd430a075"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#14e652f7827e5abfe07fcd3522b19b44">lbm_context_retrieve_src_transport_stats</a> (lbm_context_t *ctx, int *num, <a class="el" href="structlbm__src__transport__stats__t__stct.html">lbm_src_transport_stats_t</a> *stats)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the transport stats for all the sources in a given context.  <a href="#14e652f7827e5abfe07fcd3522b19b44"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8bd29d93b29e86e2a6fa6da15412da7b"></a><!-- doxytag: member="lbm.h::lbm_context_retrieve_src_transport_stats_ex" ref="8bd29d93b29e86e2a6fa6da15412da7b" args="(lbm_context_t *ctx, int *num, int size, lbm_src_transport_stats_t *stats)" -->
LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_context_retrieve_src_transport_stats_ex</b> (lbm_context_t *ctx, int *num, int size, <a class="el" href="structlbm__src__transport__stats__t__stct.html">lbm_src_transport_stats_t</a> *stats)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#fe25aeb42965853a836488a4ed6d905e">lbm_context_reset_src_transport_stats</a> (lbm_context_t *ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the transport stats for all the sources in a given context.  <a href="#fe25aeb42965853a836488a4ed6d905e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#eb9ed445a630f0db48f8c9d24bf23178">lbm_event_queue_retrieve_stats</a> (lbm_event_queue_t *evq, <a class="el" href="structlbm__event__queue__stats__t__stct.html">lbm_event_queue_stats_t</a> *stats)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the stats for an event queue.  <a href="#eb9ed445a630f0db48f8c9d24bf23178"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#1838b8382eb314eed96e6ed48c0d1f5b">lbm_event_queue_reset_stats</a> (lbm_event_queue_t *evq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the stats for an event queue.  <a href="#1838b8382eb314eed96e6ed48c0d1f5b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a8f2d2e5b28e2c97911117acb099c48e">lbm_context_retrieve_stats</a> (lbm_context_t *ctx, <a class="el" href="structlbm__context__stats__t__stct.html">lbm_context_stats_t</a> *stats)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the stats for a context.  <a href="#a8f2d2e5b28e2c97911117acb099c48e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#11a95d8df314fb8dd95e6fa428dc1d64">lbm_context_reset_stats</a> (lbm_context_t *ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the stats for a context.  <a href="#11a95d8df314fb8dd95e6fa428dc1d64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#deb93551e63dcb44a871f2fd97d3b87f">lbm_context_retrieve_im_src_transport_stats</a> (lbm_context_t *ctx, int *num, int size, <a class="el" href="structlbm__src__transport__stats__t__stct.html">lbm_src_transport_stats_t</a> *stats)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the IM source stats for a context.  <a href="#deb93551e63dcb44a871f2fd97d3b87f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c4ea73752995bb541b9eacad59815bd0">lbm_context_reset_im_src_transport_stats</a> (lbm_context_t *ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the IM source stats for a context.  <a href="#c4ea73752995bb541b9eacad59815bd0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#3a167b88f0a789dce27eb77160a9d2f2">lbm_context_retrieve_im_rcv_transport_stats</a> (lbm_context_t *ctx, int *num, int size, <a class="el" href="structlbm__rcv__transport__stats__t__stct.html">lbm_rcv_transport_stats_t</a> *stats)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the IM receiver stats for a context.  <a href="#3a167b88f0a789dce27eb77160a9d2f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#e776bad129eb68dfd548d1f7d70ae848">lbm_context_reset_im_rcv_transport_stats</a> (lbm_context_t *ctx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the IM receiver stats for a context.  <a href="#e776bad129eb68dfd548d1f7d70ae848"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#2b7788ff58f9e78bc89ea890dad0cccf">lbm_msg_retain</a> (<a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instruct UM that the API is going to retain ownership of a UM message object.  <a href="#2b7788ff58f9e78bc89ea890dad0cccf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#7b47a27da53a3855980769c2e8494141">lbm_msg_is_fragment</a> (<a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve fragment information from a UM message.  <a href="#7b47a27da53a3855980769c2e8494141"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#fa760960c21f502a8cb4c5ec5d97f91b">lbm_msg_retrieve_fragment_info</a> (<a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *msg, <a class="el" href="structlbm__msg__fragment__info__t__stct.html">lbm_msg_fragment_info_t</a> *info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns 1 if lbm message is a fragment, else 0 is returned.  <a href="#fa760960c21f502a8cb4c5ec5d97f91b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#60b05990989966403f948bb888c1a87d">lbm_msg_retrieve_gateway_info</a> (<a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *msg, <a class="el" href="structlbm__msg__gateway__info__t__stct.html">lbm_msg_gateway_info_t</a> *info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve gateway information from a UM message.  <a href="#60b05990989966403f948bb888c1a87d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#1443be763d9fd4c183b79e95e0b19605">lbm_msg_retrieve_msgid</a> (<a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *msg, <a class="el" href="structlbm__umq__msgid__t__stct.html">lbm_umq_msgid_t</a> *id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve UMQ Message ID information from a UM message.  <a href="#1443be763d9fd4c183b79e95e0b19605"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#e12a623cc402cb627501599367750500">lbm_msg_retrieve_umq_index</a> (<a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *msg, <a class="el" href="structlbm__umq__index__info__t__stct.html">lbm_umq_index_info_t</a> *info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve UMQ index information from a UM message.  <a href="#e12a623cc402cb627501599367750500"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9db4d429e3dc9e0984f48eefe6afdf65"></a><!-- doxytag: member="lbm.h::lbm_msg_retrieve_delivery_latency" ref="9db4d429e3dc9e0984f48eefe6afdf65" args="(lbm_msg_t *msg, lbm_int64_t *latency_nsecs)" -->
LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_msg_retrieve_delivery_latency</b> (<a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *msg, lbm_int64_t *latency_nsecs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a5fc1eb324a55b8c800c31460b0f0116">lbm_msg_delete</a> (<a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a UM message object.  <a href="#a5fc1eb324a55b8c800c31460b0f0116"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#d920e7ab51a45099390091dd36d26a34">lbm_msg_ume_send_explicit_ack</a> (<a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send an Explicit UMP ACK for a UM message object.  <a href="#d920e7ab51a45099390091dd36d26a34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#8fbcb30efc0ede0927402ea8d07ffb39">lbm_msg_ume_can_send_explicit_ack</a> (<a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check to see if Explicit UMP ACK for a UM message object can be called.  <a href="#8fbcb30efc0ede0927402ea8d07ffb39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#3a89366ab4e36dfa362e20397778d04a">lbm_src_ume_deregister</a> (lbm_src_t *src)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deregister a source from the UMP stores.  <a href="#3a89366ab4e36dfa362e20397778d04a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#861f4a170ec4caf4533669ee53fbf36f">lbm_rcv_ume_deregister</a> (lbm_rcv_t *rcv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deregister a receiver from all known UMP stores.  <a href="#861f4a170ec4caf4533669ee53fbf36f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#dc9f1b15ab516bed8556e7a20666770c">lbm_wrcv_ume_deregister</a> (lbm_wildcard_rcv_t *wrcv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deregister a wildcard receiver from all known UMP stores.  <a href="#dc9f1b15ab516bed8556e7a20666770c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#d7f45b2a1839090ec172a176ff6e2477">lbm_msg_umq_reassign</a> (<a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *msg, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do not acknowledge the given message and instead request that the message be reassigned.  <a href="#d7f45b2a1839090ec172a176ff6e2477"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#eeb72be91872f87626d26156c3201dfe">lbm_rcv_umq_deregister</a> (lbm_rcv_t *rcv, const char *queue_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">De-Register the given receiver from the given UMQ queue or all UMQ queues.  <a href="#eeb72be91872f87626d26156c3201dfe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f8ae533fd1738fffc12d5b986cbf5338">lbm_rcv_umq_index_stop_assignment</a> (lbm_rcv_t *rcv, const char *queue_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop assignment of new UMQ indices to the given receiver from the given UMQ queue or all UMQ queues.  <a href="#f8ae533fd1738fffc12d5b986cbf5338"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#07e8018202c16a5e0bcfefbef995f9a4">lbm_rcv_umq_index_start_assignment</a> (lbm_rcv_t *rcv, const char *queue_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start assignment of new UMQ indices to the given receiver from the given UMQ queue or all UMQ queues.  <a href="#07e8018202c16a5e0bcfefbef995f9a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#31ea2d64682933ad69600bf22e13a34d">lbm_rcv_umq_index_reserve</a> (lbm_rcv_t *rcv, const char *queue_name, <a class="el" href="structlbm__umq__index__info__t__stct.html">lbm_umq_index_info_t</a> *index_info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instruct the given UMQ queue(s) to reserve an index for assignment to this receiver.  <a href="#31ea2d64682933ad69600bf22e13a34d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#e145484500af1e2af206f02cd6b57f7e">lbm_rcv_umq_index_release</a> (lbm_rcv_t *rcv, const char *queue_name, <a class="el" href="structlbm__umq__index__info__t__stct.html">lbm_umq_index_info_t</a> *index_info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instruct the given UMQ queue(s) to release the given UMQ index that is assigned to the given receiver.  <a href="#e145484500af1e2af206f02cd6b57f7e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#15058af1a87407aefd1cbe7ae5ac53d0">lbm_wildcard_rcv_umq_index_stop_assignment</a> (lbm_wildcard_rcv_t *wrcv, const char *queue_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop assignment of new UMQ indices to the given wildcard receiver from the given UMQ queue or all UMQ queues.  <a href="#15058af1a87407aefd1cbe7ae5ac53d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ca0f28a53507aab4be69150fa1928b52">lbm_wildcard_rcv_umq_index_start_assignment</a> (lbm_wildcard_rcv_t *wrcv, const char *queue_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start assignment of new UMQ indices to the given wildcard receiver from the given UMQ queue or all UMQ queues.  <a href="#ca0f28a53507aab4be69150fa1928b52"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c898e0fc1f77452918c36f1c176a7f15">lbm_wildcard_rcv_umq_index_release</a> (lbm_wildcard_rcv_t *wrcv, const char *queue_name, <a class="el" href="structlbm__umq__index__info__t__stct.html">lbm_umq_index_info_t</a> *index_info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instruct the given UMQ queue(s) to release the given UMQ index that is assigned to the given wildcard receiver.  <a href="#c898e0fc1f77452918c36f1c176a7f15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#bdf5c9ae6ad1d5bb861eb8a9db4df4bc">lbm_wildcard_rcv_umq_deregister</a> (lbm_wildcard_rcv_t *wrcv, const char *queue_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">De-Register the given wildcard receiver from the given UMQ queue or all UMQ queues.  <a href="#bdf5c9ae6ad1d5bb861eb8a9db4df4bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#0bbc01b600ccc2ae874474e35955eb85">lbm_send_response</a> (lbm_response_t *resp, const char *data, size_t len, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a response for a given <em>resp</em> response.  <a href="#0bbc01b600ccc2ae874474e35955eb85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#95bbc6a8adcdc3217ee3ee4d24f3a70e">lbm_response_delete</a> (lbm_response_t *resp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a UM response object.  <a href="#95bbc6a8adcdc3217ee3ee4d24f3a70e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#0ce3f03714d1c51c8dcf30bdda7b37c4">lbm_serialized_response_delete</a> (<a class="el" href="structlbm__serialized__response__t__stct.html">lbm_serialized_response_t</a> *serialized_response)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a UM serialized response object.  <a href="#0ce3f03714d1c51c8dcf30bdda7b37c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL <a class="el" href="structlbm__serialized__response__t__stct.html">lbm_serialized_response_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#7595677bf01cb9397d1fd174bd095e9f">lbm_serialize_response</a> (lbm_response_t *resp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serialize a UM response object.  <a href="#7595677bf01cb9397d1fd174bd095e9f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL lbm_response_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#d74f47a1e021b2422b80c0bf8d03f7a9">lbm_deserialize_response</a> (lbm_context_t *ctx, <a class="el" href="structlbm__serialized__response__t__stct.html">lbm_serialized_response_t</a> *serialized_response)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">De-serialize a UM response object.  <a href="#d74f47a1e021b2422b80c0bf8d03f7a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#d4d06f66b8404684e191ca178e0cc09b">lbm_send_request</a> (lbm_request_t **reqp, lbm_src_t *src, const char *data, size_t len, <a class="el" href="lbm_8h.html#f3ef4385bc929e8a7ff94acbeb1eef75">lbm_request_cb_proc</a> proc, void *clientd, lbm_event_queue_t *evq, int send_flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a request on the given src that contains the given data.  <a href="#d4d06f66b8404684e191ca178e0cc09b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#abcfb44e7f5188a47d8d56540e783fa7">lbm_send_request_ex</a> (lbm_request_t **reqp, lbm_src_t *src, const char *data, size_t len, <a class="el" href="lbm_8h.html#f3ef4385bc929e8a7ff94acbeb1eef75">lbm_request_cb_proc</a> proc, void *clientd, lbm_event_queue_t *evq, int send_flags, <a class="el" href="structlbm__src__send__ex__info__t__stct.html">lbm_src_send_ex_info_t</a> *exinfo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a request on the given src that contains the given data.  <a href="#abcfb44e7f5188a47d8d56540e783fa7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#0abaa1c2ba62bba7a5eaf1f7f2abbac0">lbm_request_delete</a> (lbm_request_t *req)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a UM request object.  <a href="#0abaa1c2ba62bba7a5eaf1f7f2abbac0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f69d50b0f35e28bf6f36a9c5d9df2258">lbm_request_delete_ex</a> (lbm_request_t *req, <a class="el" href="structlbm__event__queue__cancel__cb__info__t__stct.html">lbm_event_queue_cancel_cb_info_t</a> *cbinfo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extended delete a UM request object.  <a href="#f69d50b0f35e28bf6f36a9c5d9df2258"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c7ebe02319363c84bef08f34be7865ec">lbm_event_queue_create</a> (lbm_event_queue_t **evqp, <a class="el" href="lbm_8h.html#1b4b56862044a11671aebac3ecd15b3a">lbm_event_queue_monitor_proc</a> proc, void *clientd, const lbm_event_queue_attr_t *attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a UM event queue object.  <a href="#c7ebe02319363c84bef08f34be7865ec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a481173def2062eb78401c4b5dee8fa7">lbm_event_queue_attr_create</a> (lbm_event_queue_attr_t **attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and fill a UM event queue attribute object with the current default values.  <a href="#a481173def2062eb78401c4b5dee8fa7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#8a410dd3ec412042412f7206b33f543a">lbm_event_queue_attr_create_default</a> (lbm_event_queue_attr_t **attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and fill a UM event queue attribute object with the initial default values.  <a href="#8a410dd3ec412042412f7206b33f543a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f85b737d29883af1e7be47a6e9057c6b">lbm_event_queue_attr_create_from_xml</a> (lbm_event_queue_attr_t **attr, const char *event_queue_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and fill a UM event queue attribute object with the current default values for the given event queue name.  <a href="#f85b737d29883af1e7be47a6e9057c6b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#8f376258a2ab5199d8cf8b852ad8a2f8">lbm_event_queue_attr_set_from_xml</a> (lbm_event_queue_attr_t *attr, const char *event_queue_name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill a UM event queue attribute object with the current default values for the given event queue name.  <a href="#8f376258a2ab5199d8cf8b852ad8a2f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#dec58e6e7eccd469bc66499b27445cb9">lbm_event_queue_attr_delete</a> (lbm_event_queue_attr_t *attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete an event queue attribute object.  <a href="#dec58e6e7eccd469bc66499b27445cb9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c596c3c5a7483bfef0d888f88e0ffa00">lbm_event_queue_attr_dup</a> (lbm_event_queue_attr_t **attr, const lbm_event_queue_attr_t *original)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Duplicate a UM event queue attribute object.  <a href="#c596c3c5a7483bfef0d888f88e0ffa00"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#522ba1e3a48a383693ab84bbc1242751">lbm_event_queue_attr_setopt</a> (lbm_event_queue_attr_t *attr, const char *optname, const void *optval, size_t optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option value within the given event queue attribute.  <a href="#522ba1e3a48a383693ab84bbc1242751"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#e142407377587720566411c40bcba19f">lbm_event_queue_attr_str_setopt</a> (lbm_event_queue_attr_t *attr, const char *optname, const char *optval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option value within the given event queue attribute.  <a href="#e142407377587720566411c40bcba19f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#4ed2752e3a7617dcb636c05151331302">lbm_event_queue_attr_getopt</a> (lbm_event_queue_attr_t *attr, const char *optname, void *optval, size_t *optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve an option value within the given event queue attribute.  <a href="#4ed2752e3a7617dcb636c05151331302"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ea2de962dcdcc1c575d38bd256414988">lbm_event_queue_attr_str_getopt</a> (lbm_event_queue_attr_t *attr, const char *optname, char *optval, size_t *optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a textual option value within the given event queue attribute.  <a href="#ea2de962dcdcc1c575d38bd256414988"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#4851096cebcf925e0e348bacec32aef0">lbm_event_queue_setopt</a> (lbm_event_queue_t *evq, const char *optname, const void *optval, size_t optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option value within the given <em>evq</em>.  <a href="#4851096cebcf925e0e348bacec32aef0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#e470da93b9bfbcf213afde0a9a95113e">lbm_event_queue_str_setopt</a> (lbm_event_queue_t *evq, const char *optname, const char *optval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option value within the given <em>event</em> queue.  <a href="#e470da93b9bfbcf213afde0a9a95113e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b5c77cb8b7818a9658edcb84fc857807">lbm_event_queue_getopt</a> (lbm_event_queue_t *evq, const char *optname, void *optval, size_t *optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve an option value within the given <em>event</em> queue.  <a href="#b5c77cb8b7818a9658edcb84fc857807"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#5ab263a1c33ba7a9b4ffa72a6a54075c">lbm_event_queue_str_getopt</a> (lbm_event_queue_t *evq, const char *optname, char *optval, size_t *optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a textual option value within the given <em>event</em> queue.  <a href="#5ab263a1c33ba7a9b4ffa72a6a54075c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c06b127bae882dd5fb68b7044fdceb5f">lbm_event_dispatch</a> (lbm_event_queue_t *evq, lbm_ulong_t tmo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dispatch waiting events to appropriate callback functions.  <a href="#c06b127bae882dd5fb68b7044fdceb5f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f4b1b274cb142acefe0826673ecffdbe">lbm_event_dispatch_unblock</a> (lbm_event_queue_t *evq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unblock the given UM event queue object so that a thread waiting in lbm_event_dispatch returns as soon as feasible.  <a href="#f4b1b274cb142acefe0826673ecffdbe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b0a5134ef39fc7054e5d164f0a1889f7">lbm_event_queue_size</a> (lbm_event_queue_t *evq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the number of queued events in the event queue.  <a href="#b0a5134ef39fc7054e5d164f0a1889f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#d94310754a9f685693f789a017c7bb7e">lbm_event_queue_shutdown</a> (lbm_event_queue_t *evq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shutdown the event queue by purging any pending events and not allowing additional events to be added to the queue.  <a href="#d94310754a9f685693f789a017c7bb7e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#189f4c0178374d488acacf592c3015e4">lbm_event_queue_delete</a> (lbm_event_queue_t *evq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a given UM event queue object.  <a href="#189f4c0178374d488acacf592c3015e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#497d77b133cea1547c3346fcba99872a">lbm_unicast_immediate_message</a> (lbm_context_t *ctx, const char *target, const char *topic, const char *data, size_t len, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unicast an immediate message to the target and topic. Note that immediate messages are processed somewhat less efficiently than source-based messages.  <a href="#497d77b133cea1547c3346fcba99872a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#e011c7a66e1db1f012d7f9633dbd321d">lbm_unicast_immediate_request</a> (lbm_request_t **reqp, lbm_context_t *ctx, const char *target, const char *topic, const char *data, size_t len, <a class="el" href="lbm_8h.html#f3ef4385bc929e8a7ff94acbeb1eef75">lbm_request_cb_proc</a> proc, void *clientd, lbm_event_queue_t *evq, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unicast an immediate request to the target and topic. Note that immediate messages are processed somewhat less efficiently than source-based messages.  <a href="#e011c7a66e1db1f012d7f9633dbd321d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#21cb52dc4c0a14484cfc0454a156e2d8">lbm_queue_immediate_message</a> (lbm_context_t *ctx, const char *qname, const char *topic, const char *data, size_t len, int flags, <a class="el" href="structlbm__src__send__ex__info__t__stct.html">lbm_src_send_ex_info_t</a> *info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Submit a message to a given UMQ queue and to a given topic. Note that immediate messages are processed somewhat less efficiently than source-based messages.  <a href="#21cb52dc4c0a14484cfc0454a156e2d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#24e5bff3a70e571bb12024af67b47cbb">lbm_multicast_immediate_message</a> (lbm_context_t *ctx, const char *topic, const char *data, size_t len, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multicast an immediate message to the topic. Note that immediate messages are processed somewhat less efficiently than source-based messages.  <a href="#24e5bff3a70e571bb12024af67b47cbb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#54f3933e4dd154a9c7bb72598d0d9ef1">lbm_multicast_immediate_request</a> (lbm_request_t **reqp, lbm_context_t *ctx, const char *topic, const char *data, size_t len, <a class="el" href="lbm_8h.html#f3ef4385bc929e8a7ff94acbeb1eef75">lbm_request_cb_proc</a> proc, void *clientd, lbm_event_queue_t *evq, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multicast an immediate request to the target and topic. Note that immediate messages are processed somewhat less efficiently than source-based messages.  <a href="#54f3933e4dd154a9c7bb72598d0d9ef1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6c001aad4eaf7f3d34452cb074a284c7">lbm_wildcard_rcv_dump</a> (lbm_wildcard_rcv_t *wrcv, int *size, lbm_config_option_t *opts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves all wildcard receiver attribute options.  <a href="#6c001aad4eaf7f3d34452cb074a284c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#98dc9a9c6e5bfcf72222754f5179298d">lbm_wildcard_rcv_attr_dump</a> (lbm_wildcard_rcv_attr_t *wattr, int *size, lbm_config_option_t *opts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves all wildcard receiver attribute options.  <a href="#98dc9a9c6e5bfcf72222754f5179298d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#539c15ba728b1152c696da194afe16ae">lbm_wildcard_rcv_attr_option_size</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of options that are of type "wildcard receiver".  <a href="#539c15ba728b1152c696da194afe16ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#504d418c5f1ad66627eb55ba0f937110">lbm_wildcard_rcv_attr_create</a> (lbm_wildcard_rcv_attr_t **attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and fill a UM wildcard receiver attribute object with the current default values.  <a href="#504d418c5f1ad66627eb55ba0f937110"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#5ebb6c37e8e27a5338bc786f10c05007">lbm_wildcard_rcv_attr_create_default</a> (lbm_wildcard_rcv_attr_t **attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and fill a UM wildcard receiver attribute object with the initial default values.  <a href="#5ebb6c37e8e27a5338bc786f10c05007"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#12eccde60884c35ac72b772be2aea747">lbm_wildcard_rcv_attr_create_from_xml</a> (lbm_wildcard_rcv_attr_t **attr, const char *context_name, const char *pattern, int pattern_type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and fill a UM wildcard receiver attribute object with the current default values for the given topic name.  <a href="#12eccde60884c35ac72b772be2aea747"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#aa43df07f2e39d91832882d7569d4e85">lbm_wildcard_rcv_attr_set_from_xml</a> (lbm_wildcard_rcv_attr_t *attr, const char *context_name, const char *pattern, int pattern_type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill a UM wildcard receiver attribute object with the current default values for the given topic name.  <a href="#aa43df07f2e39d91832882d7569d4e85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#e9ec474237895a81cf15a4e14619cd25">lbm_wildcard_rcv_attr_delete</a> (lbm_wildcard_rcv_attr_t *attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a wildcard receiver attribute object.  <a href="#e9ec474237895a81cf15a4e14619cd25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#87d4a547903b1743bbc29ea52b3f02ac">lbm_wildcard_rcv_attr_dup</a> (lbm_wildcard_rcv_attr_t **attr, const lbm_wildcard_rcv_attr_t *original)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Duplicate a UM wildcard receiver attribute object.  <a href="#87d4a547903b1743bbc29ea52b3f02ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#cec52fdb461e1f903b319e086d1d3e10">lbm_wildcard_rcv_attr_setopt</a> (lbm_wildcard_rcv_attr_t *attr, const char *optname, const void *optval, size_t optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option value within the given wildcard receiver attribute.  <a href="#cec52fdb461e1f903b319e086d1d3e10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#cee962d050b7c17a8e92445612d7b404">lbm_wildcard_rcv_attr_str_setopt</a> (lbm_wildcard_rcv_attr_t *attr, const char *optname, const char *optval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option value within the given wildcard receiver attribute.  <a href="#cee962d050b7c17a8e92445612d7b404"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#052576cc5bc1e5a96b2ba3d55a8639d8">lbm_wildcard_rcv_attr_getopt</a> (lbm_wildcard_rcv_attr_t *attr, const char *optname, void *optval, size_t *optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve an option value within the given wildcard receiver attribute.  <a href="#052576cc5bc1e5a96b2ba3d55a8639d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#0052519211be0078a9849a86aa574653">lbm_wildcard_rcv_attr_str_getopt</a> (lbm_wildcard_rcv_attr_t *attr, const char *optname, char *optval, size_t *optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a textual option value within the given wildcard receiver attribute.  <a href="#0052519211be0078a9849a86aa574653"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c68364b121e54fc8a6a36913be675635">lbm_wildcard_rcv_setopt</a> (lbm_wildcard_rcv_t *wrcv, const char *optname, const void *optval, size_t optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option value within the given <em>wrcv</em>.  <a href="#c68364b121e54fc8a6a36913be675635"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#85a97cc687ae23b2fbeb2a8b4701c6f2">lbm_wildcard_rcv_str_setopt</a> (lbm_wildcard_rcv_t *wrcv, const char *optname, const char *optval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option value within the given <em>wrcv</em>.  <a href="#85a97cc687ae23b2fbeb2a8b4701c6f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#3ffc7329dec32e4717bdbf0464f0ae25">lbm_wildcard_rcv_getopt</a> (lbm_wildcard_rcv_t *wrcv, const char *optname, void *optval, size_t *optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve an option value within the given <em>wrcv</em>.  <a href="#3ffc7329dec32e4717bdbf0464f0ae25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#db0853daf5d471dcf32ffed6cf7932f9">lbm_wildcard_rcv_str_getopt</a> (lbm_wildcard_rcv_t *wrcv, const char *optname, char *optval, size_t *optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the textual option value within the given <em>wrcv</em>.  <a href="#db0853daf5d471dcf32ffed6cf7932f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#5b5d52f6b87499213757b73b09bc8160">lbm_wildcard_rcv_create</a> (lbm_wildcard_rcv_t **wrcvp, lbm_context_t *ctx, const char *pattern, const lbm_rcv_topic_attr_t *tattr, const lbm_wildcard_rcv_attr_t *wattr, <a class="el" href="lbm_8h.html#e2d650dd4830971ca0b6197298eddcdd">lbm_rcv_cb_proc</a> proc, void *clientd, lbm_event_queue_t *evq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a UM wildcard receiver that will receive messages sent to any topic matching the given pattern. Note that if wildcard queries are enabled, LBM will query a maximum of 250 patterns (receivers).  <a href="#5b5d52f6b87499213757b73b09bc8160"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#64407f3874012efaebcba322ea6d229d">lbm_wildcard_rcv_delete</a> (lbm_wildcard_rcv_t *wrcv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a UM wildcard receiver object.  <a href="#64407f3874012efaebcba322ea6d229d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#154f64dd4a7027866cff1dd24e6014b9">lbm_wildcard_rcv_delete_ex</a> (lbm_wildcard_rcv_t *wrcv, <a class="el" href="structlbm__event__queue__cancel__cb__info__t__stct.html">lbm_event_queue_cancel_cb_info_t</a> *cbinfo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extended delete a UM wildcard receiver object.  <a href="#154f64dd4a7027866cff1dd24e6014b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL lbm_context_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#924008a73d7ee244027443e1d9ac5cd6">lbm_context_from_wildcard_rcv</a> (lbm_wildcard_rcv_t *wcrcv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the LBM context object associated with a UM wildcard receiver object.  <a href="#924008a73d7ee244027443e1d9ac5cd6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL lbm_event_queue_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#2814e8e961a67478e5f06469250df922">lbm_event_queue_from_wildcard_rcv</a> (lbm_wildcard_rcv_t *wcrcv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the LBM event queue object associated with a UM wildcard receiver object.  <a href="#2814e8e961a67478e5f06469250df922"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b5f6226d21dd4294bbad7d9f3e7c0bf6">lbm_hf_src_create</a> (lbm_src_t **srcp, lbm_context_t *ctx, lbm_topic_t *topic, <a class="el" href="lbm_8h.html#7503c005ce424fa049494e37b708d396">lbm_src_cb_proc</a> proc, void *clientd, lbm_event_queue_t *evq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a UM Hot Failover (HF) source that will send messages to the given <em>topic</em>. See <a href="https://communities.informatica.com/infakb/faq/5/Pages/80060.aspx">https://communities.informatica.com/infakb/faq/5/Pages/80060.aspx</a> for details and restrictions.  <a href="#b5f6226d21dd4294bbad7d9f3e7c0bf6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#eff48e558306b4bd869af2d99dcf5f4c">lbm_hf_src_send</a> (lbm_src_t *src, const char *msg, size_t len, lbm_uint_t sqn, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a Hot Failover (HF) message to the topic associated with a UM source. See <a href="https://communities.informatica.com/infakb/faq/5/Pages/80060.aspx">https://communities.informatica.com/infakb/faq/5/Pages/80060.aspx</a> for details and restrictions.  <a href="#eff48e558306b4bd869af2d99dcf5f4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c515c1425d9b3f04f1e2cea5d66d3005">lbm_hf_src_send_ex</a> (lbm_src_t *src, const char *msg, size_t len, lbm_uint_t sqn, int flags, <a class="el" href="structlbm__src__send__ex__info__t__stct.html">lbm_src_send_ex_info_t</a> *exinfo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a Hot Failover (HF) message to the topic associated with a UM source. See <a href="https://communities.informatica.com/infakb/faq/5/Pages/80060.aspx">https://communities.informatica.com/infakb/faq/5/Pages/80060.aspx</a> for details and restrictions.  <a href="#c515c1425d9b3f04f1e2cea5d66d3005"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#713c05423f7bf1767a29727c07aa4447">lbm_hf_src_sendv</a> (lbm_src_t *src, const <a class="el" href="structlbm__iovec__t__stct.html">lbm_iovec_t</a> *iov, int num, lbm_uint_t sqn, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a set of Hot Failover (HF) messages to the topic associated with a UM source. See <a href="https://communities.informatica.com/infakb/faq/5/Pages/80060.aspx">https://communities.informatica.com/infakb/faq/5/Pages/80060.aspx</a> for details and restrictions.  <a href="#713c05423f7bf1767a29727c07aa4447"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#456ac9ab0b0d12107be75d3839522ecf">lbm_hf_rcv_topic_dump</a> (lbm_hf_rcv_t *hfrcv, int *size, lbm_config_option_t *opts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves all receiver attribute options for an HF receiver.  <a href="#456ac9ab0b0d12107be75d3839522ecf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#cb6f42a8811cb998b4b19748b190f39b">lbm_hf_src_sendv_ex</a> (lbm_src_t *src, const <a class="el" href="structlbm__iovec__t__stct.html">lbm_iovec_t</a> *iov, int num, lbm_uint_t sqn, int flags, <a class="el" href="structlbm__src__send__ex__info__t__stct.html">lbm_src_send_ex_info_t</a> *exinfo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extended send of a set of Hot Failover (HF) messages to the topic associated with a UM source.  <a href="#cb6f42a8811cb998b4b19748b190f39b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#9f7ed3785938fcfd4771965d6430c4f2">lbm_hf_src_send_rcv_reset</a> (lbm_src_t *src, int flags, <a class="el" href="structlbm__src__send__ex__info__t__stct.html">lbm_src_send_ex_info_t</a> *exinfo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a message that will reset order and loss information for hot failover receivers on this topic.  <a href="#9f7ed3785938fcfd4771965d6430c4f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c208c246a6e856e24e1130060e1806c3">lbm_hf_rcv_create</a> (lbm_hf_rcv_t **hfrcvp, lbm_context_t *ctx, lbm_topic_t *topic, <a class="el" href="lbm_8h.html#e2d650dd4830971ca0b6197298eddcdd">lbm_rcv_cb_proc</a> proc, void *clientd, lbm_event_queue_t *evq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and LBM receiver that will receive LBM Hot Failover (HF) messages sent to the given <em>topic</em>. See <a href="https://communities.informatica.com/infakb/faq/5/Pages/80060.aspx">https://communities.informatica.com/infakb/faq/5/Pages/80060.aspx</a> for details and restrictions.  <a href="#c208c246a6e856e24e1130060e1806c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#bc68152bcf4d18ef1d31d8f6a15ac080">lbm_hf_rcv_delete</a> (lbm_hf_rcv_t *hfrcv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a UM Hot Failover (HF) receiver object. See <a href="https://communities.informatica.com/infakb/faq/5/Pages/80060.aspx">https://communities.informatica.com/infakb/faq/5/Pages/80060.aspx</a> for details and restrictions.  <a href="#bc68152bcf4d18ef1d31d8f6a15ac080"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#755bd1ee0a12622098b618cef46d254f">lbm_hf_rcv_delete_ex</a> (lbm_hf_rcv_t *hfrcv, <a class="el" href="structlbm__event__queue__cancel__cb__info__t__stct.html">lbm_event_queue_cancel_cb_info_t</a> *cbinfo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extended delete a UM Hot Failover (HF) receiver object. See <a href="https://communities.informatica.com/infakb/faq/5/Pages/80060.aspx">https://communities.informatica.com/infakb/faq/5/Pages/80060.aspx</a> for details and restrictions.  <a href="#755bd1ee0a12622098b618cef46d254f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL lbm_hf_rcv_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#87b75906aec93c267cf526e40ef5be71">lbm_hf_rcv_from_rcv</a> (lbm_rcv_t *rcv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the LBM Hot Failover (HF) receiver object (if any) from a UM receiver object.  <a href="#87b75906aec93c267cf526e40ef5be71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL lbm_rcv_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#db7c9dc08d4917ecdbea534c121fdb28">lbm_rcv_from_hf_rcv</a> (lbm_hf_rcv_t *hfrcv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the LBM receiver object associated with a UM Hot Failover (HF) receiver object.  <a href="#db7c9dc08d4917ecdbea534c121fdb28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#7d949468af1c01bb9198154b4891ed19">lbm_hfx_dump</a> (lbm_hfx_t *hfx, int *size, lbm_config_option_t *opts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves all HFX attribute options.  <a href="#7d949468af1c01bb9198154b4891ed19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a2d03b7f229f00e15fd0de8bcde812e4">lbm_hfx_attr_dump</a> (lbm_hfx_attr_t *attr, int *size, lbm_config_option_t *opts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves all HFX attribute options.  <a href="#a2d03b7f229f00e15fd0de8bcde812e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#9c34470a88469310e77cd90314f9f42c">lbm_hfx_attr_option_size</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of options that are of type "hfx". The function returns the number of entries that are of type "hfx".  <a href="#9c34470a88469310e77cd90314f9f42c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#0e904e14d61eee45af197c17f7e3dc08">lbm_hfx_attr_create</a> (lbm_hfx_attr_t **attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and fill a UM HFX attribute object with the current default values.  <a href="#0e904e14d61eee45af197c17f7e3dc08"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f2d3f43eacfbae9045b1ddad32aadc35">lbm_hfx_attr_create_default</a> (lbm_hfx_attr_t **attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and fill a UM HFX attribute object with the initial default values.  <a href="#f2d3f43eacfbae9045b1ddad32aadc35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#abc739544b1a28481e9b4bc51bb49705">lbm_hfx_attr_create_from_xml</a> (lbm_hfx_attr_t **attr, const char *topicname)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and fill a UM hfx attribute object with the current default values for the given topic name.  <a href="#abc739544b1a28481e9b4bc51bb49705"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#2b9f7629e9b17a14d3189b4c42bb7e4f">lbm_hfx_attr_set_from_xml</a> (lbm_hfx_attr_t *attr, const char *topicname)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill a UM hfx attribute object with the current default values for the given topic name.  <a href="#2b9f7629e9b17a14d3189b4c42bb7e4f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ca9ea90e0eba56105bac459d9a1f1887">lbm_hfx_attr_delete</a> (lbm_hfx_attr_t *attr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a UM hfx attribute object.  <a href="#ca9ea90e0eba56105bac459d9a1f1887"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c4cf1936d4930ef818760983795e74ed">lbm_hfx_attr_dup</a> (lbm_hfx_attr_t **attr, const lbm_hfx_attr_t *original)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Duplicate a UM hfx attribute object.  <a href="#c4cf1936d4930ef818760983795e74ed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#9bb4203d659a9d87ee736fb800b40294">lbm_hfx_attr_setopt</a> (lbm_hfx_attr_t *attr, const char *optname, const void *optval, size_t optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option for the given LBM hfx attribute.  <a href="#9bb4203d659a9d87ee736fb800b40294"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#efb36e1505005ef7c9b32904bf85a817">lbm_hfx_attr_str_setopt</a> (lbm_hfx_attr_t *attr, const char *optname, const char *optval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option for the given LBM hfx attribute using a string.  <a href="#efb36e1505005ef7c9b32904bf85a817"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ba74867edbabed89d7890ed84d3c7d38">lbm_hfx_attr_getopt</a> (lbm_hfx_attr_t *attr, const char *optname, void *optval, size_t *optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the value of an option for the given LBM hfx attribute.  <a href="#ba74867edbabed89d7890ed84d3c7d38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ddb7392c84f3fab0bc45d716b9721e5a">lbm_hfx_attr_str_getopt</a> (lbm_hfx_attr_t *attr, const char *optname, char *optval, size_t *optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the textual value of an option for the given LBM hfx attribute.  <a href="#ddb7392c84f3fab0bc45d716b9721e5a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b3b823b82e06584896f1cd89ae141e73">lbm_hfx_setopt</a> (lbm_hfx_t *hfx, const char *optname, const void *optval, size_t optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option value within the given <em>hfx</em>.  <a href="#b3b823b82e06584896f1cd89ae141e73"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6402e914f77ff8caac64d6ff7bf62831">lbm_hfx_str_setopt</a> (lbm_hfx_t *hfx, const char *optname, const char *optval)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option value within the given <em>hfx</em>.  <a href="#6402e914f77ff8caac64d6ff7bf62831"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#85ba681460754ea1643b1d08ef1a2c22">lbm_hfx_getopt</a> (lbm_hfx_t *hfx, const char *optname, void *optval, size_t *optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve an option value within the given <em>hfx</em>.  <a href="#85ba681460754ea1643b1d08ef1a2c22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#12d43eae4a50cb9e899162c50ff0c25b">lbm_hfx_str_getopt</a> (lbm_hfx_t *hfx, const char *optname, char *optval, size_t *optlen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the textual option value within the given <em>hfx</em>.  <a href="#12d43eae4a50cb9e899162c50ff0c25b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#82e9efbf70242d83ab287916ac497645">lbm_hfx_create</a> (lbm_hfx_t **hfxp, lbm_hfx_attr_t *cattr, const char *symbol, <a class="el" href="lbm_8h.html#e2d650dd4830971ca0b6197298eddcdd">lbm_rcv_cb_proc</a> proc, lbm_event_queue_t *evq)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and initialize an lbm_hfx_t object.  <a href="#82e9efbf70242d83ab287916ac497645"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#bc9924a0bd826db0c45a42d7199030b1">lbm_hfx_delete</a> (lbm_hfx_t *hfx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a UM hfx object.  <a href="#bc9924a0bd826db0c45a42d7199030b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#3b091cdffac78f4d1fff38e79c0cd410">lbm_hfx_delete_ex</a> (lbm_hfx_t *hfx, <a class="el" href="structlbm__event__queue__cancel__cb__info__t__stct.html">lbm_event_queue_cancel_cb_info_t</a> *cbinfo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete an LBM hfx object and receive a callback when the deletion is complete. Delete an LBM HFX object, with an application callback indicating when the object is fully cancelled. This extended version of the delete function requires the configuration option queue_cancellation_callbacks_enabled to be set to 1 if an event queue is in use. Unlike.  <a href="#3b091cdffac78f4d1fff38e79c0cd410"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ac61570f29d9cd95c42e9bd5e41e0efa">lbm_hfx_rcv_topic_dump</a> (lbm_hfx_rcv_t *hfxrcv, int *size, lbm_config_option_t *opts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves all receiver attribute options for an HFX receiver.  <a href="#ac61570f29d9cd95c42e9bd5e41e0efa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#e717b7b9923a6e4277ae9f7409983ffc">lbm_hfx_rcv_create</a> (lbm_hfx_rcv_t **hfrcvp, lbm_hfx_t *hfx, lbm_context_t *ctx, lbm_rcv_topic_attr_t *rattr, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a HFX receiver.  <a href="#e717b7b9923a6e4277ae9f7409983ffc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL lbm_rcv_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#dd57a97595ac9b23dd456fb7a67f728f">lbm_rcv_from_hfx_rcv</a> (lbm_hfx_rcv_t *hfxrcv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the underlying receiver from an lbm_hfx_rcv_t.  <a href="#dd57a97595ac9b23dd456fb7a67f728f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#096626db73533d6c39b22765014485b7">lbm_hfx_rcv_delete</a> (lbm_hfx_rcv_t *hfrcv)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a HFX receiver.  <a href="#096626db73533d6c39b22765014485b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#08d8cbd7f47af1d7b2199c85ecf7c44c">lbm_hfx_rcv_delete_ex</a> (lbm_hfx_rcv_t *hfrcv, <a class="el" href="structlbm__event__queue__cancel__cb__info__t__stct.html">lbm_event_queue_cancel_cb_info_t</a> *cbinfo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extended delete a UM HFX receiver object.  <a href="#08d8cbd7f47af1d7b2199c85ecf7c44c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#0bd19501e6a545a2e5ec555ff257288a">lbm_debug_filename</a> (const char *filename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the file to receive LBM debug log entries.  <a href="#0bd19501e6a545a2e5ec555ff257288a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#712771b8dcd34466c83bc63fa4186371">lbm_debug_mask</a> (lbm_uint64_t mask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the debug mask for LBM debug log entries.  <a href="#712771b8dcd34466c83bc63fa4186371"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="343aabeac69a5bcf05f130d373ce2159"></a><!-- doxytag: member="lbm.h::lbm_debug_noflush" ref="343aabeac69a5bcf05f130d373ce2159" args="(int on)" -->
LBMExpDLL void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#343aabeac69a5bcf05f130d373ce2159">lbm_debug_noflush</a> (int on)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the noflush flag for the debug logs. This can dramatically increase performance when a debug mask is set. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#fa8497a41108dc0ea2ba233db4636aca">lbm_debug_dump</a> (const char *filename, int append)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dump a running rollback debug log to the given filename.  <a href="#fa8497a41108dc0ea2ba233db4636aca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c00b82eb9ab67d4069cc99d94e4b256d">lbm_set_lbtrm_loss_rate</a> (int rate)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dynamically set the LBT-RM loss rate.  <a href="#c00b82eb9ab67d4069cc99d94e4b256d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#e8cce89fbfdc2bd60065dd9ec2d45027">lbm_set_lbtrm_src_loss_rate</a> (int rate)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dynamically set the LBT-RM source loss rate.  <a href="#e8cce89fbfdc2bd60065dd9ec2d45027"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6f3c10e8d065ac051b098326c836c2f4">lbm_set_lbtru_loss_rate</a> (int rate)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dynamically set the LBT-RU loss rate.  <a href="#6f3c10e8d065ac051b098326c836c2f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#bf742a93fe06c320e35ab636352bed66">lbm_set_lbtru_src_loss_rate</a> (int rate)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dynamically set the LBT-RU source loss rate.  <a href="#bf742a93fe06c320e35ab636352bed66"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#30bf33dce2021f6ea8915b45f511af56">lbm_transport_source_parse</a> (const char *source, <a class="el" href="structlbm__transport__source__info__t__stct.html">lbm_transport_source_info_t</a> *info, size_t infosize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parse a UM transport source string into its components.  <a href="#30bf33dce2021f6ea8915b45f511af56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#fa35ad2c7d5d473ffeda6727022f9b94">lbm_transport_source_format</a> (const <a class="el" href="structlbm__transport__source__info__t__stct.html">lbm_transport_source_info_t</a> *info, size_t infosize, char *source, size_t *size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Format a UM transport source string from its components.  <a href="#fa35ad2c7d5d473ffeda6727022f9b94"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#40a3fe706dc6cf4a6bd23ebe721ce636">lbm_apphdr_chain_create</a> (lbm_apphdr_chain_t **chain)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new app header chain that can be used to include metadata with a message.  <a href="#40a3fe706dc6cf4a6bd23ebe721ce636"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#4f468c363d3d1735507be95fe4638d09">lbm_apphdr_chain_delete</a> (lbm_apphdr_chain_t *chain)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete an app header chain previously created with lbm_apphdr_chain_create.  <a href="#4f468c363d3d1735507be95fe4638d09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f12d7293287405db2b965aacbb2a2b4d">lbm_apphdr_chain_append_elem</a> (lbm_apphdr_chain_t *chain, <a class="el" href="structlbm__apphdr__chain__elem__t__stct.html">lbm_apphdr_chain_elem_t</a> *elem)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Appends a user-created app header to an app header chain.  <a href="#f12d7293287405db2b965aacbb2a2b4d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a3b027a74322c1683e68ea86207b187f">lbm_apphdr_chain_iter_create</a> (lbm_apphdr_chain_iter_t **chain_iter, lbm_apphdr_chain_t *chain)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an iterator (an lbm_apphdr_chain_iter_t structure) to point to the first element in an apphdr chain.  <a href="#a3b027a74322c1683e68ea86207b187f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#316dcfdb28460ee670cc6399d6d94b9f">lbm_apphdr_chain_iter_create_from_msg</a> (lbm_apphdr_chain_iter_t **chain_iter, <a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an iterator (an lbm_apphdr_chain_iter_t structure) to point to the first element in an apphdr chain associated with a UM message.  <a href="#316dcfdb28460ee670cc6399d6d94b9f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#2fe460bfd35bf3d9f492dae02a08e77c">lbm_apphdr_chain_iter_delete</a> (lbm_apphdr_chain_iter_t *chain_iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete an iterator allocated by one of the lbm_apphdr_chain_iter functions.  <a href="#2fe460bfd35bf3d9f492dae02a08e77c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a4c079a614ffd5b547b30047749585e9">lbm_apphdr_chain_iter_first</a> (lbm_apphdr_chain_iter_t **chain_iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes an app header chain iterator to the first element in the chain.  <a href="#a4c079a614ffd5b547b30047749585e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#b04ca3bf4fee83b3f97bc0c1586f880a">lbm_apphdr_chain_iter_done</a> (lbm_apphdr_chain_iter_t **chain_iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests an lbm_apphdr_chain_iter_t iterator to see if more elements in the chain remain.  <a href="#b04ca3bf4fee83b3f97bc0c1586f880a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6729d5b35c12874bc82be08ce708339a">lbm_apphdr_chain_iter_next</a> (lbm_apphdr_chain_iter_t **chain_iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Advances the iterator to the next element in an app header chain, if any.  <a href="#6729d5b35c12874bc82be08ce708339a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL <a class="el" href="structlbm__apphdr__chain__elem__t__stct.html">lbm_apphdr_chain_elem_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#db432d65e72c04a7d5866bed9961e673">lbm_apphdr_chain_iter_current</a> (lbm_apphdr_chain_iter_t **chain_iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current element of an app header chain pointed to by an lbm_apphdr_chain_iter_t iterator.  <a href="#db432d65e72c04a7d5866bed9961e673"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#bda1a4224f1c3e94b10b74051be3dd53">lbm_msg_properties_create</a> (lbm_msg_properties_t **properties)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new properties object, used for sending messages with properties.  <a href="#bda1a4224f1c3e94b10b74051be3dd53"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#80152f12d64394821a61287e99c5db33">lbm_msg_properties_delete</a> (lbm_msg_properties_t *properties)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes a properties object.  <a href="#80152f12d64394821a61287e99c5db33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#cec18484fc06996fe3b61e76a593d5fb">lbm_msg_properties_set</a> (lbm_msg_properties_t *properties, const char *name, const void *value, int type, size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the value of the property with the specified name. Each property name may be associated with one and only one value.  <a href="#cec18484fc06996fe3b61e76a593d5fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#aea0bf981a9fe47287db442026ca13ca">lbm_msg_properties_clear</a> (lbm_msg_properties_t *properties, const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the value associated with the name in the specified properties object.  <a href="#aea0bf981a9fe47287db442026ca13ca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ac0dc50537a458d2a2ca418a394fd21b">lbm_msg_properties_get</a> (lbm_msg_properties_t *properties, const char *name, void *value, int *type, size_t *size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the value of the property with the specified name.  <a href="#ac0dc50537a458d2a2ca418a394fd21b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#a08b2aa8f00b1b97c6d496834a4432dd">lbm_msg_properties_iter_create</a> (<a class="el" href="structlbm__msg__properties__iter__t__stct.html">lbm_msg_properties_iter_t</a> **iterp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new msg properties iterator. The newly created iterator is not associated with any properties object. Use.  <a href="#a08b2aa8f00b1b97c6d496834a4432dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#79db125bc40762da0b462c70f9e8c4b4">lbm_msg_properties_iter_delete</a> (<a class="el" href="structlbm__msg__properties__iter__t__stct.html">lbm_msg_properties_iter_t</a> *iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes an lbm_msg_properties_iterator.  <a href="#79db125bc40762da0b462c70f9e8c4b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#cfa02c8316e97baeb9894daa991ef1fb">lbm_msg_properties_iter_first</a> (<a class="el" href="structlbm__msg__properties__iter__t__stct.html">lbm_msg_properties_iter_t</a> *iter, lbm_msg_properties_t *properties)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Begin iterating over an.  <a href="#cfa02c8316e97baeb9894daa991ef1fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#2876985a82c92ade238b8196a1ec3da7">lbm_msg_properties_iter_next</a> (<a class="el" href="structlbm__msg__properties__iter__t__stct.html">lbm_msg_properties_iter_t</a> *iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate to the next property in an.  <a href="#2876985a82c92ade238b8196a1ec3da7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#82b9908731d8ac4a77c00afe55f15784">lbm_src_get_inflight</a> (lbm_src_t *src, int type, int *inflight, <a class="el" href="lbm_8h.html#c26b2f61ff3e92ff1e1b44f82bbf193b">lbm_flight_size_set_inflight_cb_proc</a> proc, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the current number of inflight messages of a given type from the src pointed to by lbm_src_t *src.  <a href="#82b9908731d8ac4a77c00afe55f15784"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#93d620242351c5fd60f270030302562d">lbm_src_get_inflight_ex</a> (lbm_src_t *src, int type, <a class="el" href="structlbm__flight__size__inflight__t__stct.html">lbm_flight_size_inflight_t</a> *inflight, <a class="el" href="lbm_8h.html#75319e63d9fa4e0f006918b91672f6b5">lbm_flight_size_set_inflight_ex_cb_proc</a> proc, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the current number of inflight information of a given type from the src pointed to by lbm_src_t *src.  <a href="#93d620242351c5fd60f270030302562d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ac6015a6a8e914c6e621e3b28940fe87">lbm_ctx_umq_get_inflight</a> (lbm_context_t *ctx, const char *qname, int *inflight, <a class="el" href="lbm_8h.html#c26b2f61ff3e92ff1e1b44f82bbf193b">lbm_flight_size_set_inflight_cb_proc</a> proc, void *clientd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the current number of inflight UMQ messages from the ctx pointed to by lbm_context_t *ctx.  <a href="#ac6015a6a8e914c6e621e3b28940fe87"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#0f398a9c65bcb133539b40dacfb5d619">lbm_ume_src_msg_stable</a> (lbm_src_t *src, lbm_uint32_t sqn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mark a specific sqn as stable at a store, triggering a source event notification if configured to do so. Also adjusts the current number of inflight messages for the src if necessary.  <a href="#0f398a9c65bcb133539b40dacfb5d619"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#6cd0c297e489e006ef5da83398184daa">lbm_umq_ctx_msg_stable</a> (lbm_context_t *ctx, const char *qname, <a class="el" href="structlbm__umq__msgid__t__stct.html">lbm_umq_msgid_t</a> *msg_id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mark a specific msg_id as stable at qname, triggering a source event notification if configured to do so. Also adjusts the current number of inflight messages for the src if necessary.  <a href="#6cd0c297e489e006ef5da83398184daa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL lbm_ume_rcv_ack_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#e1b7ca376c99fcbbe6175ad3441b7aeb">lbm_msg_extract_ume_ack</a> (<a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *msg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the ack structure from a UMP message.  <a href="#e1b7ca376c99fcbbe6175ad3441b7aeb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#5c2b4c56240b15dadd9a251989c3180f">lbm_ume_ack_delete</a> (lbm_ume_rcv_ack_t *ack)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes an ack structure.  <a href="#5c2b4c56240b15dadd9a251989c3180f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#2b5aa9394b4911eb8e39768a57d5b49e">lbm_ume_ack_send_explicit_ack</a> (lbm_ume_rcv_ack_t *ack, lbm_uint_t sqn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends an explicit ack up to the sequence number provided.  <a href="#2b5aa9394b4911eb8e39768a57d5b49e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f9a26658b4ad8348f31369f77f9922de">lbm_ctx_umq_queue_topic_list</a> (lbm_context_t *ctx, const char *queue_name, <a class="el" href="structlbm__async__operation__func__t.html">lbm_async_operation_func_t</a> *async_opfunc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a list of currently available topics from a queue (asynchronous operation).  <a href="#f9a26658b4ad8348f31369f77f9922de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#83556cf6d952f5c68c1765ca2b70f126">lbm_umq_msg_selector_create</a> (lbm_umq_msg_selector_t **selector, char *str, lbm_uint16_t len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an umq message selector (an lbm_umq_msg_selector_t structure).  <a href="#83556cf6d952f5c68c1765ca2b70f126"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#9fd1730634c12b16a435ddaa5dd2923c">lbm_umq_msg_selector_delete</a> (lbm_umq_msg_selector_t *selector)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete the lbm_umq_msg_selector_t object previously created with lbm_umq_msg_selector_create.  <a href="#9fd1730634c12b16a435ddaa5dd2923c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f08bf16a7384ce04db3b13382871b814">lbm_rcv_umq_queue_msg_list</a> (lbm_rcv_t *rcv, const char *queue_name, lbm_umq_msg_selector_t *selector, <a class="el" href="structlbm__async__operation__func__t.html">lbm_async_operation_func_t</a> *async_opfunc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a list of all currently-queued messages from a queue (asynchronous operation).  <a href="#f08bf16a7384ce04db3b13382871b814"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#f8222d6585b6077f2b5aba736dc3c8fa">lbm_rcv_umq_queue_msg_retrieve</a> (lbm_rcv_t *rcv, const char *queue_name, <a class="el" href="structlbm__umq__msgid__t__stct.html">lbm_umq_msgid_t</a> *msgids, int num_msgids, <a class="el" href="structlbm__async__operation__func__t.html">lbm_async_operation_func_t</a> *async_opfunc)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a set of queued messages from the queue (asynchronous operation).  <a href="#f8222d6585b6077f2b5aba736dc3c8fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#abec52c36b62aec1fde817444f74698b">lbm_async_operation_status</a> (<a class="el" href="lbm_8h.html#f4ae0671728c6941e2a991ec695d2ebb">lbm_async_operation_handle_t</a> handle, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Query the current status of an oustanding asynchronous operation.  <a href="#abec52c36b62aec1fde817444f74698b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#bec0367ec9851d2bfd64c889a6cffca2">lbm_async_operation_cancel</a> (<a class="el" href="lbm_8h.html#f4ae0671728c6941e2a991ec695d2ebb">lbm_async_operation_handle_t</a> handle, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel an outstanding asynchronous operation.  <a href="#bec0367ec9851d2bfd64c889a6cffca2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#150a4b140b9999c5eba12cf89cc3522c">lbm_auth_set_credentials</a> (lbm_context_t *ctx, const char *name, size_t name_len, const char *passwd, size_t passwd_len, lbm_cred_callback_fn cbfn, void *clientd, int auth_required)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the user's credential and authentication requirement.  <a href="#150a4b140b9999c5eba12cf89cc3522c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ebfd20af929219cffcb2f21e2581b7ba">lbm_authstorage_open_storage_xml</a> (char *filename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create the storage object from XML password file.  <a href="#ebfd20af929219cffcb2f21e2581b7ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c923d58b2b471cffe6ed1d598d48cbc0">lbm_authstorage_close_storage_xml</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release the storage object.  <a href="#c923d58b2b471cffe6ed1d598d48cbc0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ce4921719de7dec82869837ba90441e7">lbm_authstorage_checkpermission</a> (char *username, char *command)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if the user is authorized to execute the specified command.  <a href="#ce4921719de7dec82869837ba90441e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#572ecd55a7c8d3ccd3025cd2e4efed54">lbm_authstorage_addtpnam</a> (const char *username, const char *pass, unsigned char flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add the new user credential to the password file.  <a href="#572ecd55a7c8d3ccd3025cd2e4efed54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#029a239074f0ede982ff3931ce8011ab">lbm_authstorage_deltpnam</a> (const char *username)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete the user credential from the password file.  <a href="#029a239074f0ede982ff3931ce8011ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#238478b2f89bab6884e7f65c741572d0">lbm_authstorage_user_add_role</a> (const char *username, const char *role)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add one role entry for the user to the password file.  <a href="#238478b2f89bab6884e7f65c741572d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#76a9011498d326bc845ca90ccafc6ab8">lbm_authstorage_user_del_role</a> (const char *username, const char *role)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete the role entry for the user from the password file.  <a href="#76a9011498d326bc845ca90ccafc6ab8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#fc8c273ea8be3eadc9ed56861b5ff493">lbm_authstorage_load_roletable</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load the role table from the password file.  <a href="#fc8c273ea8be3eadc9ed56861b5ff493"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#fb8e187295fd6b50e74fe5fdece7a6d3">lbm_authstorage_unload_roletable</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unload the role table.  <a href="#fb8e187295fd6b50e74fe5fdece7a6d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#e02c55b6630ac4d61613120edf9e76b3">lbm_authstorage_roletable_add_role_action</a> (const char *rolename, const char *action)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new authorized action for the specified role.  <a href="#e02c55b6630ac4d61613120edf9e76b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#c105adb81eb1a0642a3551fbe4ac5af4">lbm_authstorage_print_roletable</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print the role table saved in the internal data object.  <a href="#c105adb81eb1a0642a3551fbe4ac5af4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#ab029e3f210b40f3fded64fec2a27a02">lbm_set_umm_info</a> (<a class="el" href="structlbm__umm__info__t__stct.html">lbm_umm_info_t</a> *info)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect to and retrieve configuration from a UMM daemon.  <a href="#ab029e3f210b40f3fded64fec2a27a02"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#0068d9e57d3a0897217405e9a9068e20">lbm_is_ume_capable</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if the LBM library is capable of UME operations.  <a href="#0068d9e57d3a0897217405e9a9068e20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#957e542a9bc1172ab5ce29da151b6d05">lbm_is_umq_capable</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if the LBM library is capable of UMQ operations.  <a href="#957e542a9bc1172ab5ce29da151b6d05"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d007cc33851bd54f8fcbdad8a6a2a976"></a><!-- doxytag: member="lbm.h::lbm_seterr" ref="d007cc33851bd54f8fcbdad8a6a2a976" args="(int eno, const char *str)" -->
LBMExpDLL void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_seterr</b> (int eno, const char *str)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="349415165113e9432ef590960f747782"></a><!-- doxytag: member="lbm.h::lbm_seterrf" ref="349415165113e9432ef590960f747782" args="(int eno, const char *format,...)" -->
LBMExpDLL void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_seterrf</b> (int eno, const char *format,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d525a2b9e4d4f9dfc90a914992da1234"></a><!-- doxytag: member="lbm.h::lbm_strerror" ref="d525a2b9e4d4f9dfc90a914992da1234" args="(void)" -->
LBMExpDLL const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_strerror</b> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4c3fb8918484bdef3488114d2d90562e"></a><!-- doxytag: member="lbm.h::lbm_strerror_errnum" ref="4c3fb8918484bdef3488114d2d90562e" args="(int errnum)" -->
LBMExpDLL const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_strerror_errnum</b> (int errnum)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="96ba44b27dab0c74cd92788272707d22"></a><!-- doxytag: member="lbm.h::lbm_sock_init" ref="96ba44b27dab0c74cd92788272707d22" args="()" -->
LBMExpDLL void&nbsp;</td><td class="memItemRight" valign="bottom"><b>lbm_sock_init</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL lbm_uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#46908e2e0546293b0ae217d12f007751">lbm_create_random_id</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a random id to be used in conjunction with lbm_get_jms_msg_id for JMS compatibilty.  <a href="#46908e2e0546293b0ae217d12f007751"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LBMExpDLL char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lbm_8h.html#4e9c820cb8d8c126c3b86d885e09cc29">lbm_get_jms_msg_id</a> (lbm_uint64_t source_id, lbm_uint64_t seqno_id, char *topic)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create JMS message ID.  <a href="#4e9c820cb8d8c126c3b86d885e09cc29"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<dl class="author" compact><dt><b>Author:</b></dt><dd>Todd L. Montgomery - Informatica Corporation. </dd></dl>
<dl class="version" compact><dt><b>Version:</b></dt><dd><dl class="rcs" compact><dt><b>Id</b></dt><dd>//UMprod/REL_5_3_6/29West/lbm/src/lib/lbm/lbm.h#2 </dd></dl>
</dd></dl>
The Ultra Messaging (UM) API Description. Included are types, constants, and functions related to the API. Contents are subject to change.<p>
All of the documentation and software included in this and any other Informatica Ultra Messaging Releases Copyright (C) Informatica. All rights reserved.<p>
Redistribution and use in source and binary forms, with or without modification, are permitted only as covered by the terms of a valid software license agreement with Informatica.<p>
Copyright (C) 2004-2014, Informatica Corporation. All Rights Reserved.<p>
THE SOFTWARE IS PROVIDED "AS IS" AND INFORMATICA DISCLAIMS ALL WARRANTIES EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. INFORMATICA DOES NOT WARRANT THAT USE OF THE SOFTWARE WILL BE UNINTERRUPTED OR ERROR-FREE. INFORMATICA SHALL NOT, UNDER ANY CIRCUMSTANCES, BE LIABLE TO LICENSEE FOR LOST PROFITS, CONSEQUENTIAL, INCIDENTAL, SPECIAL OR INDIRECT DAMAGES ARISING OUT OF OR RELATED TO THIS AGREEMENT OR THE TRANSACTIONS CONTEMPLATED HEREUNDER, EVEN IF INFORMATICA HAS BEEN APPRISED OF THE LIKELIHOOD OF SUCH DAMAGES. <hr><h2>Define Documentation</h2>
<a class="anchor" name="1a656fc626c82c157958ca130e40f736"></a><!-- doxytag: member="lbm.h::LBM_ASYNC_OP_INFO_FLAG_FIRST" ref="1a656fc626c82c157958ca130e40f736" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_ASYNC_OP_INFO_FLAG_FIRST&nbsp;&nbsp;&nbsp;0x2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="structlbm__async__operation__info__t.html" title="Results struct returned via the user-specified asynchronous operation callback from...">lbm_async_operation_info_t</a> flag. This is the very first notification for this particular asynchronous operation. 
</div>
</div><p>
<a class="anchor" name="246de64eb8052dcaebe8e2df5c746c81"></a><!-- doxytag: member="lbm.h::LBM_ASYNC_OP_INFO_FLAG_INLINE" ref="246de64eb8052dcaebe8e2df5c746c81" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_ASYNC_OP_INFO_FLAG_INLINE&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="structlbm__async__operation__info__t.html" title="Results struct returned via the user-specified asynchronous operation callback from...">lbm_async_operation_info_t</a> flag. Asynchronous operation callback is being called directly inline from within an API call. 
</div>
</div><p>
<a class="anchor" name="55ea28122623c30d172e1530b00c1161"></a><!-- doxytag: member="lbm.h::LBM_ASYNC_OP_INFO_FLAG_LAST" ref="55ea28122623c30d172e1530b00c1161" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_ASYNC_OP_INFO_FLAG_LAST&nbsp;&nbsp;&nbsp;0x4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="structlbm__async__operation__info__t.html" title="Results struct returned via the user-specified asynchronous operation callback from...">lbm_async_operation_info_t</a> flag. This is the very last notification for this particular asynchronous operation. 
</div>
</div><p>
<a class="anchor" name="ef236f453e8dea50ddc88a3111ba692b"></a><!-- doxytag: member="lbm.h::LBM_ASYNC_OP_INFO_FLAG_ONLY" ref="ef236f453e8dea50ddc88a3111ba692b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_ASYNC_OP_INFO_FLAG_ONLY&nbsp;&nbsp;&nbsp;(LBM_ASYNC_OP_INFO_FLAG_FIRST | LBM_ASYNC_OP_INFO_FLAG_LAST)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="structlbm__async__operation__info__t.html" title="Results struct returned via the user-specified asynchronous operation callback from...">lbm_async_operation_info_t</a> flag. This is the only notification that will be delivered for this particular asynchronous operation. 
</div>
</div><p>
<a class="anchor" name="29916ecc9d06a54da09566123fabe253"></a><!-- doxytag: member="lbm.h::LBM_ASYNC_OP_INVALID_HANDLE" ref="29916ecc9d06a54da09566123fabe253" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_ASYNC_OP_INVALID_HANDLE&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invalid asynchronous operation handle. 
</div>
</div><p>
<a class="anchor" name="0e5bcc04f0c21960959f728dea59aeac"></a><!-- doxytag: member="lbm.h::LBM_ASYNC_OP_STATUS_CANCELED" ref="0e5bcc04f0c21960959f728dea59aeac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_ASYNC_OP_STATUS_CANCELED&nbsp;&nbsp;&nbsp;130          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asynchronous operation status code. Overall operation has been successfully canceled. This is a terminal status code. 
</div>
</div><p>
<a class="anchor" name="d44e943d8314ce64e5b9e9183c1daad7"></a><!-- doxytag: member="lbm.h::LBM_ASYNC_OP_STATUS_COMPLETE" ref="d44e943d8314ce64e5b9e9183c1daad7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_ASYNC_OP_STATUS_COMPLETE&nbsp;&nbsp;&nbsp;128          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asynchronous operation status code. Overall operation has completed successfully. This is a terminal status code. 
</div>
</div><p>
<a class="anchor" name="d4076e6e838f9f8da91cc7f47526af83"></a><!-- doxytag: member="lbm.h::LBM_ASYNC_OP_STATUS_ERROR" ref="d4076e6e838f9f8da91cc7f47526af83" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_ASYNC_OP_STATUS_ERROR&nbsp;&nbsp;&nbsp;129          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asynchronous operation status code. Overall operation has failed. This is a terminal status code. 
</div>
</div><p>
<a class="anchor" name="386dfee7ceddf177eb333f21f85b755d"></a><!-- doxytag: member="lbm.h::LBM_ASYNC_OP_STATUS_IN_PROGRESS" ref="386dfee7ceddf177eb333f21f85b755d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_ASYNC_OP_STATUS_IN_PROGRESS&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asynchronous operation status code. Overall operation is still in progress. 
</div>
</div><p>
<a class="anchor" name="d48acd1ecb2e4429b8b0fd7f041c6428"></a><!-- doxytag: member="lbm.h::LBM_ASYNC_OP_TYPE_CTX_UMQ_QUEUE_TOPIC_LIST" ref="d48acd1ecb2e4429b8b0fd7f041c6428" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_ASYNC_OP_TYPE_CTX_UMQ_QUEUE_TOPIC_LIST&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asynchronous operation type. UMQ queue topic list. 
</div>
</div><p>
<a class="anchor" name="080d784d8bd2cb03d396aa6394289343"></a><!-- doxytag: member="lbm.h::LBM_ASYNC_OP_TYPE_RCV_UMQ_QUEUE_MSG_LIST" ref="080d784d8bd2cb03d396aa6394289343" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_ASYNC_OP_TYPE_RCV_UMQ_QUEUE_MSG_LIST&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asynchronous operation type. UMQ queue message list. 
</div>
</div><p>
<a class="anchor" name="ae8a7e90c8ada5ef5e012eb18af8a432"></a><!-- doxytag: member="lbm.h::LBM_ASYNC_OP_TYPE_RCV_UMQ_QUEUE_MSG_RETRIEVE" ref="ae8a7e90c8ada5ef5e012eb18af8a432" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_ASYNC_OP_TYPE_RCV_UMQ_QUEUE_MSG_RETRIEVE&nbsp;&nbsp;&nbsp;3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asynchronous operation type. UMQ queue message retrieve. 
</div>
</div><p>
<a class="anchor" name="86f86ebba51cabc4d9cc18dab73c97b0"></a><!-- doxytag: member="lbm.h::LBM_ASYNC_OPERATION_CANCEL_FLAG_NONBLOCK" ref="86f86ebba51cabc4d9cc18dab73c97b0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_ASYNC_OPERATION_CANCEL_FLAG_NONBLOCK&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_async_operation_cancel flag. Do not block if the operation cannot be immediately canceled. 
</div>
</div><p>
<a class="anchor" name="8a1c382c7c7f649bb31c58b072100d59"></a><!-- doxytag: member="lbm.h::LBM_ASYNC_OPERATION_STATUS_FLAG_NONBLOCK" ref="8a1c382c7c7f649bb31c58b072100d59" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_ASYNC_OPERATION_STATUS_FLAG_NONBLOCK&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_async_operation_status flag. Do not block if the operation's status cannot be retrieved immediately. 
</div>
</div><p>
<a class="anchor" name="eed14db023c1109f428a1801616b01fe"></a><!-- doxytag: member="lbm.h::LBM_CHAIN_ELEM_APPHDR" ref="eed14db023c1109f428a1801616b01fe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_CHAIN_ELEM_APPHDR&nbsp;&nbsp;&nbsp;0x4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Element is a non-chain app header 
</div>
</div><p>
<a class="anchor" name="18bc28f8841c79ad1532e699eb8aa426"></a><!-- doxytag: member="lbm.h::LBM_CHAIN_ELEM_CHANNEL_NUMBER" ref="18bc28f8841c79ad1532e699eb8aa426" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_CHAIN_ELEM_CHANNEL_NUMBER&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Element is a channel number in network byte order 
</div>
</div><p>
<a class="anchor" name="4f25c3373d9f82d7e171df6b8b070801"></a><!-- doxytag: member="lbm.h::LBM_CHAIN_ELEM_GW_INFO" ref="4f25c3373d9f82d7e171df6b8b070801" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_CHAIN_ELEM_GW_INFO&nbsp;&nbsp;&nbsp;0x3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Element is gateway information 
</div>
</div><p>
<a class="anchor" name="683cfc4a78a744afc6a1e55fd3cbe458"></a><!-- doxytag: member="lbm.h::LBM_CHAIN_ELEM_HF_SQN" ref="683cfc4a78a744afc6a1e55fd3cbe458" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_CHAIN_ELEM_HF_SQN&nbsp;&nbsp;&nbsp;0x2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Element is a hot-failover sequence number in network byte order 
</div>
</div><p>
<a class="anchor" name="74bfca22086f34cee6fbe80ae46db358"></a><!-- doxytag: member="lbm.h::LBM_CHAIN_ELEM_PROPERTIES_LENGTH" ref="74bfca22086f34cee6fbe80ae46db358" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_CHAIN_ELEM_PROPERTIES_LENGTH&nbsp;&nbsp;&nbsp;0x6          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Element is the offset of a serialized properties object within an LBM message 
</div>
</div><p>
<a class="anchor" name="37233effa75b0b79c0ad518010a96646"></a><!-- doxytag: member="lbm.h::LBM_CHAIN_ELEM_USER_DATA" ref="37233effa75b0b79c0ad518010a96646" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_CHAIN_ELEM_USER_DATA&nbsp;&nbsp;&nbsp;0x5          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Element is user data with no byte-order transformation applied 
</div>
</div><p>
<a class="anchor" name="ec8f983c8bdc7abdb2d8dae56029acdf"></a><!-- doxytag: member="lbm.h::LBM_CONTEXT_EVENT_UMQ_INSTANCE_LIST_NOTIFICATION" ref="ec8f983c8bdc7abdb2d8dae56029acdf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_CONTEXT_EVENT_UMQ_INSTANCE_LIST_NOTIFICATION&nbsp;&nbsp;&nbsp;4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of context event. For UMQ only, means queue instance list has changed. Event holds information string. 
</div>
</div><p>
<a class="anchor" name="5aa7c61a4613a1e63f75fb481796edd0"></a><!-- doxytag: member="lbm.h::LBM_CONTEXT_EVENT_UMQ_REGISTRATION_COMPLETE_EX" ref="5aa7c61a4613a1e63f75fb481796edd0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_CONTEXT_EVENT_UMQ_REGISTRATION_COMPLETE_EX&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of context event. For UMQ only, means registration of context complete. Event data holds Queue information, Registration ID, etc. 
</div>
</div><p>
<a class="anchor" name="796234c441b154db2f88d433222c8223"></a><!-- doxytag: member="lbm.h::LBM_CONTEXT_EVENT_UMQ_REGISTRATION_COMPLETE_EX_FLAG_QUORUM" ref="796234c441b154db2f88d433222c8223" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_CONTEXT_EVENT_UMQ_REGISTRATION_COMPLETE_EX_FLAG_QUORUM&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registration completed with only quorum reached. 
</div>
</div><p>
<a class="anchor" name="8c24d36b98bf3118143307d2e64182bf"></a><!-- doxytag: member="lbm.h::LBM_CONTEXT_EVENT_UMQ_REGISTRATION_ERROR" ref="8c24d36b98bf3118143307d2e64182bf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_CONTEXT_EVENT_UMQ_REGISTRATION_ERROR&nbsp;&nbsp;&nbsp;3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of context event. For UMQ only, means registration of context failed with an error. Event data holds error string. 
</div>
</div><p>
<a class="anchor" name="027e25776e82d746adb67f3bbd6b95b6"></a><!-- doxytag: member="lbm.h::LBM_CONTEXT_EVENT_UMQ_REGISTRATION_SUCCESS_EX" ref="027e25776e82d746adb67f3bbd6b95b6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_CONTEXT_EVENT_UMQ_REGISTRATION_SUCCESS_EX&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of context event. For UMQ only, means registration of context successful with specific Queue instance. Event data holds Queue instance information, etc. 
</div>
</div><p>
<a class="anchor" name="77bf26d092500ee172a62df43b1a21a8"></a><!-- doxytag: member="lbm.h::LBM_DAEMON_EVENT_CONNECT_ERROR" ref="77bf26d092500ee172a62df43b1a21a8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_DAEMON_EVENT_CONNECT_ERROR&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
UM daemon event. Connected could not complete successfully (info valid) 
</div>
</div><p>
<a class="anchor" name="3aded199e00f5f4f20b6f38fc2d4e179"></a><!-- doxytag: member="lbm.h::LBM_DAEMON_EVENT_CONNECT_TIMEOUT" ref="3aded199e00f5f4f20b6f38fc2d4e179" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_DAEMON_EVENT_CONNECT_TIMEOUT&nbsp;&nbsp;&nbsp;4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
UM daemon event. Connection to daemon timed out 
</div>
</div><p>
<a class="anchor" name="5ce6d6282cc249b1650e61304d02f595"></a><!-- doxytag: member="lbm.h::LBM_DAEMON_EVENT_CONNECTED" ref="5ce6d6282cc249b1650e61304d02f595" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_DAEMON_EVENT_CONNECTED&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
UM daemon event. Connected successfully to daemon (info not valid) 
</div>
</div><p>
<a class="anchor" name="322412cb10f94f700ae2232d97d02530"></a><!-- doxytag: member="lbm.h::LBM_DAEMON_EVENT_DISCONNECTED" ref="322412cb10f94f700ae2232d97d02530" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_DAEMON_EVENT_DISCONNECTED&nbsp;&nbsp;&nbsp;3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
UM daemon event. Connection to daemon aborted (info not valid) 
</div>
</div><p>
<a class="anchor" name="2c339a557567c26309cdcfb7389f72a4"></a><!-- doxytag: member="lbm.h::LBM_EDAEMONCONN" ref="2c339a557567c26309cdcfb7389f72a4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_EDAEMONCONN&nbsp;&nbsp;&nbsp;7          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="lbm_8h.html#f3a827eb26d87be5b1a6b9fd3a4b63aa" title="Return the error number last encountered by this thread.">lbm_errnum()</a> value. UM daemon connection not connected. 
</div>
</div><p>
<a class="anchor" name="84ffe407ae998e9d27c51186e35ff558"></a><!-- doxytag: member="lbm.h::LBM_EINPROGRESS" ref="84ffe407ae998e9d27c51186e35ff558" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_EINPROGRESS&nbsp;&nbsp;&nbsp;10          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="lbm_8h.html#f3a827eb26d87be5b1a6b9fd3a4b63aa" title="Return the error number last encountered by this thread.">lbm_errnum()</a> value. Operation in progress. 
</div>
</div><p>
<a class="anchor" name="df5e90fc057c91d8edfde3a6dacead36"></a><!-- doxytag: member="lbm.h::LBM_EINVAL" ref="df5e90fc057c91d8edfde3a6dacead36" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_EINVAL&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="lbm_8h.html#f3a827eb26d87be5b1a6b9fd3a4b63aa" title="Return the error number last encountered by this thread.">lbm_errnum()</a> value. An invalid argument was passed. 
</div>
</div><p>
<a class="anchor" name="71d76f5ed5dbf09472d01d0620489376"></a><!-- doxytag: member="lbm.h::LBM_EMSG_SELECTOR" ref="71d76f5ed5dbf09472d01d0620489376" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_EMSG_SELECTOR&nbsp;&nbsp;&nbsp;14          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="lbm_8h.html#f3a827eb26d87be5b1a6b9fd3a4b63aa" title="Return the error number last encountered by this thread.">lbm_errnum()</a> Error parsing message selector. 
</div>
</div><p>
<a class="anchor" name="08de784eb29c9dd67d32ad87537616bc"></a><!-- doxytag: member="lbm.h::LBM_ENO_QUEUE_REG" ref="08de784eb29c9dd67d32ad87537616bc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_ENO_QUEUE_REG&nbsp;&nbsp;&nbsp;11          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="lbm_8h.html#f3a827eb26d87be5b1a6b9fd3a4b63aa" title="Return the error number last encountered by this thread.">lbm_errnum()</a> The queue is not fully registered. 
</div>
</div><p>
<a class="anchor" name="e5cf704243cf7e614863f2e535182676"></a><!-- doxytag: member="lbm.h::LBM_ENO_STORE_REG" ref="e5cf704243cf7e614863f2e535182676" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_ENO_STORE_REG&nbsp;&nbsp;&nbsp;12          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="lbm_8h.html#f3a827eb26d87be5b1a6b9fd3a4b63aa" title="Return the error number last encountered by this thread.">lbm_errnum()</a> The store is not fully registered. 
</div>
</div><p>
<a class="anchor" name="cb2933529ac090f72d189a6ef8bad81f"></a><!-- doxytag: member="lbm.h::LBM_ENOMEM" ref="cb2933529ac090f72d189a6ef8bad81f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_ENOMEM&nbsp;&nbsp;&nbsp;3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="lbm_8h.html#f3a827eb26d87be5b1a6b9fd3a4b63aa" title="Return the error number last encountered by this thread.">lbm_errnum()</a> value. Operation could not be completed due to memory allocation error. 
</div>
</div><p>
<a class="anchor" name="24ee8abac59b5a0584c662c2eeddefb6"></a><!-- doxytag: member="lbm.h::LBM_EOP" ref="24ee8abac59b5a0584c662c2eeddefb6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_EOP&nbsp;&nbsp;&nbsp;4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="lbm_8h.html#f3a827eb26d87be5b1a6b9fd3a4b63aa" title="Return the error number last encountered by this thread.">lbm_errnum()</a> value. Operation was invalid due to error in internal processing. 
</div>
</div><p>
<a class="anchor" name="f2390eaa119a81bb0087b30c5b36aefa"></a><!-- doxytag: member="lbm.h::LBM_EOPNOTSUPP" ref="f2390eaa119a81bb0087b30c5b36aefa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_EOPNOTSUPP&nbsp;&nbsp;&nbsp;9          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="lbm_8h.html#f3a827eb26d87be5b1a6b9fd3a4b63aa" title="Return the error number last encountered by this thread.">lbm_errnum()</a> value. Operation is not supported. 
</div>
</div><p>
<a class="anchor" name="987b349dea4592bf3832af15ef66b22c"></a><!-- doxytag: member="lbm.h::LBM_EOS" ref="987b349dea4592bf3832af15ef66b22c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_EOS&nbsp;&nbsp;&nbsp;5          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="lbm_8h.html#f3a827eb26d87be5b1a6b9fd3a4b63aa" title="Return the error number last encountered by this thread.">lbm_errnum()</a> value. Operation failed due to unrecoverable OS system call error. 
</div>
</div><p>
<a class="anchor" name="11df546da476e408cb7bb333b2a7c60a"></a><!-- doxytag: member="lbm.h::LBM_ETIMEDOUT" ref="11df546da476e408cb7bb333b2a7c60a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_ETIMEDOUT&nbsp;&nbsp;&nbsp;6          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="lbm_8h.html#f3a827eb26d87be5b1a6b9fd3a4b63aa" title="Return the error number last encountered by this thread.">lbm_errnum()</a> value. Operation timed out waiting to complete. 
</div>
</div><p>
<a class="anchor" name="2ef169e3b343481d569a88755f22bd59"></a><!-- doxytag: member="lbm.h::LBM_EUMENOREG" ref="2ef169e3b343481d569a88755f22bd59" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_EUMENOREG&nbsp;&nbsp;&nbsp;8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="lbm_8h.html#f3a827eb26d87be5b1a6b9fd3a4b63aa" title="Return the error number last encountered by this thread.">lbm_errnum()</a> value. Registration not completed. 
</div>
</div><p>
<a class="anchor" name="2c6b535637bfd72be2905b0cd4782140"></a><!-- doxytag: member="lbm.h::LBM_EVENT_QUEUE_BLOCK" ref="2c6b535637bfd72be2905b0cd4782140" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_EVENT_QUEUE_BLOCK&nbsp;&nbsp;&nbsp;0xFFFFFFFF          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Value passed to lbm_event_dispatch to ask it to block 
</div>
</div><p>
<a class="anchor" name="9bc366996c2e3fa52441096c2c322ca2"></a><!-- doxytag: member="lbm.h::LBM_EVENT_QUEUE_DELAY_WARNING" ref="9bc366996c2e3fa52441096c2c322ca2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_EVENT_QUEUE_DELAY_WARNING&nbsp;&nbsp;&nbsp;0x2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
event queue monitor event type. Warning of excessive delay for event. 
</div>
</div><p>
<a class="anchor" name="f0aeb1f5c969629a478e19f51913162e"></a><!-- doxytag: member="lbm.h::LBM_EVENT_QUEUE_ENQUEUE_NOTIFICATION" ref="f0aeb1f5c969629a478e19f51913162e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_EVENT_QUEUE_ENQUEUE_NOTIFICATION&nbsp;&nbsp;&nbsp;0x3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
event queue monitor event type. Notification of something being added to queue. 
</div>
</div><p>
<a class="anchor" name="1995a85e2c983f6b38322c5c5784f32e"></a><!-- doxytag: member="lbm.h::LBM_EVENT_QUEUE_POLL" ref="1995a85e2c983f6b38322c5c5784f32e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_EVENT_QUEUE_POLL&nbsp;&nbsp;&nbsp;0x0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Value passed to lbm_event_dispatch to ask it to poll 
</div>
</div><p>
<a class="anchor" name="8d104d87acef6f7b27b2ad111861df81"></a><!-- doxytag: member="lbm.h::LBM_EVENT_QUEUE_SIZE_WARNING" ref="8d104d87acef6f7b27b2ad111861df81" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_EVENT_QUEUE_SIZE_WARNING&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
event queue monitor event type. Warning of event queue size. 
</div>
</div><p>
<a class="anchor" name="75f0f83b8684df30d9816210cc20b4b0"></a><!-- doxytag: member="lbm.h::LBM_EWOULDBLOCK" ref="75f0f83b8684df30d9816210cc20b4b0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_EWOULDBLOCK&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="lbm_8h.html#f3a827eb26d87be5b1a6b9fd3a4b63aa" title="Return the error number last encountered by this thread.">lbm_errnum()</a> value. Function would block, but object is set to be nonblocking. 
</div>
</div><p>
<a class="anchor" name="a7202a258223ec773160a9a10b5a200f"></a><!-- doxytag: member="lbm.h::LBM_FD_EVENT_ACCEPT" ref="a7202a258223ec773160a9a10b5a200f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_FD_EVENT_ACCEPT&nbsp;&nbsp;&nbsp;0x8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
FD event. Accept connection (TCP) indication on file descriptor/socket 
</div>
</div><p>
<a class="anchor" name="ad8b25f8f19d67d5e52acd69a4fe41d6"></a><!-- doxytag: member="lbm.h::LBM_FD_EVENT_ALL" ref="ad8b25f8f19d67d5e52acd69a4fe41d6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_FD_EVENT_ALL&nbsp;&nbsp;&nbsp;0x3f          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
FD event. All events indication on file descriptor/socket 
</div>
</div><p>
<a class="anchor" name="85802e46728ea5804511097a66f7e8b4"></a><!-- doxytag: member="lbm.h::LBM_FD_EVENT_CLOSE" ref="85802e46728ea5804511097a66f7e8b4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_FD_EVENT_CLOSE&nbsp;&nbsp;&nbsp;0x10          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
FD event. Close indication on file descriptor/socket 
</div>
</div><p>
<a class="anchor" name="50d726f1c661fbdc9ff1631c0d65fe11"></a><!-- doxytag: member="lbm.h::LBM_FD_EVENT_CONNECT" ref="50d726f1c661fbdc9ff1631c0d65fe11" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_FD_EVENT_CONNECT&nbsp;&nbsp;&nbsp;0x20          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
FD event. Connected indication on file descriptor/socket 
</div>
</div><p>
<a class="anchor" name="33de981e32d17806f4488a572e53d8c2"></a><!-- doxytag: member="lbm.h::LBM_FD_EVENT_EXCEPT" ref="33de981e32d17806f4488a572e53d8c2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_FD_EVENT_EXCEPT&nbsp;&nbsp;&nbsp;0x4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
FD event. Exception (OOB/URG) indication on file descriptor/socket 
</div>
</div><p>
<a class="anchor" name="ba1b4477a130ebca41ca8fa07820acf8"></a><!-- doxytag: member="lbm.h::LBM_FD_EVENT_READ" ref="ba1b4477a130ebca41ca8fa07820acf8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_FD_EVENT_READ&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
FD event. Read indication on file descriptor/socket 
</div>
</div><p>
<a class="anchor" name="888ea40737dc555b9d8cad3e3170b790"></a><!-- doxytag: member="lbm.h::LBM_FD_EVENT_WRITE" ref="888ea40737dc555b9d8cad3e3170b790" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_FD_EVENT_WRITE&nbsp;&nbsp;&nbsp;0x2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
FD event. Write indication on file descriptor/socket 
</div>
</div><p>
<a class="anchor" name="3b4465e642a1c4eb4dd48458ed98c314"></a><!-- doxytag: member="lbm.h::LBM_FLIGHT_SIZE_TYPE_ULB" ref="3b4465e642a1c4eb4dd48458ed98c314" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_FLIGHT_SIZE_TYPE_ULB&nbsp;&nbsp;&nbsp;0x2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specify a ULB flight size 
</div>
</div><p>
<a class="anchor" name="8df58b9b0abb57cae51aa977a12e45b8"></a><!-- doxytag: member="lbm.h::LBM_FLIGHT_SIZE_TYPE_UME" ref="8df58b9b0abb57cae51aa977a12e45b8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_FLIGHT_SIZE_TYPE_UME&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specify a UMP flight size 
</div>
</div><p>
<a class="anchor" name="30c7a62d878cf9f9e4fcd366adc50eb4"></a><!-- doxytag: member="lbm.h::LBM_FLIGHT_SIZE_TYPE_UMQ" ref="30c7a62d878cf9f9e4fcd366adc50eb4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_FLIGHT_SIZE_TYPE_UMQ&nbsp;&nbsp;&nbsp;0x3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specify a UMQ flight size 
</div>
</div><p>
<a class="anchor" name="68e312c699dc51992fb70a28ef775de5"></a><!-- doxytag: member="lbm.h::LBM_LOG_ALERT" ref="68e312c699dc51992fb70a28ef775de5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_LOG_ALERT&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
log level. Alert 
</div>
</div><p>
<a class="anchor" name="40934de7af6bbe51233bb81b2abd8ea4"></a><!-- doxytag: member="lbm.h::LBM_LOG_CRIT" ref="40934de7af6bbe51233bb81b2abd8ea4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_LOG_CRIT&nbsp;&nbsp;&nbsp;3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
log level. Critical 
</div>
</div><p>
<a class="anchor" name="e02fdb7032b05050cec7ab0d205562c8"></a><!-- doxytag: member="lbm.h::LBM_LOG_DEBUG" ref="e02fdb7032b05050cec7ab0d205562c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_LOG_DEBUG&nbsp;&nbsp;&nbsp;8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
log level. Debugging information 
</div>
</div><p>
<a class="anchor" name="9b11d6d1f560c852821e0e71dee0a674"></a><!-- doxytag: member="lbm.h::LBM_LOG_EMERG" ref="9b11d6d1f560c852821e0e71dee0a674" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_LOG_EMERG&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
log level. Emergency 
</div>
</div><p>
<a class="anchor" name="5924551ebcb0e0cc96ddacb76c60de24"></a><!-- doxytag: member="lbm.h::LBM_LOG_ERR" ref="5924551ebcb0e0cc96ddacb76c60de24" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_LOG_ERR&nbsp;&nbsp;&nbsp;4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
log level. Error 
</div>
</div><p>
<a class="anchor" name="4dda4ddf0e0916c80944fa9d626b5b21"></a><!-- doxytag: member="lbm.h::LBM_LOG_INFO" ref="4dda4ddf0e0916c80944fa9d626b5b21" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_LOG_INFO&nbsp;&nbsp;&nbsp;7          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
log level. Informational 
</div>
</div><p>
<a class="anchor" name="95d263f41b71997ef7c073c3afb1eee9"></a><!-- doxytag: member="lbm.h::LBM_LOG_NOTICE" ref="95d263f41b71997ef7c073c3afb1eee9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_LOG_NOTICE&nbsp;&nbsp;&nbsp;6          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
log level. Notice 
</div>
</div><p>
<a class="anchor" name="bf896478100ba27f32ab0aa3bea3fe00"></a><!-- doxytag: member="lbm.h::LBM_LOG_WARNING" ref="bf896478100ba27f32ab0aa3bea3fe00" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_LOG_WARNING&nbsp;&nbsp;&nbsp;5          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
log level. Warning 
</div>
</div><p>
<a class="anchor" name="b5489080adc7157549a9930b30c68425"></a><!-- doxytag: member="lbm.h::LBM_MSG_BOS" ref="b5489080adc7157549a9930b30c68425" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_BOS&nbsp;&nbsp;&nbsp;20          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t type. Beginning of Transport Session (source connection established) (data received). 
</div>
</div><p>
<a class="anchor" name="645d298b05f49d6b7ba11db4ce208584"></a><!-- doxytag: member="lbm.h::LBM_MSG_COMPLETE_BATCH" ref="645d298b05f49d6b7ba11db4ce208584" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_COMPLETE_BATCH&nbsp;&nbsp;&nbsp;0x3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flag passed to a source send call E.G. (<a class="el" href="lbm_8h.html#91f4b9cb04fe1323ec56833211cc5cb7" title="Send a message to the topic associated with a UM source.">lbm_src_send()</a>, <a class="el" href="lbm_8h.html#091b5806bf18d10ebd0d9117e0c70229" title="Extended send of a message to the topic associated with a UM source.">lbm_src_send_ex()</a> etc) : Message constitutes a complete batch and should be sent to the implicit batching buffer. 
</div>
</div><p>
<a class="anchor" name="a47eb604db7dc9fd53f9650ed940e058"></a><!-- doxytag: member="lbm.h::LBM_MSG_DATA" ref="a47eb604db7dc9fd53f9650ed940e058" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_DATA&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t type. Data message, Message is composed of user data. 
</div>
</div><p>
<a class="anchor" name="8c283640e3e5ffdae94fd89900b38db4"></a><!-- doxytag: member="lbm.h::LBM_MSG_END_BATCH" ref="8c283640e3e5ffdae94fd89900b38db4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_END_BATCH&nbsp;&nbsp;&nbsp;0x2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flag passed to a source send call E.G. (<a class="el" href="lbm_8h.html#91f4b9cb04fe1323ec56833211cc5cb7" title="Send a message to the topic associated with a UM source.">lbm_src_send()</a>, <a class="el" href="lbm_8h.html#091b5806bf18d10ebd0d9117e0c70229" title="Extended send of a message to the topic associated with a UM source.">lbm_src_send_ex()</a> etc) : Message ends a batch of messages 
</div>
</div><p>
<a class="anchor" name="2647b87f92adb5a34ea129fbfeeed5a3"></a><!-- doxytag: member="lbm.h::LBM_MSG_EOS" ref="2647b87f92adb5a34ea129fbfeeed5a3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_EOS&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t type. End of Transport Session (connection closed to source) (no further data). 
</div>
</div><p>
<a class="anchor" name="84bff966269331fc0d7a8b61210b919b"></a><!-- doxytag: member="lbm.h::LBM_MSG_FLAG_DELIVERY_LATENCY" ref="84bff966269331fc0d7a8b61210b919b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_FLAG_DELIVERY_LATENCY&nbsp;&nbsp;&nbsp;0x200          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reserved for future use 
</div>
</div><p>
<a class="anchor" name="dc1c5e04a364561221d4f36285350f1f"></a><!-- doxytag: member="lbm.h::LBM_MSG_FLAG_END_BATCH" ref="dc1c5e04a364561221d4f36285350f1f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_FLAG_END_BATCH&nbsp;&nbsp;&nbsp;0x2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t flags. Message ends a batch. 
</div>
</div><p>
<a class="anchor" name="b2bf26e11ab181e8176a62300bfcbaff"></a><!-- doxytag: member="lbm.h::LBM_MSG_FLAG_HF_32" ref="b2bf26e11ab181e8176a62300bfcbaff" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_FLAG_HF_32&nbsp;&nbsp;&nbsp;0x800          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t flags. Message contains a 32 bit hot failover sequence number 
</div>
</div><p>
<a class="anchor" name="9dfe5a7d9229f8683a1e5114bde50336"></a><!-- doxytag: member="lbm.h::LBM_MSG_FLAG_HF_64" ref="9dfe5a7d9229f8683a1e5114bde50336" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_FLAG_HF_64&nbsp;&nbsp;&nbsp;0x1000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t flags. Message contains a 64 bit hot failover sequence number. 
</div>
</div><p>
<a class="anchor" name="9510697e9e5ab993733ec3063f107d86"></a><!-- doxytag: member="lbm.h::LBM_MSG_FLAG_HF_DUPLICATE" ref="9510697e9e5ab993733ec3063f107d86" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_FLAG_HF_DUPLICATE&nbsp;&nbsp;&nbsp;0x20          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t flags. Message is a Hot Failover duplicate message. 
</div>
</div><p>
<a class="anchor" name="768d9db1d811448e30738dd58125b699"></a><!-- doxytag: member="lbm.h::LBM_MSG_FLAG_HF_OPTIONAL" ref="768d9db1d811448e30738dd58125b699" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_FLAG_HF_OPTIONAL&nbsp;&nbsp;&nbsp;0x400          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t flags. Message is a Hot Failover optional message. 
</div>
</div><p>
<a class="anchor" name="cf728840c483a968c63f2b0613723725"></a><!-- doxytag: member="lbm.h::LBM_MSG_FLAG_HF_PASS_THROUGH" ref="cf728840c483a968c63f2b0613723725" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_FLAG_HF_PASS_THROUGH&nbsp;&nbsp;&nbsp;0x4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t flags. Message is a passed-through Hot Failover message. 
</div>
</div><p>
<a class="anchor" name="381f386fad7f6919d46676bd6e3f2d3a"></a><!-- doxytag: member="lbm.h::LBM_MSG_FLAG_IMMEDIATE" ref="381f386fad7f6919d46676bd6e3f2d3a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_FLAG_IMMEDIATE&nbsp;&nbsp;&nbsp;0x10          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t flags. Message is an immediate message. 
</div>
</div><p>
<a class="anchor" name="749bcd06a6a03250751f6171a6522a7b"></a><!-- doxytag: member="lbm.h::LBM_MSG_FLAG_NUMBERED_CHANNEL" ref="749bcd06a6a03250751f6171a6522a7b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_FLAG_NUMBERED_CHANNEL&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_channel_info_t flags. Message was sent on a numbered channel 
</div>
</div><p>
<a class="anchor" name="2b086d6bd8088880fe53f8b82d3d6eec"></a><!-- doxytag: member="lbm.h::LBM_MSG_FLAG_OTR" ref="2b086d6bd8088880fe53f8b82d3d6eec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_FLAG_OTR&nbsp;&nbsp;&nbsp;0x2000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t flags. Message was recovered via OTR 
</div>
</div><p>
<a class="anchor" name="1313dd3d0692d160c256956f48d023dd"></a><!-- doxytag: member="lbm.h::LBM_MSG_FLAG_RETRANSMIT" ref="1313dd3d0692d160c256956f48d023dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_FLAG_RETRANSMIT&nbsp;&nbsp;&nbsp;0x8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t flags. Message is a retransmission. 
</div>
</div><p>
<a class="anchor" name="4834e225e76aa9d4b4d32496552bae94"></a><!-- doxytag: member="lbm.h::LBM_MSG_FLAG_START_BATCH" ref="4834e225e76aa9d4b4d32496552bae94" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_FLAG_START_BATCH&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t flags. Message starts a batch. 
</div>
</div><p>
<a class="anchor" name="f1c052d0506e76507dbc109e4d77160e"></a><!-- doxytag: member="lbm.h::LBM_MSG_FLAG_TOPICLESS" ref="f1c052d0506e76507dbc109e4d77160e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_FLAG_TOPICLESS&nbsp;&nbsp;&nbsp;0x100          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t flags. Message has no topic. 
</div>
</div><p>
<a class="anchor" name="bae94fa27ea855156f5aac9962d5435c"></a><!-- doxytag: member="lbm.h::LBM_MSG_FLAG_UME_RETRANSMIT" ref="bae94fa27ea855156f5aac9962d5435c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_FLAG_UME_RETRANSMIT&nbsp;&nbsp;&nbsp;0x8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t flags. Message is a UMP retransmission. 
</div>
</div><p>
<a class="anchor" name="560d3a276cb5cf3bd67b2617394e8a9e"></a><!-- doxytag: member="lbm.h::LBM_MSG_FLAG_UMQ_REASSIGNED" ref="560d3a276cb5cf3bd67b2617394e8a9e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_FLAG_UMQ_REASSIGNED&nbsp;&nbsp;&nbsp;0x40          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t flags. Message is a UMQ message that has been re-assigned at least once. 
</div>
</div><p>
<a class="anchor" name="a56ddca7bfbc1b4f057ea5f0f1162582"></a><!-- doxytag: member="lbm.h::LBM_MSG_FLAG_UMQ_RESUBMITTED" ref="a56ddca7bfbc1b4f057ea5f0f1162582" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_FLAG_UMQ_RESUBMITTED&nbsp;&nbsp;&nbsp;0x80          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t flags. Message is a UMQ message that has been resubmitted at least once. 
</div>
</div><p>
<a class="anchor" name="ff5c45a7f7b65c5bde5988165b89fbd2"></a><!-- doxytag: member="lbm.h::LBM_MSG_FLUSH" ref="ff5c45a7f7b65c5bde5988165b89fbd2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_FLUSH&nbsp;&nbsp;&nbsp;0x4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flag passed to a source send call E.G. (<a class="el" href="lbm_8h.html#91f4b9cb04fe1323ec56833211cc5cb7" title="Send a message to the topic associated with a UM source.">lbm_src_send()</a>, <a class="el" href="lbm_8h.html#091b5806bf18d10ebd0d9117e0c70229" title="Extended send of a message to the topic associated with a UM source.">lbm_src_send_ex()</a> etc) : Message is to be sent ASAP (not implicitly or explicitly batched). This also flushes waiting messages that were explicitly or implicitly batched. 
</div>
</div><p>
<a class="anchor" name="e451edfbf80aa1cf945bfc844563933a"></a><!-- doxytag: member="lbm.h::LBM_MSG_HF_RESET" ref="e451edfbf80aa1cf945bfc844563933a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_HF_RESET&nbsp;&nbsp;&nbsp;27          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t type. Hot-failover reset message was handled. UMS is now expecting msg-&gt;hf_sequence_number as the next non-reset hot-failover message. 
</div>
</div><p>
<a class="anchor" name="f769aef242bc786cdbf9d0df28e06b2c"></a><!-- doxytag: member="lbm.h::LBM_MSG_IOV_GATHER" ref="f769aef242bc786cdbf9d0df28e06b2c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_IOV_GATHER&nbsp;&nbsp;&nbsp;0x40          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flag passed to a source send vectored call E.G. (<a class="el" href="lbm_8h.html#f28189e64ef0ee10d3444e418443aaa9" title="Send a set of messages to the topic associated with a UM source.">lbm_src_sendv()</a>, <a class="el" href="lbm_8h.html#4d883eaaa22baf81abf21d495f471c8b" title="Extended send of a set of messages to the topic associated with a UM source.">lbm_src_sendv_ex()</a> etc) : iovec elements should be gather into a single message 
</div>
</div><p>
<a class="anchor" name="e5762d573ecd4a041f1d1326d35312aa"></a><!-- doxytag: member="lbm.h::LBM_MSG_NO_SOURCE_NOTIFICATION" ref="e5762d573ecd4a041f1d1326d35312aa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_NO_SOURCE_NOTIFICATION&nbsp;&nbsp;&nbsp;6          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t type. Notification that no source has been found for topic. Still querying for topic source. 
</div>
</div><p>
<a class="anchor" name="ac271de581ec421ccf1bc4905ec4e52c"></a><!-- doxytag: member="lbm.h::LBM_MSG_PROPERTIES_MAX_NAMELEN" ref="ac271de581ec421ccf1bc4905ec4e52c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_PROPERTIES_MAX_NAMELEN&nbsp;&nbsp;&nbsp;250          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum size for the name of a message property 
</div>
</div><p>
<a class="anchor" name="de4e8a8380aead4cecd99d34074febd2"></a><!-- doxytag: member="lbm.h::LBM_MSG_PROPERTY_BOOLEAN" ref="de4e8a8380aead4cecd99d34074febd2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_PROPERTY_BOOLEAN&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Message property of boolean type 
</div>
</div><p>
<a class="anchor" name="3bc28e91b1571e511d7bf5f8c101cc43"></a><!-- doxytag: member="lbm.h::LBM_MSG_PROPERTY_BYTE" ref="3bc28e91b1571e511d7bf5f8c101cc43" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_PROPERTY_BYTE&nbsp;&nbsp;&nbsp;0x2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Message property of byte type 
</div>
</div><p>
<a class="anchor" name="4bbd5d39680d349384d4e80079d602b2"></a><!-- doxytag: member="lbm.h::LBM_MSG_PROPERTY_DOUBLE" ref="4bbd5d39680d349384d4e80079d602b2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_PROPERTY_DOUBLE&nbsp;&nbsp;&nbsp;0x7          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Message property of double type 
</div>
</div><p>
<a class="anchor" name="179ee6d46f98f273b358bba2bdfba75c"></a><!-- doxytag: member="lbm.h::LBM_MSG_PROPERTY_FLOAT" ref="179ee6d46f98f273b358bba2bdfba75c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_PROPERTY_FLOAT&nbsp;&nbsp;&nbsp;0x6          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Message property of float type 
</div>
</div><p>
<a class="anchor" name="77a1d3090e2e8e1dce799ae56859ce47"></a><!-- doxytag: member="lbm.h::LBM_MSG_PROPERTY_INT" ref="77a1d3090e2e8e1dce799ae56859ce47" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_PROPERTY_INT&nbsp;&nbsp;&nbsp;0x4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Message property of int type (4 bytes) 
</div>
</div><p>
<a class="anchor" name="ac5202e17486cd42934756b8be785ad4"></a><!-- doxytag: member="lbm.h::LBM_MSG_PROPERTY_LONG" ref="ac5202e17486cd42934756b8be785ad4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_PROPERTY_LONG&nbsp;&nbsp;&nbsp;0x5          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Message property of long type (8 bytes) 
</div>
</div><p>
<a class="anchor" name="6cad233ae9a9a1f4c48911c3e569ecee"></a><!-- doxytag: member="lbm.h::LBM_MSG_PROPERTY_NONE" ref="6cad233ae9a9a1f4c48911c3e569ecee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_PROPERTY_NONE&nbsp;&nbsp;&nbsp;0x0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Message property with no type (used to indicate an iterator has reached the last element) 
</div>
</div><p>
<a class="anchor" name="cac3a9e4b1dc7d3d9f1d42acabbcd514"></a><!-- doxytag: member="lbm.h::LBM_MSG_PROPERTY_SHORT" ref="cac3a9e4b1dc7d3d9f1d42acabbcd514" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_PROPERTY_SHORT&nbsp;&nbsp;&nbsp;0x3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Message property of short type (2 bytes) 
</div>
</div><p>
<a class="anchor" name="bd04d3a94da9cc86cf2886b3f0849bb7"></a><!-- doxytag: member="lbm.h::LBM_MSG_PROPERTY_STRING" ref="bd04d3a94da9cc86cf2886b3f0849bb7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_PROPERTY_STRING&nbsp;&nbsp;&nbsp;0x8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Message property of string type 
</div>
</div><p>
<a class="anchor" name="b83f7de50ce32f69651a7252d84ea828"></a><!-- doxytag: member="lbm.h::LBM_MSG_REQUEST" ref="b83f7de50ce32f69651a7252d84ea828" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_REQUEST&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t type. Request message from source. 
</div>
</div><p>
<a class="anchor" name="1d6c42864a4f2eb50d3300f12d8a33cb"></a><!-- doxytag: member="lbm.h::LBM_MSG_RESPONSE" ref="1d6c42864a4f2eb50d3300f12d8a33cb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_RESPONSE&nbsp;&nbsp;&nbsp;3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t type. Response message from requestee 
</div>
</div><p>
<a class="anchor" name="ad39695c269efdb19af8371edaa3bb89"></a><!-- doxytag: member="lbm.h::LBM_MSG_START_BATCH" ref="ad39695c269efdb19af8371edaa3bb89" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_START_BATCH&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flag passed to a source send call E.G. (<a class="el" href="lbm_8h.html#91f4b9cb04fe1323ec56833211cc5cb7" title="Send a message to the topic associated with a UM source.">lbm_src_send()</a>, <a class="el" href="lbm_8h.html#091b5806bf18d10ebd0d9117e0c70229" title="Extended send of a message to the topic associated with a UM source.">lbm_src_send_ex()</a> etc) : Message starts a batch 
</div>
</div><p>
<a class="anchor" name="86121aa40ecebeaa5c17e711dcd76b96"></a><!-- doxytag: member="lbm.h::LBM_MSG_UME_DEREGISTRATION_COMPLETE_EX" ref="86121aa40ecebeaa5c17e711dcd76b96" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UME_DEREGISTRATION_COMPLETE_EX&nbsp;&nbsp;&nbsp;13          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t type. UMP receiver notification of deregistration complete. 
</div>
</div><p>
<a class="anchor" name="c6a7a25ddf1e95d30d686b967fd7e5c9"></a><!-- doxytag: member="lbm.h::LBM_MSG_UME_DEREGISTRATION_SUCCESS_EX" ref="c6a7a25ddf1e95d30d686b967fd7e5c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UME_DEREGISTRATION_SUCCESS_EX&nbsp;&nbsp;&nbsp;12          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t type. UMP receiver notification of deregistration success. Data holds registration IDs, etc. 
</div>
</div><p>
<a class="anchor" name="50deb1ea55d9025a31dbf6e4a429f6db"></a><!-- doxytag: member="lbm.h::LBM_MSG_UME_DEREGISTRATION_SUCCESS_EX_FLAG_RPP" ref="50deb1ea55d9025a31dbf6e4a429f6db" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UME_DEREGISTRATION_SUCCESS_EX_FLAG_RPP&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deregistration was flagged as coming from a RPP store 
</div>
</div><p>
<a class="anchor" name="c12f55e0cdd14bd4d389bb3ef3afded3"></a><!-- doxytag: member="lbm.h::LBM_MSG_UME_REGISTRATION_CHANGE" ref="c12f55e0cdd14bd4d389bb3ef3afded3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UME_REGISTRATION_CHANGE&nbsp;&nbsp;&nbsp;9          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t type. UMP receiver notification of source registration change. Data holds info message. 
</div>
</div><p>
<a class="anchor" name="b0571ebaf7704333a5503d1c0668a989"></a><!-- doxytag: member="lbm.h::LBM_MSG_UME_REGISTRATION_COMPLETE_EX" ref="b0571ebaf7704333a5503d1c0668a989" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UME_REGISTRATION_COMPLETE_EX&nbsp;&nbsp;&nbsp;11          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t type. UMP receiver notification of registration completion. Data holds sequence number and flags, etc. 
</div>
</div><p>
<a class="anchor" name="588a541d2af81ae40418a93501b8a236"></a><!-- doxytag: member="lbm.h::LBM_MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM" ref="588a541d2af81ae40418a93501b8a236" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registration completed with only quorum reached. 
</div>
</div><p>
<a class="anchor" name="62fd6916bc53e965325d0e15df3aca47"></a><!-- doxytag: member="lbm.h::LBM_MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_RXREQMAX" ref="62fd6916bc53e965325d0e15df3aca47" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_RXREQMAX&nbsp;&nbsp;&nbsp;0x2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registration completed with RX REQ maximum used. 
</div>
</div><p>
<a class="anchor" name="eb0203ec0c560a60c3b97017afc61ada"></a><!-- doxytag: member="lbm.h::LBM_MSG_UME_REGISTRATION_ERROR" ref="eb0203ec0c560a60c3b97017afc61ada" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UME_REGISTRATION_ERROR&nbsp;&nbsp;&nbsp;7          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t type. UMP receiver registration encountered an error. Data holds error message. 
</div>
</div><p>
<a class="anchor" name="2ffe0658e008764982ad97128fedcaf0"></a><!-- doxytag: member="lbm.h::LBM_MSG_UME_REGISTRATION_SUCCESS" ref="2ffe0658e008764982ad97128fedcaf0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UME_REGISTRATION_SUCCESS&nbsp;&nbsp;&nbsp;8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t type. UMP receiver registration successful. Data holds registration IDs. 
</div>
</div><p>
<a class="anchor" name="cae32fc8bfc50769993fcea62e553bd8"></a><!-- doxytag: member="lbm.h::LBM_MSG_UME_REGISTRATION_SUCCESS_EX" ref="cae32fc8bfc50769993fcea62e553bd8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UME_REGISTRATION_SUCCESS_EX&nbsp;&nbsp;&nbsp;10          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t type. UMP receiver registration successful for a store (extended form). Data holds registration IDs, etc. 
</div>
</div><p>
<a class="anchor" name="6006f0d0dcf4ccb6589cfbe1f3df2a28"></a><!-- doxytag: member="lbm.h::LBM_MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_NOCACHE" ref="6006f0d0dcf4ccb6589cfbe1f3df2a28" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_NOCACHE&nbsp;&nbsp;&nbsp;0x2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registration was flagged as coming from a store that is configured to not cache data. 
</div>
</div><p>
<a class="anchor" name="10e26760ecc2f3b3b84a1fe71c2c2ae3"></a><!-- doxytag: member="lbm.h::LBM_MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_OLD" ref="10e26760ecc2f3b3b84a1fe71c2c2ae3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_OLD&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registration was flagged as an old receiver by the store. An old receiver is one the store had cached. 
</div>
</div><p>
<a class="anchor" name="e6eebed3b46d914bb37feddaac596db2"></a><!-- doxytag: member="lbm.h::LBM_MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_RPP" ref="e6eebed3b46d914bb37feddaac596db2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_RPP&nbsp;&nbsp;&nbsp;0x4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registration was flagged as coming from a store that has allowed a RPP receiver 
</div>
</div><p>
<a class="anchor" name="7e05596c569bc4043d30833347f92bba"></a><!-- doxytag: member="lbm.h::LBM_MSG_UMQ_DEREGISTRATION_COMPLETE_EX" ref="7e05596c569bc4043d30833347f92bba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UMQ_DEREGISTRATION_COMPLETE_EX&nbsp;&nbsp;&nbsp;19          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t type. UMQ receiver notification of de-registration completion. Data holds Queue information, etc. 
</div>
</div><p>
<a class="anchor" name="26ce01530072149fa87ea320a87b2d6b"></a><!-- doxytag: member="lbm.h::LBM_MSG_UMQ_DEREGISTRATION_COMPLETE_EX_FLAG_ULB" ref="26ce01530072149fa87ea320a87b2d6b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UMQ_DEREGISTRATION_COMPLETE_EX_FLAG_ULB&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deregistration completed for UMQ ULB source. 
</div>
</div><p>
<a class="anchor" name="84058f898fab99ffe5652d64e105c1aa"></a><!-- doxytag: member="lbm.h::LBM_MSG_UMQ_INDEX_ASSIGNED_EX" ref="84058f898fab99ffe5652d64e105c1aa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UMQ_INDEX_ASSIGNED_EX&nbsp;&nbsp;&nbsp;24          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t type. UMQ receiver notification of beginning of index. 
</div>
</div><p>
<a class="anchor" name="951a325a326d6ebd1e494c138238d138"></a><!-- doxytag: member="lbm.h::LBM_MSG_UMQ_INDEX_ASSIGNED_EX_FLAG_REQUESTED" ref="951a325a326d6ebd1e494c138238d138" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UMQ_INDEX_ASSIGNED_EX_FLAG_REQUESTED&nbsp;&nbsp;&nbsp;0x2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Beginning of index assignment that was requested by receiver. 
</div>
</div><p>
<a class="anchor" name="0211c9dc0a470d7d5d88202d32d7272a"></a><!-- doxytag: member="lbm.h::LBM_MSG_UMQ_INDEX_ASSIGNED_EX_FLAG_ULB" ref="0211c9dc0a470d7d5d88202d32d7272a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UMQ_INDEX_ASSIGNED_EX_FLAG_ULB&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Beginning of index from ULB source. 
</div>
</div><p>
<a class="anchor" name="6fd9dbb2e6c9559c16fb2ad2e6c0781d"></a><!-- doxytag: member="lbm.h::LBM_MSG_UMQ_INDEX_ASSIGNMENT_ELIGIBILITY_ERROR" ref="6fd9dbb2e6c9559c16fb2ad2e6c0781d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UMQ_INDEX_ASSIGNMENT_ELIGIBILITY_ERROR&nbsp;&nbsp;&nbsp;21          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t type. UMQ receiver index assignment start/stop encountered an error. Data holds error message. 
</div>
</div><p>
<a class="anchor" name="0be80e79faa49ef9cb1e399c9bf436f6"></a><!-- doxytag: member="lbm.h::LBM_MSG_UMQ_INDEX_ASSIGNMENT_ELIGIBILITY_START_COMPLETE_EX" ref="0be80e79faa49ef9cb1e399c9bf436f6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UMQ_INDEX_ASSIGNMENT_ELIGIBILITY_START_COMPLETE_EX&nbsp;&nbsp;&nbsp;22          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t type. UMQ receiver notification of beginning of index assignment eligibility or index assignment. Data holds index information, etc. 
</div>
</div><p>
<a class="anchor" name="b998f932074057e2bca6bf7c471eb8bf"></a><!-- doxytag: member="lbm.h::LBM_MSG_UMQ_INDEX_ASSIGNMENT_ELIGIBILITY_START_COMPLETE_EX_FLAG_ULB" ref="b998f932074057e2bca6bf7c471eb8bf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UMQ_INDEX_ASSIGNMENT_ELIGIBILITY_START_COMPLETE_EX_FLAG_ULB&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Index assignment started for ULB source. 
</div>
</div><p>
<a class="anchor" name="cee7666e4e4d1b4ee55d4e580cf21c90"></a><!-- doxytag: member="lbm.h::LBM_MSG_UMQ_INDEX_ASSIGNMENT_ELIGIBILITY_STOP_COMPLETE_EX" ref="cee7666e4e4d1b4ee55d4e580cf21c90" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UMQ_INDEX_ASSIGNMENT_ELIGIBILITY_STOP_COMPLETE_EX&nbsp;&nbsp;&nbsp;23          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t type. UMQ receiver notification of end of index assignment eligibility or index assignment. Data holds index information, etc. 
</div>
</div><p>
<a class="anchor" name="b7c5c80779193e392dbe64b8a04417ea"></a><!-- doxytag: member="lbm.h::LBM_MSG_UMQ_INDEX_ASSIGNMENT_ELIGIBILITY_STOP_COMPLETE_EX_FLAG_ULB" ref="b7c5c80779193e392dbe64b8a04417ea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UMQ_INDEX_ASSIGNMENT_ELIGIBILITY_STOP_COMPLETE_EX_FLAG_ULB&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Index assignment stopped for ULB source. 
</div>
</div><p>
<a class="anchor" name="55784af6ed72244740c3d0509f9d4e84"></a><!-- doxytag: member="lbm.h::LBM_MSG_UMQ_INDEX_ASSIGNMENT_ERROR" ref="55784af6ed72244740c3d0509f9d4e84" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UMQ_INDEX_ASSIGNMENT_ERROR&nbsp;&nbsp;&nbsp;26          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t type. UMQ receiver notification of an index assignment error. 
</div>
</div><p>
<a class="anchor" name="3ba42691e5f6f4f8f38b46ccce203ba4"></a><!-- doxytag: member="lbm.h::LBM_MSG_UMQ_INDEX_RELEASED_EX" ref="3ba42691e5f6f4f8f38b46ccce203ba4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UMQ_INDEX_RELEASED_EX&nbsp;&nbsp;&nbsp;25          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t type. UMQ receiver notification of end of index. 
</div>
</div><p>
<a class="anchor" name="849bc0ca99de35c9e59d4f0202866b1f"></a><!-- doxytag: member="lbm.h::LBM_MSG_UMQ_INDEX_RELEASED_EX_FLAG_ULB" ref="849bc0ca99de35c9e59d4f0202866b1f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UMQ_INDEX_RELEASED_EX_FLAG_ULB&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
End of index from ULB source. 
</div>
</div><p>
<a class="anchor" name="6c51a89970a7e1f98afc8c493bd9b86e"></a><!-- doxytag: member="lbm.h::LBM_MSG_UMQ_REASSIGN_FLAG_DISCARD" ref="6c51a89970a7e1f98afc8c493bd9b86e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UMQ_REASSIGN_FLAG_DISCARD&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Instead of requesting reassignment, request the message be discarded. 
</div>
</div><p>
<a class="anchor" name="f5cdc6cdb79853c73d03abac074e2d4c"></a><!-- doxytag: member="lbm.h::LBM_MSG_UMQ_REGISTRATION_COMPLETE_EX" ref="f5cdc6cdb79853c73d03abac074e2d4c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UMQ_REGISTRATION_COMPLETE_EX&nbsp;&nbsp;&nbsp;18          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t type. UMQ receiver notification of registration completion. Data holds Queue information, assignment ID, etc. 
</div>
</div><p>
<a class="anchor" name="f5b1c26869ce6144e5fba3fb65e6eb25"></a><!-- doxytag: member="lbm.h::LBM_MSG_UMQ_REGISTRATION_COMPLETE_EX_FLAG_QUORUM" ref="f5b1c26869ce6144e5fba3fb65e6eb25" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UMQ_REGISTRATION_COMPLETE_EX_FLAG_QUORUM&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registration completed with only quorum reached. 
</div>
</div><p>
<a class="anchor" name="e21ffacef3953f86f1b4559c78d348f2"></a><!-- doxytag: member="lbm.h::LBM_MSG_UMQ_REGISTRATION_COMPLETE_EX_FLAG_ULB" ref="e21ffacef3953f86f1b4559c78d348f2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UMQ_REGISTRATION_COMPLETE_EX_FLAG_ULB&nbsp;&nbsp;&nbsp;0x2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registration completed for UMQ ULB source. 
</div>
</div><p>
<a class="anchor" name="9d1e2e6ee259b458a8a7097462ae7166"></a><!-- doxytag: member="lbm.h::LBM_MSG_UMQ_REGISTRATION_ERROR" ref="9d1e2e6ee259b458a8a7097462ae7166" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UMQ_REGISTRATION_ERROR&nbsp;&nbsp;&nbsp;16          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t type. UMQ receiver registration encountered an error. Data holds error message. 
</div>
</div><p>
<a class="anchor" name="88920e0a4188081f9a14fc8f76c18578"></a><!-- doxytag: member="lbm.h::LBM_MSG_UNRECOVERABLE_LOSS" ref="88920e0a4188081f9a14fc8f76c18578" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UNRECOVERABLE_LOSS&nbsp;&nbsp;&nbsp;4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t type. Missing message detected and not recovered in given time. 
</div>
</div><p>
<a class="anchor" name="6629139aaf902976c8df9de3f37d10db"></a><!-- doxytag: member="lbm.h::LBM_MSG_UNRECOVERABLE_LOSS_BURST" ref="6629139aaf902976c8df9de3f37d10db" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_MSG_UNRECOVERABLE_LOSS_BURST&nbsp;&nbsp;&nbsp;5          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_msg_t type. Missing burst of messages detected and not recovered. 
</div>
</div><p>
<a class="anchor" name="ba03604772ef910a1c10064d8fcbd58d"></a><!-- doxytag: member="lbm.h::LBM_RCV_BLOCK" ref="ba03604772ef910a1c10064d8fcbd58d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_RCV_BLOCK&nbsp;&nbsp;&nbsp;0x20          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reserved for future use 
</div>
</div><p>
<a class="anchor" name="01cfd803e98493dfc2c7988aaa7f4b79"></a><!-- doxytag: member="lbm.h::LBM_RCV_BLOCK_TEMP" ref="01cfd803e98493dfc2c7988aaa7f4b79" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_RCV_BLOCK_TEMP&nbsp;&nbsp;&nbsp;0x10          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reserved for future use 
</div>
</div><p>
<a class="anchor" name="e38db10baacaa5e86f2968993fb3e8a9"></a><!-- doxytag: member="lbm.h::LBM_RCV_NONBLOCK" ref="e38db10baacaa5e86f2968993fb3e8a9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_RCV_NONBLOCK&nbsp;&nbsp;&nbsp;0x8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reserved for future use 
</div>
</div><p>
<a class="anchor" name="41a6bc8b3a5d8670b4066cf14fbe2556"></a><!-- doxytag: member="lbm.h::LBM_SRC_BLOCK" ref="41a6bc8b3a5d8670b4066cf14fbe2556" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_BLOCK&nbsp;&nbsp;&nbsp;0x20          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flag passed to a source send call E.G. (<a class="el" href="lbm_8h.html#91f4b9cb04fe1323ec56833211cc5cb7" title="Send a message to the topic associated with a UM source.">lbm_src_send()</a>, <a class="el" href="lbm_8h.html#091b5806bf18d10ebd0d9117e0c70229" title="Extended send of a message to the topic associated with a UM source.">lbm_src_send_ex()</a> etc) : Block the caller indefinitely until the message is sent. (This behavior is the default if neither LBM_SRC_NONBLOCK nor LBM_SRC_BLOCK are supplied.) 
</div>
</div><p>
<a class="anchor" name="51d2a9b83f28205fadae8ab9abf89b38"></a><!-- doxytag: member="lbm.h::LBM_SRC_BLOCK_TEMP" ref="51d2a9b83f28205fadae8ab9abf89b38" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_BLOCK_TEMP&nbsp;&nbsp;&nbsp;0x10          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reserved for future use 
</div>
</div><p>
<a class="anchor" name="ede9b7b462cd83fd6e46346260a134ca"></a><!-- doxytag: member="lbm.h::LBM_SRC_COST_FUNCTION_REJECT" ref="ede9b7b462cd83fd6e46346260a134ca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_COST_FUNCTION_REJECT&nbsp;&nbsp;&nbsp;0xffffffff          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Source cost function return value to indicate this source should be permanently rejected. 
</div>
</div><p>
<a class="anchor" name="db8a3d729fdaa96b9729144ee86668ad"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_CONNECT" ref="db8a3d729fdaa96b9729144ee86668ad" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_CONNECT&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. This event indicates that the first or initial receiver of a receiving application has joined a unicast transport session. UM delivers this event if it has mapped a source object to a unicast transport session (TCP, LBT-RU, LBT-IPC, or LBT-RDMA) and then the first receiver joins the transport session. If several sources map to the transport session, UM delivers this event multiple times, once for each source. The initial receiver can be subscribed to any of the sources topics. Subsequent receivers that join the transport session do not trigger additional events. However, additional receiving applications (contexts) may also join the transport session and UM delivers the event for the first or initial receiver of each additional application. 
</div>
</div><p>
<a class="anchor" name="565d6e278372a69bf318b3cde5bfcb23"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_DAEMON_CONFIRM" ref="565d6e278372a69bf318b3cde5bfcb23" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_DAEMON_CONFIRM&nbsp;&nbsp;&nbsp;4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UM daemon usage only, means daemon has confirmed src created 
</div>
</div><p>
<a class="anchor" name="cf50e4167d38a398bf5ae12c163ff2bb"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_DISCONNECT" ref="cf50e4167d38a398bf5ae12c163ff2bb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_DISCONNECT&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. This event indicates that the last or final receiver of a receiving application has left a unicast transport session. UM delivers this event if it has mapped a source object to a unicast transport session (TCP, LBT-RU, LBT-IPC, or LBT-RDMA) and then the last receiver leaves the transport session. If several sources map to the transport session, UM delivers this event multiple times, once for each source. The final receiver can be subscribed to any of the sources topics. Additional receiving applications (contexts) may also leave the transport session and UM delivers the event for the last or final receiver of each additional application. 
</div>
</div><p>
<a class="anchor" name="6d75dfecae9635b61c289efa3a8aa017"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_FLIGHT_SIZE_NOTIFICATION" ref="6d75dfecae9635b61c289efa3a8aa017" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_FLIGHT_SIZE_NOTIFICATION&nbsp;&nbsp;&nbsp;29          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UMP, UMQ, and/or ULB, informs the application of a change in state for a specified flight size. Event data holds state information. 
</div>
</div><p>
<a class="anchor" name="117eda1a0792b41a8a6ffbab7becf834"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_FLIGHT_SIZE_NOTIFICATION_STATE_OVER" ref="117eda1a0792b41a8a6ffbab7becf834" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_FLIGHT_SIZE_NOTIFICATION_STATE_OVER&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Messages in flight has exceeded the threshold 
</div>
</div><p>
<a class="anchor" name="df54f7b5bcae5127f6cf814945a62ab9"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_FLIGHT_SIZE_NOTIFICATION_STATE_UNDER" ref="df54f7b5bcae5127f6cf814945a62ab9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_FLIGHT_SIZE_NOTIFICATION_STATE_UNDER&nbsp;&nbsp;&nbsp;0x2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Messages in flight is now below the threshold 
</div>
</div><p>
<a class="anchor" name="641ccdb2bad37d1dcf84dbded61a33cb"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_FLIGHT_SIZE_NOTIFICATION_TYPE_ULB" ref="641ccdb2bad37d1dcf84dbded61a33cb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_FLIGHT_SIZE_NOTIFICATION_TYPE_ULB&nbsp;&nbsp;&nbsp;0x2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specifies a ULB flight size 
</div>
</div><p>
<a class="anchor" name="802df02d3e81ef390217b22d123f8b9a"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_FLIGHT_SIZE_NOTIFICATION_TYPE_UME" ref="802df02d3e81ef390217b22d123f8b9a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_FLIGHT_SIZE_NOTIFICATION_TYPE_UME&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specifies a UMP flight size 
</div>
</div><p>
<a class="anchor" name="ead2957413a2955c6efa76d591455896"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_FLIGHT_SIZE_NOTIFICATION_TYPE_UMQ" ref="ead2957413a2955c6efa76d591455896" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_FLIGHT_SIZE_NOTIFICATION_TYPE_UMQ&nbsp;&nbsp;&nbsp;0x3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specifies a UMQ flight size 
</div>
</div><p>
<a class="anchor" name="350c2cab7f6f029276ebc323b7d73795"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_SEQUENCE_NUMBER_INFO" ref="350c2cab7f6f029276ebc323b7d73795" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_SEQUENCE_NUMBER_INFO&nbsp;&nbsp;&nbsp;15          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. Informs the application the sequence numbers used with a message. Event data holds sequence number data. This event is generated only when using the "lbm_src_send_ex()" API's with the LBM_SRC_SEND_EX_FLAG_SEQUENCE_NUMBER_INFO flag or LBM_SRC_SEND_EX_FLAG_SEQUENCE_NUMBER_INFO_FRAGONLY flag. 
</div>
</div><p>
<a class="anchor" name="b9d560dcaaa6d7982d9590ae897ce0b5"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION" ref="b9d560dcaaa6d7982d9590ae897ce0b5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION&nbsp;&nbsp;&nbsp;8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UMP only, means UMP Confirmed Delivery of Message from receiver. Event data holds ACK information. 
</div>
</div><p>
<a class="anchor" name="e7124621f7cab5925ed8354690d736f9"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX" ref="e7124621f7cab5925ed8354690d736f9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX&nbsp;&nbsp;&nbsp;14          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UMP only, means UMP Confirmed Delivery of Message from receiver (extended form). Event data holds ACK information. 
</div>
</div><p>
<a class="anchor" name="149eecc4bad8748ef9a5a834e1272f5a"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_EXACK" ref="149eecc4bad8748ef9a5a834e1272f5a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_EXACK&nbsp;&nbsp;&nbsp;0x8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Confirmation received with Explicit ACK (EXACK) flagged. 
</div>
</div><p>
<a class="anchor" name="b669fba2eefaf6754ac963df27902099"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_OOD" ref="b669fba2eefaf6754ac963df27902099" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_OOD&nbsp;&nbsp;&nbsp;0x4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Confirmation received with Out-of-Order Delivery (OOD) flagged. 
</div>
</div><p>
<a class="anchor" name="07588ef8b95c9af845bdf5293961d23d"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_UNIQUEACKS" ref="07588ef8b95c9af845bdf5293961d23d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_UNIQUEACKS&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Confirmation received for specified number of unique ACKs. 
</div>
</div><p>
<a class="anchor" name="d88a2ca8fd310da45f4eb38cc5c77d9f"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_UREGID" ref="d88a2ca8fd310da45f4eb38cc5c77d9f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_UREGID&nbsp;&nbsp;&nbsp;0x2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Confirmation received with User Specified Rcv Registration ID flagged. 
</div>
</div><p>
<a class="anchor" name="7f14767a9e7acac796f11ab829ddd7d0"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_WHOLE_MESSAGE_CONFIRMED" ref="7f14767a9e7acac796f11ab829ddd7d0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_WHOLE_MESSAGE_CONFIRMED&nbsp;&nbsp;&nbsp;0x10          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whole message (each fragment) has been confirmed 
</div>
</div><p>
<a class="anchor" name="cd799cdd68375462a2b6dec522e0250b"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_DEREGISTRATION_COMPLETE_EX" ref="cd799cdd68375462a2b6dec522e0250b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_DEREGISTRATION_COMPLETE_EX&nbsp;&nbsp;&nbsp;32          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UMP only, means deregistration of source complete (extended form). 
</div>
</div><p>
<a class="anchor" name="161b30d489f39fde9ead22bea7e13c83"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_DEREGISTRATION_SUCCESS_EX" ref="161b30d489f39fde9ead22bea7e13c83" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_DEREGISTRATION_SUCCESS_EX&nbsp;&nbsp;&nbsp;31          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UMP only, means deregistration of source successful (extended form). 
</div>
</div><p>
<a class="anchor" name="d1821a408b0feaf8c28893ee79816dab"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_MESSAGE_RECLAIMED" ref="d1821a408b0feaf8c28893ee79816dab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_MESSAGE_RECLAIMED&nbsp;&nbsp;&nbsp;10          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UMP only, means message is being reclaimed. Event data holds ACK information. 
</div>
</div><p>
<a class="anchor" name="91689d8826be0160f64358ccfcff2877"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_MESSAGE_RECLAIMED_EX" ref="91689d8826be0160f64358ccfcff2877" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_MESSAGE_RECLAIMED_EX&nbsp;&nbsp;&nbsp;30          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. Message is being reclaimed. Event data holds ACK information. 
</div>
</div><p>
<a class="anchor" name="6407f37e7d8b600732408d1ae4d0e9a5"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_MESSAGE_RECLAIMED_EX_FLAG_FORCED" ref="6407f37e7d8b600732408d1ae4d0e9a5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_MESSAGE_RECLAIMED_EX_FLAG_FORCED&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reclaim notification is the result of a forced reclaim 
</div>
</div><p>
<a class="anchor" name="9b8f0ee19762fe6d8c9a43ccdb0d94ef"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_MESSAGE_STABLE" ref="9b8f0ee19762fe6d8c9a43ccdb0d94ef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_MESSAGE_STABLE&nbsp;&nbsp;&nbsp;7          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UMP only, means UMP ACK from store indicates message is stable. Event data holds ACK information. 
</div>
</div><p>
<a class="anchor" name="cf1cedd5755e63083db63f3d45e45df6"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX" ref="cf1cedd5755e63083db63f3d45e45df6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX&nbsp;&nbsp;&nbsp;13          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UMP only, means UMP ACK from store indicates message is stable (extended form). Event data holds ACK information. 
</div>
</div><p>
<a class="anchor" name="5209ab197cba9f57f03b8ae6a5f48585"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_INTERGROUP_STABLE" ref="5209ab197cba9f57f03b8ae6a5f48585" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_INTERGROUP_STABLE&nbsp;&nbsp;&nbsp;0x2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Message stable for intergroup stability 
</div>
</div><p>
<a class="anchor" name="4e0b6021726c4981d2e75ad11853af7a"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_INTRAGROUP_STABLE" ref="4e0b6021726c4981d2e75ad11853af7a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_INTRAGROUP_STABLE&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Message stable for intragroup stability 
</div>
</div><p>
<a class="anchor" name="379b0fa6121126b2f0e2d10904654142"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_STABLE" ref="379b0fa6121126b2f0e2d10904654142" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_STABLE&nbsp;&nbsp;&nbsp;0x4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Message is stable according to behavior desired 
</div>
</div><p>
<a class="anchor" name="1a5d30c2598d27caf11355d276ea7d8c"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_STORE" ref="1a5d30c2598d27caf11355d276ea7d8c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_STORE&nbsp;&nbsp;&nbsp;0x8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Message stable information has active store information 
</div>
</div><p>
<a class="anchor" name="6432918a0f748a74ca565e1bfc90c5e6"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_USER" ref="6432918a0f748a74ca565e1bfc90c5e6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_USER&nbsp;&nbsp;&nbsp;0x20          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Message stabilized via lbm_ume_src_msg_stable API 
</div>
</div><p>
<a class="anchor" name="5b5f204996c14a67f0e96847c3c49121"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_WHOLE_MESSAGE_STABLE" ref="5b5f204996c14a67f0e96847c3c49121" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_WHOLE_MESSAGE_STABLE&nbsp;&nbsp;&nbsp;0x10          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whole message (each fragment) is stable 
</div>
</div><p>
<a class="anchor" name="1e46557c499f8e8f97bb7996a1662f26"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_REGISTRATION_COMPLETE_EX" ref="1e46557c499f8e8f97bb7996a1662f26" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_REGISTRATION_COMPLETE_EX&nbsp;&nbsp;&nbsp;12          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UMP only, means registration of source complete (extended form). Event data holds sequence number, flags, etc. 
</div>
</div><p>
<a class="anchor" name="1260065b954b5fd3d93dc375fdf8fa48"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM" ref="1260065b954b5fd3d93dc375fdf8fa48" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registration completed with only quorum reached. 
</div>
</div><p>
<a class="anchor" name="b030d061f44d60babc7d9efba6769cc2"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_REGISTRATION_ERROR" ref="b030d061f44d60babc7d9efba6769cc2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_REGISTRATION_ERROR&nbsp;&nbsp;&nbsp;5          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UMP only, means registration of source failed with an error. Event data holds error string. 
</div>
</div><p>
<a class="anchor" name="eb34dd1f9e35b809f214b1a9b5f1bed9"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS" ref="eb34dd1f9e35b809f214b1a9b5f1bed9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS&nbsp;&nbsp;&nbsp;6          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UMP only, means registration of source successful. Event data holds registration info 
</div>
</div><p>
<a class="anchor" name="99e39b5b7215553654f91f8b74ad98c8"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX" ref="99e39b5b7215553654f91f8b74ad98c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX&nbsp;&nbsp;&nbsp;11          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UMP only, means registration of source successful (extended form). Event data holds registration info 
</div>
</div><p>
<a class="anchor" name="4a2bea66079c493cbcda44221eb84817"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_NOACKS" ref="4a2bea66079c493cbcda44221eb84817" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_NOACKS&nbsp;&nbsp;&nbsp;0x2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registration was flagged as coming from a store that is configured to not send ACKs for stability (no-cache store) 
</div>
</div><p>
<a class="anchor" name="67fb27c8719fc6d535a1a6dbd9efcb06"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_OLD" ref="67fb27c8719fc6d535a1a6dbd9efcb06" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_OLD&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registration was flagged as an old source by the store. An old source is one the store had cached. 
</div>
</div><p>
<a class="anchor" name="356af56356f6619bc632ec3dc530dc95"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_RPP" ref="356af56356f6619bc632ec3dc530dc95" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_RPP&nbsp;&nbsp;&nbsp;0x4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registration was flagged as coming from a store that allows and has accepted RPP persistent topics 
</div>
</div><p>
<a class="anchor" name="9505bdf346c03c9751b7d1c3755d4843"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UME_STORE_UNRESPONSIVE" ref="9505bdf346c03c9751b7d1c3755d4843" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UME_STORE_UNRESPONSIVE&nbsp;&nbsp;&nbsp;9          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UMP only, means store has not been active within timeout. Event data holds info string. 
</div>
</div><p>
<a class="anchor" name="9145c5492742c8c53163874789d0d8b5"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UMQ_MESSAGE_ID_INFO" ref="9145c5492742c8c53163874789d0d8b5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UMQ_MESSAGE_ID_INFO&nbsp;&nbsp;&nbsp;17          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UMQ only, informs the application of the Message ID assigned with a message. Event data holds Message ID, etc. 
</div>
</div><p>
<a class="anchor" name="65cd8e57a5b144f29cc70c8537c7d506"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UMQ_MESSAGE_STABLE_EX" ref="65cd8e57a5b144f29cc70c8537c7d506" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UMQ_MESSAGE_STABLE_EX&nbsp;&nbsp;&nbsp;19          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UMQ only, means UMQ ACK from queue indicates message is stable. Event data holds ACK information. 
</div>
</div><p>
<a class="anchor" name="d3602e1a062f6e505abcfa6eba2153b1"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UMQ_MESSAGE_STABLE_EX_FLAG_INTERGROUP_STABLE" ref="d3602e1a062f6e505abcfa6eba2153b1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UMQ_MESSAGE_STABLE_EX_FLAG_INTERGROUP_STABLE&nbsp;&nbsp;&nbsp;0x2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Message stable for intergroup stability 
</div>
</div><p>
<a class="anchor" name="f9f3a473d5fcd99707d5c291dfe1e8b7"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UMQ_MESSAGE_STABLE_EX_FLAG_INTRAGROUP_STABLE" ref="f9f3a473d5fcd99707d5c291dfe1e8b7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UMQ_MESSAGE_STABLE_EX_FLAG_INTRAGROUP_STABLE&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Message stable for intragroup stability 
</div>
</div><p>
<a class="anchor" name="6e8dfa6aac8f88adc873651058c9f61f"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UMQ_MESSAGE_STABLE_EX_FLAG_STABLE" ref="6e8dfa6aac8f88adc873651058c9f61f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UMQ_MESSAGE_STABLE_EX_FLAG_STABLE&nbsp;&nbsp;&nbsp;0x4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Message is stable according to behavior desired 
</div>
</div><p>
<a class="anchor" name="4df886d1321f264f72fc5c17abc82e26"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UMQ_MESSAGE_STABLE_EX_FLAG_USER" ref="4df886d1321f264f72fc5c17abc82e26" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UMQ_MESSAGE_STABLE_EX_FLAG_USER&nbsp;&nbsp;&nbsp;0x8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Message stabilized via the lbm_umq_ctx_msg_stable API 
</div>
</div><p>
<a class="anchor" name="a409add379c0380b2efa63f4095d69e4"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UMQ_REGISTRATION_COMPLETE_EX" ref="a409add379c0380b2efa63f4095d69e4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UMQ_REGISTRATION_COMPLETE_EX&nbsp;&nbsp;&nbsp;18          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UMQ only, means registration of source complete. Event data holds Queue information, etc. 
</div>
</div><p>
<a class="anchor" name="30614c41c2a4ec374ee846bf87f0f5d1"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UMQ_REGISTRATION_COMPLETE_EX_FLAG_QUORUM" ref="30614c41c2a4ec374ee846bf87f0f5d1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UMQ_REGISTRATION_COMPLETE_EX_FLAG_QUORUM&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registration completed with only quorum reached. 
</div>
</div><p>
<a class="anchor" name="2baee742e0a92121e87871afb2215ab5"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UMQ_REGISTRATION_ERROR" ref="2baee742e0a92121e87871afb2215ab5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UMQ_REGISTRATION_ERROR&nbsp;&nbsp;&nbsp;16          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UMQ only, means registration of source failed with an error. Event data holds error string. 
</div>
</div><p>
<a class="anchor" name="9cfe28e7621da64e7c4a0cadd87314fa"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UMQ_ULB_MESSAGE_ASSIGNED_EX" ref="9cfe28e7621da64e7c4a0cadd87314fa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UMQ_ULB_MESSAGE_ASSIGNED_EX&nbsp;&nbsp;&nbsp;20          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UMQ ULB only, means message was assigned to a receiver. Event data holds message information. 
</div>
</div><p>
<a class="anchor" name="4a7db539dc44a3ea20b28221a760d1ab"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UMQ_ULB_MESSAGE_COMPLETE_EX" ref="4a7db539dc44a3ea20b28221a760d1ab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UMQ_ULB_MESSAGE_COMPLETE_EX&nbsp;&nbsp;&nbsp;23          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UMQ ULB only, means message was completed processed on all application sets. Event data holds message information. 
</div>
</div><p>
<a class="anchor" name="9b09c5d3c47ada94e65653cdc8e3084f"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UMQ_ULB_MESSAGE_CONSUMED_EX" ref="9b09c5d3c47ada94e65653cdc8e3084f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UMQ_ULB_MESSAGE_CONSUMED_EX&nbsp;&nbsp;&nbsp;24          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UMQ ULB only, means message was consumed by a receiver. Event data holds message information. 
</div>
</div><p>
<a class="anchor" name="f5f5b23502005a15f3baa56ef898deff"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UMQ_ULB_MESSAGE_REASSIGNED_EX" ref="f5f5b23502005a15f3baa56ef898deff" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UMQ_ULB_MESSAGE_REASSIGNED_EX&nbsp;&nbsp;&nbsp;21          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UMQ ULB only, means message was reassigned from a receiver. Event data holds message information. 
</div>
</div><p>
<a class="anchor" name="d1e214f4a013bcf2244772618c3ce44e"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UMQ_ULB_MESSAGE_REASSIGNED_EX_FLAG_EXPLICIT" ref="d1e214f4a013bcf2244772618c3ce44e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UMQ_ULB_MESSAGE_REASSIGNED_EX_FLAG_EXPLICIT&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reassignment is the result of the lbm_msg_umq_reassign API being called by a receiver 
</div>
</div><p>
<a class="anchor" name="6defdca03dccc09650911b703601e532"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UMQ_ULB_MESSAGE_TIMEOUT_EX" ref="6defdca03dccc09650911b703601e532" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UMQ_ULB_MESSAGE_TIMEOUT_EX&nbsp;&nbsp;&nbsp;22          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UMQ ULB only, means message timed out and was end-of-lifed. Event data holds message information. 
</div>
</div><p>
<a class="anchor" name="7f795726e8119ace7fb061a1afea47e2"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UMQ_ULB_MESSAGE_TIMEOUT_EX_FLAG_DISCARD" ref="7f795726e8119ace7fb061a1afea47e2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UMQ_ULB_MESSAGE_TIMEOUT_EX_FLAG_DISCARD&nbsp;&nbsp;&nbsp;0x4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
timeout is the result of the lbm_msg_umq_reassign API being called with the LBM_MSG_UMQ_REASSIGN_FLAG_DISCARD flag set 
</div>
</div><p>
<a class="anchor" name="10c3f354a4cd9d2ff3b03f58558d6b97"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UMQ_ULB_MESSAGE_TIMEOUT_EX_FLAG_EXPLICIT" ref="10c3f354a4cd9d2ff3b03f58558d6b97" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UMQ_ULB_MESSAGE_TIMEOUT_EX_FLAG_EXPLICIT&nbsp;&nbsp;&nbsp;0x2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
timeout is the result of the lbm_msg_umq_reassign API being called by a receiver 
</div>
</div><p>
<a class="anchor" name="f22450a211ef86eaa83aaa0f4c41876a"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UMQ_ULB_MESSAGE_TIMEOUT_EX_FLAG_MAX_REASSIGNS" ref="f22450a211ef86eaa83aaa0f4c41876a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UMQ_ULB_MESSAGE_TIMEOUT_EX_FLAG_MAX_REASSIGNS&nbsp;&nbsp;&nbsp;0x8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
timeout is the result of hitting umq_ulb_application_set_message_max_reassignments number of assignments 
</div>
</div><p>
<a class="anchor" name="8f49499d793faf9a36a19a4a522f4ff2"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UMQ_ULB_MESSAGE_TIMEOUT_EX_FLAG_TOTAL_LIFETIME_EXPIRED" ref="8f49499d793faf9a36a19a4a522f4ff2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UMQ_ULB_MESSAGE_TIMEOUT_EX_FLAG_TOTAL_LIFETIME_EXPIRED&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
timeout is the result of the total lifetime expiring 
</div>
</div><p>
<a class="anchor" name="3bbeb7b185382c984ae914eabeb38c1f"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UMQ_ULB_RECEIVER_DEREGISTRATION_EX" ref="3bbeb7b185382c984ae914eabeb38c1f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UMQ_ULB_RECEIVER_DEREGISTRATION_EX&nbsp;&nbsp;&nbsp;26          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UMQ ULB only, means receiver deregistered. Event data holds receiver information. 
</div>
</div><p>
<a class="anchor" name="4f1ebd4914b356901f6decd9fe7e31c2"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UMQ_ULB_RECEIVER_READY_EX" ref="4f1ebd4914b356901f6decd9fe7e31c2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UMQ_ULB_RECEIVER_READY_EX&nbsp;&nbsp;&nbsp;27          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UMQ ULB only, means receiver signalled ready for messages. Event data holds receiver information. 
</div>
</div><p>
<a class="anchor" name="79201bd07423ee41ed965fabe08f0e24"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UMQ_ULB_RECEIVER_REGISTRATION_EX" ref="79201bd07423ee41ed965fabe08f0e24" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UMQ_ULB_RECEIVER_REGISTRATION_EX&nbsp;&nbsp;&nbsp;25          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UMQ ULB only, means receiver registered. Event data holds receiver information. 
</div>
</div><p>
<a class="anchor" name="00bee6cad8e118c8d3846d9a36dd32e3"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_UMQ_ULB_RECEIVER_TIMEOUT_EX" ref="00bee6cad8e118c8d3846d9a36dd32e3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_UMQ_ULB_RECEIVER_TIMEOUT_EX&nbsp;&nbsp;&nbsp;28          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. For UMQ ULB only, means receiver timed out and was end-of-lifed. Event data holds receiver information. 
</div>
</div><p>
<a class="anchor" name="a905cb268bbee255c71b74694370fe61"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_WAKEUP" ref="a905cb268bbee255c71b74694370fe61" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_WAKEUP&nbsp;&nbsp;&nbsp;3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of source event. Following earlier return of LBM_EWOULDBLOCK, means source is ready for more sends 
</div>
</div><p>
<a class="anchor" name="80c462e977454baadb0e3ef0c8255105"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_WAKEUP_FLAG_MIM" ref="80c462e977454baadb0e3ef0c8255105" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_WAKEUP_FLAG_MIM&nbsp;&nbsp;&nbsp;0x2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unblocked source is a context-level multicast immediate mode source. 
</div>
</div><p>
<a class="anchor" name="f9d73f2362f2d1bed196801a79afc993"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_WAKEUP_FLAG_NORMAL" ref="f9d73f2362f2d1bed196801a79afc993" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_WAKEUP_FLAG_NORMAL&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unblocked source is a normal (or hot failover) source. 
</div>
</div><p>
<a class="anchor" name="e9bc7f5766b7c7eaf8829ee4c128cced"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_WAKEUP_FLAG_REQUEST" ref="e9bc7f5766b7c7eaf8829ee4c128cced" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_WAKEUP_FLAG_REQUEST&nbsp;&nbsp;&nbsp;0x8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unblocked source is a context-level request source. 
</div>
</div><p>
<a class="anchor" name="8281dbcdd348d03a6d7f7bc80bbbf650"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_WAKEUP_FLAG_RESPONSE" ref="8281dbcdd348d03a6d7f7bc80bbbf650" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_WAKEUP_FLAG_RESPONSE&nbsp;&nbsp;&nbsp;0x10          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unblocked source is a context-level response source. 
</div>
</div><p>
<a class="anchor" name="18d855a3d5a9eb39a9148020eca733d9"></a><!-- doxytag: member="lbm.h::LBM_SRC_EVENT_WAKEUP_FLAG_UIM" ref="18d855a3d5a9eb39a9148020eca733d9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_EVENT_WAKEUP_FLAG_UIM&nbsp;&nbsp;&nbsp;0x4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unblocked source is a context-level unicast immediate mode source. 
</div>
</div><p>
<a class="anchor" name="b8a470f02029480f179cc4872b7fa713"></a><!-- doxytag: member="lbm.h::LBM_SRC_NONBLOCK" ref="b8a470f02029480f179cc4872b7fa713" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_NONBLOCK&nbsp;&nbsp;&nbsp;0x8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flag passed to a source send call E.G. (<a class="el" href="lbm_8h.html#91f4b9cb04fe1323ec56833211cc5cb7" title="Send a message to the topic associated with a UM source.">lbm_src_send()</a>, <a class="el" href="lbm_8h.html#091b5806bf18d10ebd0d9117e0c70229" title="Extended send of a message to the topic associated with a UM source.">lbm_src_send_ex()</a> etc) : If message could not be sent immediately return and error and signal LBM_EWOULDBLOCK. 
</div>
</div><p>
<a class="anchor" name="71368905028cc0d6480c239a0228b49c"></a><!-- doxytag: member="lbm.h::LBM_SRC_SEND_EX_FLAG_APPHDR_CHAIN" ref="71368905028cc0d6480c239a0228b49c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_SEND_EX_FLAG_APPHDR_CHAIN&nbsp;&nbsp;&nbsp;0x8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send messages using an appheader chain 
</div>
</div><p>
<a class="anchor" name="148ccd9217cfe34e171c81c241f5375c"></a><!-- doxytag: member="lbm.h::LBM_SRC_SEND_EX_FLAG_CHANNEL" ref="148ccd9217cfe34e171c81c241f5375c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_SEND_EX_FLAG_CHANNEL&nbsp;&nbsp;&nbsp;0x20          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send messages using supplied channel information 
</div>
</div><p>
<a class="anchor" name="8fa0f4ed620fb82d08eec3f47db187be"></a><!-- doxytag: member="lbm.h::LBM_SRC_SEND_EX_FLAG_HF_32" ref="8fa0f4ed620fb82d08eec3f47db187be" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_SEND_EX_FLAG_HF_32&nbsp;&nbsp;&nbsp;0x400          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send message with the supplied 32 bit hot failover sequence number 
</div>
</div><p>
<a class="anchor" name="c8dc3937fb55c66c86180c0ce2285318"></a><!-- doxytag: member="lbm.h::LBM_SRC_SEND_EX_FLAG_HF_64" ref="c8dc3937fb55c66c86180c0ce2285318" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_SEND_EX_FLAG_HF_64&nbsp;&nbsp;&nbsp;0x800          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send message with the supplied 64 bit hot failover sequence number 
</div>
</div><p>
<a class="anchor" name="5bf62d916b1acee97156dc8077ac3584"></a><!-- doxytag: member="lbm.h::LBM_SRC_SEND_EX_FLAG_HF_OPTIONAL" ref="5bf62d916b1acee97156dc8077ac3584" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_SEND_EX_FLAG_HF_OPTIONAL&nbsp;&nbsp;&nbsp;0x100          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send messages marked as an optional message for Hot Failover 
</div>
</div><p>
<a class="anchor" name="169eb19b58d383875b718117b2def6e5"></a><!-- doxytag: member="lbm.h::LBM_SRC_SEND_EX_FLAG_PROPERTIES" ref="169eb19b58d383875b718117b2def6e5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_SEND_EX_FLAG_PROPERTIES&nbsp;&nbsp;&nbsp;0x200          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send message with the supplied messages properties 
</div>
</div><p>
<a class="anchor" name="b99586b3f3b469aa6f2e2da632fa5be0"></a><!-- doxytag: member="lbm.h::LBM_SRC_SEND_EX_FLAG_SEQUENCE_NUMBER_INFO" ref="b99586b3f3b469aa6f2e2da632fa5be0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_SEND_EX_FLAG_SEQUENCE_NUMBER_INFO&nbsp;&nbsp;&nbsp;0x2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inform application of the sequence numbers used for message 
</div>
</div><p>
<a class="anchor" name="e2b7b029ca6a3fcfc2cd67d809930a95"></a><!-- doxytag: member="lbm.h::LBM_SRC_SEND_EX_FLAG_SEQUENCE_NUMBER_INFO_FRAGONLY" ref="e2b7b029ca6a3fcfc2cd67d809930a95" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_SEND_EX_FLAG_SEQUENCE_NUMBER_INFO_FRAGONLY&nbsp;&nbsp;&nbsp;0x4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inform application of the sequence numbers used for message (fragmented messages only) 
</div>
</div><p>
<a class="anchor" name="781e689ed6e1178938dc0b2e2bfabc06"></a><!-- doxytag: member="lbm.h::LBM_SRC_SEND_EX_FLAG_UME_CLIENTD" ref="781e689ed6e1178938dc0b2e2bfabc06" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_SEND_EX_FLAG_UME_CLIENTD&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
UMP client data pointer is valid 
</div>
</div><p>
<a class="anchor" name="b5e0248995820580913a90b05ebd56ca"></a><!-- doxytag: member="lbm.h::LBM_SRC_SEND_EX_FLAG_UMQ_CLIENTD" ref="b5e0248995820580913a90b05ebd56ca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_SEND_EX_FLAG_UMQ_CLIENTD&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
UMQ client data pointer is valid 
</div>
</div><p>
<a class="anchor" name="01992618e0edcf2ca8aea4bc607c9d1e"></a><!-- doxytag: member="lbm.h::LBM_SRC_SEND_EX_FLAG_UMQ_INDEX" ref="01992618e0edcf2ca8aea4bc607c9d1e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_SEND_EX_FLAG_UMQ_INDEX&nbsp;&nbsp;&nbsp;0x40          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send messages associating them with the supplied UMQ Index 
</div>
</div><p>
<a class="anchor" name="3dced1476af472b3d4256a3d51683c4d"></a><!-- doxytag: member="lbm.h::LBM_SRC_SEND_EX_FLAG_UMQ_MESSAGE_ID_INFO" ref="3dced1476af472b3d4256a3d51683c4d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_SEND_EX_FLAG_UMQ_MESSAGE_ID_INFO&nbsp;&nbsp;&nbsp;0x10          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inform application of the UMQ Message ID used for the message 
</div>
</div><p>
<a class="anchor" name="a04727ba812d6da49d6a4af74f0aac6f"></a><!-- doxytag: member="lbm.h::LBM_SRC_SEND_EX_FLAG_UMQ_TOTAL_LIFETIME" ref="a04727ba812d6da49d6a4af74f0aac6f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_SRC_SEND_EX_FLAG_UMQ_TOTAL_LIFETIME&nbsp;&nbsp;&nbsp;0x80          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
umq_msg_total_lifetime is valid 
</div>
</div><p>
<a class="anchor" name="2d53d68f1969481af25a04c9f132408d"></a><!-- doxytag: member="lbm.h::LBM_TOPIC_RES_REQUEST_ADVERTISEMENT" ref="2d53d68f1969481af25a04c9f132408d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_TOPIC_RES_REQUEST_ADVERTISEMENT&nbsp;&nbsp;&nbsp;0x04          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flag passed to <a class="el" href="lbm_8h.html#e6dd7c56acf916ef66658cc1ebc7a525" title="Request Topic Advertisements (sources), Topic Queries (receivers), and/or Wildcard...">lbm_context_topic_resolution_request()</a> to request sources to re-advertise 
</div>
</div><p>
<a class="anchor" name="b00ed9cd0b3212bdde1b4aeaf6d0bb12"></a><!-- doxytag: member="lbm.h::LBM_TOPIC_RES_REQUEST_QUERY" ref="b00ed9cd0b3212bdde1b4aeaf6d0bb12" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_TOPIC_RES_REQUEST_QUERY&nbsp;&nbsp;&nbsp;0x02          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flag passed to <a class="el" href="lbm_8h.html#e6dd7c56acf916ef66658cc1ebc7a525" title="Request Topic Advertisements (sources), Topic Queries (receivers), and/or Wildcard...">lbm_context_topic_resolution_request()</a> to request receivers to query for source 
</div>
</div><p>
<a class="anchor" name="ab8c1c27f8edbea06cb38387b5146eb5"></a><!-- doxytag: member="lbm.h::LBM_TOPIC_RES_REQUEST_RESERVED1" ref="ab8c1c27f8edbea06cb38387b5146eb5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_TOPIC_RES_REQUEST_RESERVED1&nbsp;&nbsp;&nbsp;0x08          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reserved for internal use 
</div>
</div><p>
<a class="anchor" name="598fc36ad06eb844dcc9ff8107ad87dd"></a><!-- doxytag: member="lbm.h::LBM_TOPIC_RES_REQUEST_WILDCARD_QUERY" ref="598fc36ad06eb844dcc9ff8107ad87dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_TOPIC_RES_REQUEST_WILDCARD_QUERY&nbsp;&nbsp;&nbsp;0x01          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flag passed to <a class="el" href="lbm_8h.html#e6dd7c56acf916ef66658cc1ebc7a525" title="Request Topic Advertisements (sources), Topic Queries (receivers), and/or Wildcard...">lbm_context_topic_resolution_request()</a> to request wildcard receivers to query for source 
</div>
</div><p>
<a class="anchor" name="f2d3ee2ee236072c693d4854ea18fad2"></a><!-- doxytag: member="lbm.h::LBM_TRANSPORT_STAT_DAEMON" ref="f2d3ee2ee236072c693d4854ea18fad2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_TRANSPORT_STAT_DAEMON&nbsp;&nbsp;&nbsp;0xFF          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transport statistic type. UM Daemon is being used 
</div>
</div><p>
<a class="anchor" name="64de821cc3a1afda47c5668996d16d9b"></a><!-- doxytag: member="lbm.h::LBM_TRANSPORT_STAT_LBTIPC" ref="64de821cc3a1afda47c5668996d16d9b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_TRANSPORT_STAT_LBTIPC&nbsp;&nbsp;&nbsp;LBM_TRANSPORT_TYPE_LBTIPC          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transport statistic type. LBT-IPC transport 
</div>
</div><p>
<a class="anchor" name="b8fc2e2fb0287dfa80713fb8fb6c23df"></a><!-- doxytag: member="lbm.h::LBM_TRANSPORT_STAT_LBTRDMA" ref="b8fc2e2fb0287dfa80713fb8fb6c23df" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_TRANSPORT_STAT_LBTRDMA&nbsp;&nbsp;&nbsp;LBM_TRANSPORT_TYPE_LBTRDMA          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transport statistic type. LBT-RDMA transport 
</div>
</div><p>
<a class="anchor" name="32e0d3eee1fe69fa87e985f3343830b3"></a><!-- doxytag: member="lbm.h::LBM_TRANSPORT_STAT_LBTRM" ref="32e0d3eee1fe69fa87e985f3343830b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_TRANSPORT_STAT_LBTRM&nbsp;&nbsp;&nbsp;LBM_TRANSPORT_TYPE_LBTRM          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transport statistic type. LBT-RM transport 
</div>
</div><p>
<a class="anchor" name="1f4acd28e4192be6809ce2cc496cb514"></a><!-- doxytag: member="lbm.h::LBM_TRANSPORT_STAT_LBTRU" ref="1f4acd28e4192be6809ce2cc496cb514" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_TRANSPORT_STAT_LBTRU&nbsp;&nbsp;&nbsp;LBM_TRANSPORT_TYPE_LBTRU          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transport statistic type. LBT-RU transport 
</div>
</div><p>
<a class="anchor" name="6da60dbd4d5790ee0df30d6c3048f977"></a><!-- doxytag: member="lbm.h::LBM_TRANSPORT_STAT_TCP" ref="6da60dbd4d5790ee0df30d6c3048f977" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_TRANSPORT_STAT_TCP&nbsp;&nbsp;&nbsp;LBM_TRANSPORT_TYPE_TCP          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transport statistic type. TCP transport 
</div>
</div><p>
<a class="anchor" name="f267de2c80e4873002aa5814588cce81"></a><!-- doxytag: member="lbm.h::LBM_TRANSPORT_TYPE_LBTIPC" ref="f267de2c80e4873002aa5814588cce81" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_TRANSPORT_TYPE_LBTIPC&nbsp;&nbsp;&nbsp;0x40          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transport type LBT-IPC. 
</div>
</div><p>
<a class="anchor" name="79030d6b72ec8c7f4fd0450695876735"></a><!-- doxytag: member="lbm.h::LBM_TRANSPORT_TYPE_LBTRDMA" ref="79030d6b72ec8c7f4fd0450695876735" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_TRANSPORT_TYPE_LBTRDMA&nbsp;&nbsp;&nbsp;0x20          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transport type LBT-RDMA. 
</div>
</div><p>
<a class="anchor" name="baa12e19600af1560d72e4edd0175089"></a><!-- doxytag: member="lbm.h::LBM_TRANSPORT_TYPE_LBTRM" ref="baa12e19600af1560d72e4edd0175089" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_TRANSPORT_TYPE_LBTRM&nbsp;&nbsp;&nbsp;0x10          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transport type LBT-RM. 
</div>
</div><p>
<a class="anchor" name="5f0a2858a79f5865eb4df2c042e677c3"></a><!-- doxytag: member="lbm.h::LBM_TRANSPORT_TYPE_LBTRU" ref="5f0a2858a79f5865eb4df2c042e677c3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_TRANSPORT_TYPE_LBTRU&nbsp;&nbsp;&nbsp;0x01          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transport type LBT-RU. 
</div>
</div><p>
<a class="anchor" name="15f010b660c2d9093f2ff605b383da38"></a><!-- doxytag: member="lbm.h::LBM_TRANSPORT_TYPE_TCP" ref="15f010b660c2d9093f2ff605b383da38" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_TRANSPORT_TYPE_TCP&nbsp;&nbsp;&nbsp;0x00          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transport type TCP. 
</div>
</div><p>
<a class="anchor" name="4ebecbc385d1e8724495408b628c868e"></a><!-- doxytag: member="lbm.h::LBM_UMM_INFO_FLAGS_USE_SSL" ref="4ebecbc385d1e8724495408b628c868e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_UMM_INFO_FLAGS_USE_SSL&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Use SSL for UMM daemon connections. 
</div>
</div><p>
<a class="anchor" name="3cf89159246e4b3c518ae90a3f460ff9"></a><!-- doxytag: member="lbm.h::LBM_UMQ_INDEX_FLAG_NUMERIC" ref="3cf89159246e4b3c518ae90a3f460ff9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_UMQ_INDEX_FLAG_NUMERIC&nbsp;&nbsp;&nbsp;0x1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
lbm_umq_index_info_t flags. Index is a 64-bit unsigned integer. 
</div>
</div><p>
<a class="anchor" name="e764ea8abf227789ef8d44c6dee9625f"></a><!-- doxytag: member="lbm.h::LBM_WILDCARD_RCV_PATTERN_TYPE_APP_CB" ref="e764ea8abf227789ef8d44c6dee9625f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_WILDCARD_RCV_PATTERN_TYPE_APP_CB&nbsp;&nbsp;&nbsp;3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Application defined callback pattern type 
</div>
</div><p>
<a class="anchor" name="45694a07474901f236317f2160276a2a"></a><!-- doxytag: member="lbm.h::LBM_WILDCARD_RCV_PATTERN_TYPE_PCRE" ref="45694a07474901f236317f2160276a2a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_WILDCARD_RCV_PATTERN_TYPE_PCRE&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
PCRE (Perl Compatible Regular Expressions) pattern type 
</div>
</div><p>
<a class="anchor" name="ec2a243ccda8dec97432e5f4c4520ae5"></a><!-- doxytag: member="lbm.h::LBM_WILDCARD_RCV_PATTERN_TYPE_REGEX" ref="ec2a243ccda8dec97432e5f4c4520ae5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LBM_WILDCARD_RCV_PATTERN_TYPE_REGEX&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
POSIX regex pattern type 
</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="2dc2a08b3bc5b1f0904551b177101c27"></a><!-- doxytag: member="lbm.h::lbm_async_operation_function_cb" ref="2dc2a08b3bc5b1f0904551b177101c27" args="(lbm_async_operation_info_t *opinfo, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(*) <a class="el" href="lbm_8h.html#2dc2a08b3bc5b1f0904551b177101c27">lbm_async_operation_function_cb</a>(<a class="el" href="structlbm__async__operation__info__t.html">lbm_async_operation_info_t</a> *opinfo, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>opinfo</em>&nbsp;</td><td>Operation-specific results. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in in the <a class="el" href="structlbm__async__operation__func__t.html" title="Structure that holds information for asynchronous operation callbacks.">lbm_async_operation_func_t</a> struct passed in to an asynchronous API call. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success, -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="12c823d52cadbbfc9032c5338c077ceb"></a><!-- doxytag: member="lbm.h::lbm_context_event_cb_proc" ref="12c823d52cadbbfc9032c5338c077ceb" args="(lbm_context_t *ctx, int event, void *ed, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(*) <a class="el" href="lbm_8h.html#12c823d52cadbbfc9032c5338c077ceb">lbm_context_event_cb_proc</a>(lbm_context_t *ctx, int event, void *ed, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by the "context_event_function" context attribute. If this application callback is set without an event queue, it is called from the context thread and is limited in the API calls that it can make. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Context object generating the event. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>Type of event. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ed</em>&nbsp;</td><td>Pointer to event data, content dependent on event type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied when setting "context_event_function" context attribute. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 always </dd></dl>

</div>
</div><p>
<a class="anchor" name="2ad9c4d58e9129102d7d780b611c58b4"></a><!-- doxytag: member="lbm.h::lbm_context_event_func_t" ref="2ad9c4d58e9129102d7d780b611c58b4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__context__event__func__t__stct.html">lbm_context_event_func_t_stct</a>  <a class="el" href="structlbm__context__event__func__t__stct.html">lbm_context_event_func_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A struct used to set a context-level event callback and callback info. 
</div>
</div><p>
<a class="anchor" name="45a43eff8472d717cb984cad9b6c9bad"></a><!-- doxytag: member="lbm.h::lbm_context_event_umq_registration_complete_ex_t" ref="45a43eff8472d717cb984cad9b6c9bad" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__context__event__umq__registration__complete__ex__t__stct.html">lbm_context_event_umq_registration_complete_ex_t_stct</a>  <a class="el" href="structlbm__context__event__umq__registration__complete__ex__t__stct.html">lbm_context_event_umq_registration_complete_ex_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with UMQ receivers and sources to indicate successful context registration to quorum or to all queue instances involved. 
</div>
</div><p>
<a class="anchor" name="a8eab1f96d8ab2216a7cbe95abd06a20"></a><!-- doxytag: member="lbm.h::lbm_context_event_umq_registration_ex_t" ref="a8eab1f96d8ab2216a7cbe95abd06a20" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__context__event__umq__registration__ex__t__stct.html">lbm_context_event_umq_registration_ex_t_stct</a>  <a class="el" href="structlbm__context__event__umq__registration__ex__t__stct.html">lbm_context_event_umq_registration_ex_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with UMQ receivers and sources to indicate successful context registration with an instance of the queue. 
</div>
</div><p>
<a class="anchor" name="b9916750784e7d597e8e19580b9a0fe1"></a><!-- doxytag: member="lbm.h::lbm_context_rcv_immediate_msgs_func_t" ref="b9916750784e7d597e8e19580b9a0fe1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__context__rcv__immediate__msgs__func__t__stct.html">lbm_context_rcv_immediate_msgs_func_t_stct</a>  <a class="el" href="structlbm__context__rcv__immediate__msgs__func__t__stct.html">lbm_context_rcv_immediate_msgs_func_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A struct used to set the context-level topic-less immediate mode message receiver callback. If an event queue is specified, messages will be placed on the event queue; if evq is NULL, messages will be delivered directly from the context thread. 
</div>
</div><p>
<a class="anchor" name="6528467874659f28e2eccf1e1caf676b"></a><!-- doxytag: member="lbm.h::lbm_context_src_cb_proc" ref="6528467874659f28e2eccf1e1caf676b" args="(lbm_context_t *ctx, int event, void *ed, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(*) <a class="el" href="lbm_8h.html#6528467874659f28e2eccf1e1caf676b">lbm_context_src_cb_proc</a>(lbm_context_t *ctx, int event, void *ed, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by the "source_event_function" context attribute. If this application callback is set without an event queue, it is called from the context thread and is limited in the API calls that it can make. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Context object generating the event. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ed</em>&nbsp;</td><td>Pointer to event data, content dependent on event type. <ul>
<li>For <em>event</em> == LBM_SRC_EVENT_WAKEUP, <em>ed</em> should be re-cast as a (lbm_src_event_wakeup_t) and indicates which context-level source (or sources) has become un-blocked. </li>
<li>For <em>event</em> == LBM_SRC_EVENT_FLIGHT_SIZE_NOTIFICATION, <em>ed</em> should be re-cast as a (lbm_src_event_flight_size_notification_t *) to extract the flight size information. </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied when setting "source_event_function" context attribute. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 always </dd></dl>

</div>
</div><p>
<a class="anchor" name="9b7832bd627106205ba58ac151917b18"></a><!-- doxytag: member="lbm.h::lbm_context_src_event_func_t" ref="9b7832bd627106205ba58ac151917b18" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__context__src__event__func__t__stct.html">lbm_context_src_event_func_t_stct</a>  <a class="el" href="structlbm__context__src__event__func__t__stct.html">lbm_context_src_event_func_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A struct used to set a context-level source event callback and callback info. 
</div>
</div><p>
<a class="anchor" name="b86e72a3f715d7c8ddc49c6431455839"></a><!-- doxytag: member="lbm.h::lbm_context_stats_t" ref="b86e72a3f715d7c8ddc49c6431455839" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__context__stats__t__stct.html">lbm_context_stats_t_stct</a>  <a class="el" href="structlbm__context__stats__t__stct.html">lbm_context_stats_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This structure holds general context statistics for things like topic resolution and interaction with transports and applications. 
</div>
</div><p>
<a class="anchor" name="3d21707bec0da738e48a6166a56f3f06"></a><!-- doxytag: member="lbm.h::lbm_daemon_event_cb_proc" ref="3d21707bec0da738e48a6166a56f3f06" args="(lbm_context_t *ctx, int event, const char *info, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(*) <a class="el" href="lbm_8h.html#3d21707bec0da738e48a6166a56f3f06">lbm_daemon_event_cb_proc</a>(lbm_context_t *ctx, int event, const char *info, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by <a class="el" href="lbm_8h.html#8058947690bd0995bc2c59d4a61b462f" title="Create and initialize an lbm_context_t object.">lbm_context_create()</a>. Only used when operation_mode is set to daemon. NOTE: this application callback is always made from the context thread, and is therefore limited in the UM API calls it can make. NOTE: daemon mode is no longer available; this definition is retained for for backward compatibility only. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Context generating the event. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>One of LBM_DAEMON_EVENT_* indicating event type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>Pointer to LBM-supplied string giving more information. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in <a class="el" href="lbm_8h.html#8058947690bd0995bc2c59d4a61b462f" title="Create and initialize an lbm_context_t object.">lbm_context_create()</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 always. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8f700b98f4bbfb65ab0f12dc71a55083"></a><!-- doxytag: member="lbm.h::lbm_event_queue_cancel_cb_proc" ref="8f700b98f4bbfb65ab0f12dc71a55083" args="(int dispatch_thrd, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(*) <a class="el" href="lbm_8h.html#8f700b98f4bbfb65ab0f12dc71a55083">lbm_event_queue_cancel_cb_proc</a>(int dispatch_thrd, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by lbm_*_delete_ex(). NOTE: this application callback can be made from the context thread, and is therefore limited in the UM API calls it can make. The application is called after all events associated with the delete are canceled or completed. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#9e019e7c96360ebe45b985a3efbf8083" title="Structure passed to cancel/delete functions so that a cancel callback may be called...">lbm_event_queue_cancel_cb_info_t</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dispatch_thrd</em>&nbsp;</td><td>Indicates from where the callback is being called. This can be useful to the application to avoid deadlock. <ul>
<li>1 - Called by dispatch thread (after the lbm_*_delete_ex() returned). </li>
<li>0 - Called directly by the lbm_*_delete_ex() function. </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in the lbm_event_queue_cancel_cb_info_t passed to the lbm_*_delete_ex(). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 always. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1b4b56862044a11671aebac3ecd15b3a"></a><!-- doxytag: member="lbm.h::lbm_event_queue_monitor_proc" ref="1b4b56862044a11671aebac3ecd15b3a" args="(lbm_event_queue_t *evq, int event, size_t evq_size, lbm_ulong_t event_delay_usec, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(*) <a class="el" href="lbm_8h.html#1b4b56862044a11671aebac3ecd15b3a">lbm_event_queue_monitor_proc</a>(lbm_event_queue_t *evq, int event, size_t evq_size, lbm_ulong_t event_delay_usec, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by <a class="el" href="lbm_8h.html#c7ebe02319363c84bef08f34be7865ec" title="Create a UM event queue object.">lbm_event_queue_create()</a>. NOTE: this application callback can be made from the context thread, and is therefore limited in the UM API calls it can make. (Specifically, the context calls it for the enqueue notification.) Note that the one or more event queue options must be set to enable the use of event queue monitoring. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>Event queue generating the event. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>One of LBM_EVENT_QUEUE_*_WARNING or LBM_EVENT_QUEUE_ENQUEUE_NOTIFICATION, depending on enabled options. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>evq_size</em>&nbsp;</td><td>Number of events currently in the queue. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event_delay_usec</em>&nbsp;</td><td>Number of microseconds the oldest event has been in the event queue. (Note, this will be the next event dispatched.) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in <a class="el" href="lbm_8h.html#c7ebe02319363c84bef08f34be7865ec" title="Create a UM event queue object.">lbm_event_queue_create()</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for success, -1 for failure. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The <em>event</em> parameter operates as both a value and a bitmask, and the monitor function may be called to indicate both a size and delay warning. The value of <a class="el" href="lbm_8h.html#f0aeb1f5c969629a478e19f51913162e">LBM_EVENT_QUEUE_ENQUEUE_NOTIFICATION</a> is the same as the value of (<a class="el" href="lbm_8h.html#9bc366996c2e3fa52441096c2c322ca2">LBM_EVENT_QUEUE_DELAY_WARNING</a> | <a class="el" href="lbm_8h.html#8d104d87acef6f7b27b2ad111861df81">LBM_EVENT_QUEUE_SIZE_WARNING</a>). </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>If <em>event</em> is <a class="el" href="lbm_8h.html#f0aeb1f5c969629a478e19f51913162e">LBM_EVENT_QUEUE_ENQUEUE_NOTIFICATION</a>, <em>evq_size</em> is 1, and <em>evq_delay_usec</em> is 0, the callback is due to an event being enqueued. To distinguish between an enqueue notification and a size or delay warning, the following code template may be used. <div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> event_queue_monitor_proc(lbm_event_queue_t * evq, <span class="keywordtype">int</span> event,
    <span class="keywordtype">size_t</span> evq_size, lbm_ulong_t event_delay_usec, <span class="keywordtype">void</span> * clientd)
{
    <span class="keywordflow">if</span> ((event == <a class="code" href="lbm_8h.html#f0aeb1f5c969629a478e19f51913162e">LBM_EVENT_QUEUE_ENQUEUE_NOTIFICATION</a>)
        &amp;&amp; (evq_size == 1) &amp;&amp; (event_delay_usec == 0))
    {
        <span class="comment">// This is an ENQUEUE notification.</span>
        <span class="keywordflow">return</span> (0);
    }
    <span class="keywordflow">if</span> ((event &amp; <a class="code" href="lbm_8h.html#8d104d87acef6f7b27b2ad111861df81">LBM_EVENT_QUEUE_SIZE_WARNING</a>) != 0)
    {
        <span class="comment">// Size warning, event queue size is in evq_size</span>
    }
    <span class="keywordflow">if</span> ((event &amp; <a class="code" href="lbm_8h.html#9bc366996c2e3fa52441096c2c322ca2">LBM_EVENT_QUEUE_DELAY_WARNING</a>) != 0)
    {
        <span class="comment">// Delay warning, delay of oldest (about to be dequeued)</span>
        <span class="comment">// message is in event_delay_usec.</span>
    }
    <span class="keywordflow">return</span> (0);
}
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a533d6a23589618291f552e988a426f6"></a><!-- doxytag: member="lbm.h::lbm_event_queue_stats_t" ref="a533d6a23589618291f552e988a426f6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__event__queue__stats__t__stct.html">lbm_event_queue_stats_t_stct</a>  <a class="el" href="structlbm__event__queue__stats__t__stct.html">lbm_event_queue_stats_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This structure holds statistics for messages and other events that enter and exit the event queue. NOTE: Specific count-enable options must sometimes be enabled for these statistics to populate. 
</div>
</div><p>
<a class="anchor" name="0aa2a7e14eca4d75925063cac2ecd879"></a><!-- doxytag: member="lbm.h::lbm_fd_cb_proc" ref="0aa2a7e14eca4d75925063cac2ecd879" args="(lbm_context_t *ctx, lbm_handle_t handle, lbm_ulong_t ev, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(*) <a class="el" href="lbm_8h.html#0aa2a7e14eca4d75925063cac2ecd879">lbm_fd_cb_proc</a>(lbm_context_t *ctx, lbm_handle_t handle, lbm_ulong_t ev, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by <a class="el" href="lbm_8h.html#50d8ea5a6ebb5f1f0c6c5d9155c09657" title="Register a file descriptor/socket for events that calls proc when a given event occurs...">lbm_register_fd()</a>. If this application callback is set without an event queue, it is called from the context thread and is limited in the API calls that it can make. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Context monitoring the <em>handle</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>File descriptor or socket generating the event. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ev</em>&nbsp;</td><td>One or more of LBM_FD_EVENT_* (ORed together) indicating the event type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in <a class="el" href="lbm_8h.html#50d8ea5a6ebb5f1f0c6c5d9155c09657" title="Register a file descriptor/socket for events that calls proc when a given event occurs...">lbm_register_fd()</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 always. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c26b2f61ff3e92ff1e1b44f82bbf193b"></a><!-- doxytag: member="lbm.h::lbm_flight_size_set_inflight_cb_proc" ref="c26b2f61ff3e92ff1e1b44f82bbf193b" args="(int inflight, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(*) <a class="el" href="lbm_8h.html#c26b2f61ff3e92ff1e1b44f82bbf193b">lbm_flight_size_set_inflight_cb_proc</a>(int inflight, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by lbm_*_flight_size_set_inflight(). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inflight</em>&nbsp;</td><td>Gives the current inflight value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in the call to lbm_*_flight_size_set_inflight(). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The new inflight value. </dd></dl>

</div>
</div><p>
<a class="anchor" name="75319e63d9fa4e0f006918b91672f6b5"></a><!-- doxytag: member="lbm.h::lbm_flight_size_set_inflight_ex_cb_proc" ref="75319e63d9fa4e0f006918b91672f6b5" args="(lbm_flight_size_inflight_t *inflight, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(*) <a class="el" href="lbm_8h.html#75319e63d9fa4e0f006918b91672f6b5">lbm_flight_size_set_inflight_ex_cb_proc</a>(<a class="el" href="structlbm__flight__size__inflight__t__stct.html">lbm_flight_size_inflight_t</a> *inflight, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inflight</em>&nbsp;</td><td>Pointer to a structure containing current inflight values for both messages and bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in the call to lbm_ume_flight_size_set_inflight_ex(). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7947fbc8b37e649ff36cc9ca66ef2dc7"></a><!-- doxytag: member="lbm.h::lbm_immediate_msg_cb_proc" ref="7947fbc8b37e649ff36cc9ca66ef2dc7" args="(lbm_context_t *ctx, lbm_msg_t *msg, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(*) <a class="el" href="lbm_8h.html#7947fbc8b37e649ff36cc9ca66ef2dc7">lbm_immediate_msg_cb_proc</a>(lbm_context_t *ctx, <a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *msg, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by <a class="el" href="lbm_8h.html#374f135dddf7794130509f97b1e96cf8" title="Set the callback procedure and delivery method for non-topic immediate messages.">lbm_context_rcv_immediate_msgs()</a>. If this application callback is set without an event queue, it is called from the context thread and is limited in the API calls that it can make.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>For received application messages, be aware that UM does not guarantee any alignment of that data. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Context receiving the message. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Pointer to received message. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in <a class="el" href="lbm_8h.html#374f135dddf7794130509f97b1e96cf8" title="Set the callback procedure and delivery method for non-topic immediate messages.">lbm_context_rcv_immediate_msgs()</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 always. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0cc1e47e9e1aec978aaded128bb7ce55"></a><!-- doxytag: member="lbm.h::lbm_iovec_t" ref="0cc1e47e9e1aec978aaded128bb7ce55" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__iovec__t__stct.html">lbm_iovec_t_stct</a>  <a class="el" href="structlbm__iovec__t__stct.html">lbm_iovec_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
UM replacement for struct iovec for portability. 
</div>
</div><p>
<a class="anchor" name="0b66a5b33839617b2a822e4a20a8d535"></a><!-- doxytag: member="lbm.h::lbm_ipv4_address_mask_t" ref="0b66a5b33839617b2a822e4a20a8d535" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__ipv4__address__mask__t__stct.html">lbm_ipv4_address_mask_t_stct</a>  <a class="el" href="structlbm__ipv4__address__mask__t__stct.html">lbm_ipv4_address_mask_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with options to set/get specific addresses within a range. 
</div>
</div><p>
<a class="anchor" name="72ac99d9f07d98bfe2c7c5856d37c2d0"></a><!-- doxytag: member="lbm.h::lbm_log_cb_proc" ref="72ac99d9f07d98bfe2c7c5856d37c2d0" args="(int level, const char *message, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(*) <a class="el" href="lbm_8h.html#72ac99d9f07d98bfe2c7c5856d37c2d0">lbm_log_cb_proc</a>(int level, const char *message, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by <a class="el" href="lbm_8h.html#ae14099b91f2919f424e81f20ca10951" title="Set a callback function to be called for UM log messages (warnings, notices, etc...">lbm_log()</a>. NOTE: this application callback can be made from the context thread, and is therefore limited in the UM API calls it can make. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>One of LBM_LOG_* indicating severity level. Values can be (in order of decreasing importance): <ul>
<li>LBM_LOG_EMERG </li>
<li>LBM_LOG_ALERT </li>
<li>LBM_LOG_CRIT </li>
<li>LBM_LOG_ERR </li>
<li>LBM_LOG_WARNING </li>
<li>LBM_LOG_NOTICE </li>
<li>LBM_LOG_INFO </li>
<li>LBM_LOG_DEBUG </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>message</em>&nbsp;</td><td>Pointer to error message string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in <a class="el" href="lbm_8h.html#ae14099b91f2919f424e81f20ca10951" title="Set a callback function to be called for UM log messages (warnings, notices, etc...">lbm_log()</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 always. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5fdd36ef808e7589c75fa9e7406cf5bf"></a><!-- doxytag: member="lbm.h::lbm_mim_unrecloss_func_t" ref="5fdd36ef808e7589c75fa9e7406cf5bf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__mim__unrecloss__func__t__stct.html">lbm_mim_unrecloss_func_t_stct</a>  <a class="el" href="structlbm__mim__unrecloss__func__t__stct.html">lbm_mim_unrecloss_func_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with options to set/get a specific callback function 
</div>
</div><p>
<a class="anchor" name="092915cccebd4e51e8128588f4439f63"></a><!-- doxytag: member="lbm.h::lbm_mim_unrecloss_function_cb" ref="092915cccebd4e51e8128588f4439f63" args="(const char *source_name, lbm_uint_t seqnum, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(*) <a class="el" href="lbm_8h.html#092915cccebd4e51e8128588f4439f63">lbm_mim_unrecloss_function_cb</a>(const char *source_name, lbm_uint_t seqnum, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by <a class="el" href="lbm_8h.html#b67f641d5a0ad1a9fe53d415da58d961" title="Set an option for the given UM context attribute.">lbm_context_attr_setopt()</a> with option "mim_unrecoverable_loss_function". NOTE: this application callback is always made from the context thread and is therefore limited in the UM API calls it can make. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#5fdd36ef808e7589c75fa9e7406cf5bf" title="Structure that holds the application callback for multicast immediate message unrecoverable...">lbm_mim_unrecloss_func_t</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source_name</em>&nbsp;</td><td>Name of the source </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>seqnum</em>&nbsp;</td><td>Sequence Number that is lost </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in the lbm_mim_unrecloss_func_t passed to <a class="el" href="lbm_8h.html#b67f641d5a0ad1a9fe53d415da58d961" title="Set an option for the given UM context attribute.">lbm_context_attr_setopt()</a> with the "mim_unrecoverable_loss_function" attribute. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 always. </dd></dl>

</div>
</div><p>
<a class="anchor" name="92eeef15a938f250c05c436c52960055"></a><!-- doxytag: member="lbm.h::lbm_msg_channel_info_t" ref="92eeef15a938f250c05c436c52960055" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__msg__channel__info__t__stct.html">lbm_msg_channel_info_t_stct</a>  <a class="el" href="structlbm__msg__channel__info__t__stct.html">lbm_msg_channel_info_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This channel information assigns a channel designator to individual messages. Receivers may use this channel designator to filter messages or direct them to specific callbacks on a per-channel basis. 
</div>
</div><p>
<a class="anchor" name="5e2b10a2d5dd362cf4852ca9b99302a7"></a><!-- doxytag: member="lbm.h::lbm_msg_fragment_info_t" ref="5e2b10a2d5dd362cf4852ca9b99302a7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__msg__fragment__info__t__stct.html">lbm_msg_fragment_info_t_stct</a>  <a class="el" href="structlbm__msg__fragment__info__t__stct.html">lbm_msg_fragment_info_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
To retrieve the UM-message fragment information held in this structure, it is typically necessary to call <a class="el" href="lbm_8h.html#fa760960c21f502a8cb4c5ec5d97f91b" title="Returns 1 if lbm message is a fragment, else 0 is returned.">lbm_msg_retrieve_fragment_info()</a>. 
</div>
</div><p>
<a class="anchor" name="a7855ba983aeb84b6e00a38c827e5c0d"></a><!-- doxytag: member="lbm.h::lbm_msg_gateway_info_t" ref="a7855ba983aeb84b6e00a38c827e5c0d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__msg__gateway__info__t__stct.html">lbm_msg_gateway_info_t_stct</a>  <a class="el" href="structlbm__msg__gateway__info__t__stct.html">lbm_msg_gateway_info_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="6d5e0cfca8c0720107c6d592c32d5144"></a><!-- doxytag: member="lbm.h::lbm_msg_ume_deregistration_ex_t" ref="6d5e0cfca8c0720107c6d592c32d5144" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__msg__ume__deregistration__ex__t__stct.html">lbm_msg_ume_deregistration_ex_t_stct</a>  <a class="el" href="structlbm__msg__ume__deregistration__ex__t__stct.html">lbm_msg_ume_deregistration_ex_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with UM receivers to indicate successful deregistration (extended form). 
</div>
</div><p>
<a class="anchor" name="d9ba4ab7929365987c9f7ed17554d498"></a><!-- doxytag: member="lbm.h::lbm_msg_ume_registration_complete_ex_t" ref="d9ba4ab7929365987c9f7ed17554d498" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__msg__ume__registration__complete__ex__t__stct.html">lbm_msg_ume_registration_complete_ex_t_stct</a>  <a class="el" href="structlbm__msg__ume__registration__complete__ex__t__stct.html">lbm_msg_ume_registration_complete_ex_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with UM receivers to indicate successful registration to quorum or to all stores involved. 
</div>
</div><p>
<a class="anchor" name="2a896740a179ab09f615c632776db385"></a><!-- doxytag: member="lbm.h::lbm_msg_ume_registration_ex_t" ref="2a896740a179ab09f615c632776db385" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__msg__ume__registration__ex__t__stct.html">lbm_msg_ume_registration_ex_t_stct</a>  <a class="el" href="structlbm__msg__ume__registration__ex__t__stct.html">lbm_msg_ume_registration_ex_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with UM receivers to indicate successful registration (extended form). 
</div>
</div><p>
<a class="anchor" name="96d698804703ba4a5af6270e3793e701"></a><!-- doxytag: member="lbm.h::lbm_msg_ume_registration_t" ref="96d698804703ba4a5af6270e3793e701" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__msg__ume__registration__t__stct.html">lbm_msg_ume_registration_t_stct</a>  <a class="el" href="structlbm__msg__ume__registration__t__stct.html">lbm_msg_ume_registration_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with UMP receivers to indicate successful registration. 
</div>
</div><p>
<a class="anchor" name="6125b2ab298fa345efc869b6e7ff4a06"></a><!-- doxytag: member="lbm.h::lbm_msg_umq_deregistration_complete_ex_t" ref="6125b2ab298fa345efc869b6e7ff4a06" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__msg__umq__deregistration__complete__ex__t__stct.html">lbm_msg_umq_deregistration_complete_ex_t_stct</a>  <a class="el" href="structlbm__msg__umq__deregistration__complete__ex__t__stct.html">lbm_msg_umq_deregistration_complete_ex_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A struct used with UMQ receivers to indicate successful de-registration from a queue. 
</div>
</div><p>
<a class="anchor" name="ce36a383619fc391d14538c4ff0ff778"></a><!-- doxytag: member="lbm.h::lbm_msg_umq_index_assigned_ex_t" ref="ce36a383619fc391d14538c4ff0ff778" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__msg__umq__index__assigned__ex__t__stct.html">lbm_msg_umq_index_assigned_ex_t_stct</a>  <a class="el" href="structlbm__msg__umq__index__assigned__ex__t__stct.html">lbm_msg_umq_index_assigned_ex_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with UMQ or ULB receivers to indicate the stop of index assignment from all queue instances involved. 
</div>
</div><p>
<a class="anchor" name="fec7b685110ce840e10af3f1a6ed3744"></a><!-- doxytag: member="lbm.h::lbm_msg_umq_index_assignment_eligibility_start_complete_ex_t" ref="fec7b685110ce840e10af3f1a6ed3744" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__msg__umq__index__assignment__eligibility__start__complete__ex__t__stct.html">lbm_msg_umq_index_assignment_eligibility_start_complete_ex_t_stct</a>  <a class="el" href="structlbm__msg__umq__index__assignment__eligibility__start__complete__ex__t__stct.html">lbm_msg_umq_index_assignment_eligibility_start_complete_ex_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with UMQ or ULB receivers to indicate the start of index assignment from all queue instances involved. 
</div>
</div><p>
<a class="anchor" name="58ad1eb9891440c64aed45631e54be2c"></a><!-- doxytag: member="lbm.h::lbm_msg_umq_index_assignment_eligibility_stop_complete_ex_t" ref="58ad1eb9891440c64aed45631e54be2c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__msg__umq__index__assignment__eligibility__stop__complete__ex__t__stct.html">lbm_msg_umq_index_assignment_eligibility_stop_complete_ex_t_stct</a>  <a class="el" href="structlbm__msg__umq__index__assignment__eligibility__stop__complete__ex__t__stct.html">lbm_msg_umq_index_assignment_eligibility_stop_complete_ex_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with UMQ or ULB receivers to indicate the stop of index assignment from all queue instances involved. 
</div>
</div><p>
<a class="anchor" name="70be7bc53ea59eed65c220f7c0189f73"></a><!-- doxytag: member="lbm.h::lbm_msg_umq_index_released_ex_t" ref="70be7bc53ea59eed65c220f7c0189f73" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__msg__umq__index__released__ex__t__stct.html">lbm_msg_umq_index_released_ex_t_stct</a>  <a class="el" href="structlbm__msg__umq__index__released__ex__t__stct.html">lbm_msg_umq_index_released_ex_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with UMQ or ULB receivers to indicate the stop of index assignment from all queue instances involved. 
</div>
</div><p>
<a class="anchor" name="0c64df03275aad96fb201948e3fb26c6"></a><!-- doxytag: member="lbm.h::lbm_msg_umq_registration_complete_ex_t" ref="0c64df03275aad96fb201948e3fb26c6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__msg__umq__registration__complete__ex__t__stct.html">lbm_msg_umq_registration_complete_ex_t_stct</a>  <a class="el" href="structlbm__msg__umq__registration__complete__ex__t__stct.html">lbm_msg_umq_registration_complete_ex_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with UMQ receivers to indicate successful receiver registration to quorum or to all queue instances involved. 
</div>
</div><p>
<a class="anchor" name="e2d650dd4830971ca0b6197298eddcdd"></a><!-- doxytag: member="lbm.h::lbm_rcv_cb_proc" ref="e2d650dd4830971ca0b6197298eddcdd" args="(lbm_rcv_t *rcv, lbm_msg_t *msg, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(*) <a class="el" href="lbm_8h.html#e2d650dd4830971ca0b6197298eddcdd">lbm_rcv_cb_proc</a>(lbm_rcv_t *rcv, <a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *msg, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by <a class="el" href="lbm_8h.html#a7491c50fefbc2b70f8035fce7ac1477" title="Create a UM receiver that will receive messages sent to the given topic.">lbm_rcv_create()</a>. If this application callback is set without an event queue, it is called from the context thread and is limited in the API calls that it can make.<p>
After the callback returns, the message object <em>msg</em> is deleted and the application must not refer to it. This behavior can be overridden by calling <a class="el" href="lbm_8h.html#2b7788ff58f9e78bc89ea890dad0cccf" title="Instruct UM that the API is going to retain ownership of a UM message object.">lbm_msg_retain()</a> from the receive callback before it returns. It then becomes the application's responsibility to delete the message object using <a class="el" href="lbm_8h.html#a5fc1eb324a55b8c800c31460b0f0116" title="Delete a UM message object.">lbm_msg_delete()</a>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>For received application messages, be aware that UM does not guarantee any alignment of that data. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>Receiver object generating the event. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Message object containing the receiver event. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in <a class="el" href="lbm_8h.html#a7491c50fefbc2b70f8035fce7ac1477" title="Create a UM receiver that will receive messages sent to the given topic.">lbm_rcv_create()</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 always. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c58e7da14fdce3af9f20478cf87da125"></a><!-- doxytag: member="lbm.h::lbm_rcv_src_notification_create_function_cb" ref="c58e7da14fdce3af9f20478cf87da125" args="(const char *source_name, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void*(*) <a class="el" href="lbm_8h.html#c58e7da14fdce3af9f20478cf87da125">lbm_rcv_src_notification_create_function_cb</a>(const char *source_name, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by <a class="el" href="lbm_8h.html#1afc75f0fb3601d072b3463e7acf16a6" title="Set an option value within the given receiver topic attribute.">lbm_rcv_topic_attr_setopt()</a> with option "source_notification_function". NOTE: this application callback is always made from the context thread and is therefore limited in the UM API calls it can make. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#45be527ef7ef03b53afd4b193558107f" title="Structure that holds the application callback for source status notifications for...">lbm_rcv_src_notification_func_t</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source_name</em>&nbsp;</td><td>Name of the source </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in the lbm_rcv_src_notification_func_t passed to <a class="el" href="lbm_8h.html#b67f641d5a0ad1a9fe53d415da58d961" title="Set an option for the given UM context attribute.">lbm_context_attr_setopt()</a> with the "source_notification_function" attribute. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>void pointer to be set for all messages to this topic from the specified source. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3763fcb07ba3693804a63f6416e3e045"></a><!-- doxytag: member="lbm.h::lbm_rcv_src_notification_delete_function_cb" ref="3763fcb07ba3693804a63f6416e3e045" args="(const char *source_name, void *clientd, void *source_clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(*) <a class="el" href="lbm_8h.html#3763fcb07ba3693804a63f6416e3e045">lbm_rcv_src_notification_delete_function_cb</a>(const char *source_name, void *clientd, void *source_clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by <a class="el" href="lbm_8h.html#1afc75f0fb3601d072b3463e7acf16a6" title="Set an option value within the given receiver topic attribute.">lbm_rcv_topic_attr_setopt()</a> with option "source_notification_function". NOTE: this application callback is always made from the context thread and is therefore limited in the UM API calls it can make. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#45be527ef7ef03b53afd4b193558107f" title="Structure that holds the application callback for source status notifications for...">lbm_rcv_src_notification_func_t</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source_name</em>&nbsp;</td><td>Name of the source </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in the lbm_rcv_src_notification_func_t passed to <a class="el" href="lbm_8h.html#b67f641d5a0ad1a9fe53d415da58d961" title="Set an option for the given UM context attribute.">lbm_context_attr_setopt()</a> with the "source_notification_function" attribute. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source_clientd</em>&nbsp;</td><td>Client data pointer set to be included in each message. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 always </dd></dl>

</div>
</div><p>
<a class="anchor" name="45be527ef7ef03b53afd4b193558107f"></a><!-- doxytag: member="lbm.h::lbm_rcv_src_notification_func_t" ref="45be527ef7ef03b53afd4b193558107f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__rcv__src__notification__func__t__stct.html">lbm_rcv_src_notification_func_t_stct</a>  <a class="el" href="structlbm__rcv__src__notification__func__t__stct.html">lbm_rcv_src_notification_func_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with options to set/get a specific callback function 
</div>
</div><p>
<a class="anchor" name="a1aa4094d297eacd2752ab472b7a8956"></a><!-- doxytag: member="lbm.h::lbm_rcv_transport_stats_daemon_t" ref="a1aa4094d297eacd2752ab472b7a8956" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__rcv__transport__stats__daemon__t__stct.html">lbm_rcv_transport_stats_daemon_t_stct</a>  <a class="el" href="structlbm__rcv__transport__stats__daemon__t__stct.html">lbm_rcv_transport_stats_daemon_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This structure holds statistics for receiver transports using the daemon mode. NOTE: daemon mode is deprecated and no longer available; this structure is retained for for backward compatibility only. 
</div>
</div><p>
<a class="anchor" name="9bdc2628dece44f0675b0bdebfb3d52c"></a><!-- doxytag: member="lbm.h::lbm_rcv_transport_stats_t" ref="9bdc2628dece44f0675b0bdebfb3d52c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__rcv__transport__stats__t__stct.html">lbm_rcv_transport_stats_t_stct</a>  <a class="el" href="structlbm__rcv__transport__stats__t__stct.html">lbm_rcv_transport_stats_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This structure holds statistics for all receiver transports. The structure is filled in when statistics for receiver transports are requested. 
</div>
</div><p>
<a class="anchor" name="f3ef4385bc929e8a7ff94acbeb1eef75"></a><!-- doxytag: member="lbm.h::lbm_request_cb_proc" ref="f3ef4385bc929e8a7ff94acbeb1eef75" args="(lbm_request_t *req, lbm_msg_t *msg, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(*) <a class="el" href="lbm_8h.html#f3ef4385bc929e8a7ff94acbeb1eef75">lbm_request_cb_proc</a>(lbm_request_t *req, <a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *msg, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by <a class="el" href="lbm_8h.html#d4d06f66b8404684e191ca178e0cc09b" title="Send a request on the given src that contains the given data.">lbm_send_request()</a>, <a class="el" href="lbm_8h.html#54f3933e4dd154a9c7bb72598d0d9ef1" title="Multicast an immediate request to the target and topic. Note that immediate messages...">lbm_multicast_immediate_request()</a>, <a class="el" href="lbm_8h.html#e011c7a66e1db1f012d7f9633dbd321d" title="Unicast an immediate request to the target and topic. Note that immediate messages...">lbm_unicast_immediate_request()</a>. If this application callback is set without an event queue, it is called from the context thread and is limited in the API calls that it can make.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>For received application messages, be aware that UM does not guarantee any alignment of that data. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>req</em>&nbsp;</td><td>Request object receiving the response. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Pointer to received message. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in <a class="el" href="lbm_8h.html#d4d06f66b8404684e191ca178e0cc09b" title="Send a request on the given src that contains the given data.">lbm_send_request()</a>, etc. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 always. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7503c005ce424fa049494e37b708d396"></a><!-- doxytag: member="lbm.h::lbm_src_cb_proc" ref="7503c005ce424fa049494e37b708d396" args="(lbm_src_t *src, int event, void *ed, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(*) <a class="el" href="lbm_8h.html#7503c005ce424fa049494e37b708d396">lbm_src_cb_proc</a>(lbm_src_t *src, int event, void *ed, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by <a class="el" href="lbm_8h.html#b8dd76271bf9df7a5f88476d431f523e" title="Create a UM source that will send messages to the given topic.">lbm_src_create()</a> and <a class="el" href="lbm_8h.html#b5f6226d21dd4294bbad7d9f3e7c0bf6" title="Create a UM Hot Failover (HF) source that will send messages to the given topic....">lbm_hf_src_create()</a>. If this application callback is set without an event queue, it is called from the context thread and is limited in the API calls that it can make. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Source object generating the event. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event</em>&nbsp;</td><td>One of LBM_SRC_EVENT_* indicating event type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ed</em>&nbsp;</td><td>Pointer to event data, content dependent on event type. <ul>
<li>For <em>event</em> == LBM_SRC_EVENT_CONNECT (not applicable for LBT-RM), <em>ed</em> should be re-cast as a (char *) and points at the receiver as a string. Format depends on transport type. Formats containing IP address and Port pertain to the receiver's IP and Port. For string formats and examples, see <a class="el" href="structlbm__transport__source__info__t__stct.html" title="Structure that holds formatted and parsed transport source strings.">lbm_transport_source_info_t_stct</a>. </li>
<li>For <em>event</em> == LBM_SRC_EVENT_DISCONNECT (not applicable for LBT-RM), <em>ed</em> should be re-cast as a (char *) and points at the receiver as a string (see above). </li>
<li>For <em>event</em> == LBM_SRC_EVENT_WAKEUP, <em>ed</em> should be re-cast as a (lbm_src_event_wakeup_t) and indicates which source has become un-blocked. </li>
<li>For <em>event</em> == LBM_SRC_EVENT_SEQUENCE_NUMBER_INFO, <em>ed</em> should be re-cast as a (lbm_src_event_sequence_number_info_t *) to extract the sequence number information. </li>
<li>For <em>event</em> == LBM_SRC_EVENT_UME_REGISTRATION_ERROR, <em>ed</em> should be re-cast as a (const char *) to extract the error message. </li>
<li>For <em>event</em> == LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS, <em>ed</em> should be re-cast as a (lbm_src_event_ume_registration_t *) to extract the registration information. </li>
<li>For <em>event</em> == LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX, <em>ed</em> should be re-cast as a (lbm_src_event_ume_registration_ex_t *) to extract the extra registration information. </li>
<li>For <em>event</em> == LBM_SRC_EVENT_UME_REGISTRATION_COMPLETE_EX, <em>ed</em> should be re-cast as a (lbm_src_event_ume_registration_complete_ex_t *) to extract the extra registration completion information. </li>
<li>For <em>event</em> == LBM_SRC_EVENT_UME_MESSAGE_STABLE, <em>ed</em> should be re-cast as a (lbm_src_event_ume_ack_info_t *) to extract the UMP message acknowledgment information. </li>
<li>For <em>event</em> == LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX, <em>ed</em> should be re-cast as a (lbm_src_event_ume_ack_ex_info_t *) to extract the extra UMP message acknowledgment information. </li>
<li>For <em>event</em> == LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION, <em>ed</em> should be re-cast as a (lbm_src_event_ume_ack_info_t *) to extract the UMP message acknowledgment information. </li>
<li>For <em>event</em> == LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX, <em>ed</em> should be re-cast as a (lbm_src_event_ume_ack_ex_info_t *) to extract the extra UMP message acknowledgment information. </li>
<li>For <em>event</em> == LBM_SRC_EVENT_UME_MESSAGE_RECLAIMED, <em>ed</em> should be re-cast as a (lbm_src_event_ume_ack_info_t *) to extract the UMP message acknowledgment information. </li>
<li>For <em>event</em> == LBM_SRC_EVENT_UME_STORE_UNRESPONSIVE, <em>ed</em> should be re-cast as a (const char *) to extract the UMP store name. </li>
<li>For <em>event</em> == LBM_SRC_EVENT_FLIGHT_SIZE_NOTIFICATION, <em>ed</em> should be re-cast as a (lbm_src_event_flight_size_notification_t *) to extract the flight size information. </li>
<li>For <em>event</em> == LBM_SRC_EVENT_UME_MESSAGE_RECLAIMED_EX, <em>ed</em> should be re-cast as a (lbm_src_event_ume_ack_ex_info_t *) to extract the UMP message acknowledgment information. </li>
<li>For all other event types, <em>ed</em> contains nothing and should be ignored. </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in <a class="el" href="lbm_8h.html#b8dd76271bf9df7a5f88476d431f523e" title="Create a UM source that will send messages to the given topic.">lbm_src_create()</a>, etc. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 always </dd></dl>

</div>
</div><p>
<a class="anchor" name="3ee96b453b592c6f94c6fb65fcb5adcb"></a><!-- doxytag: member="lbm.h::lbm_src_cost_function_cb" ref="3ee96b453b592c6f94c6fb65fcb5adcb" args="(const char *topic, const lbm_transport_source_info_t *transport, lbm_uint32_t hop_count, lbm_uint32_t cost, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef lbm_uint32_t(*) <a class="el" href="lbm_8h.html#3ee96b453b592c6f94c6fb65fcb5adcb">lbm_src_cost_function_cb</a>(const char *topic, const <a class="el" href="structlbm__transport__source__info__t__stct.html">lbm_transport_source_info_t</a> *transport, lbm_uint32_t hop_count, lbm_uint32_t cost, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set via the "source_cost_evaluation_function" context attribute. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>topic</em>&nbsp;</td><td>Topic for which the new source was discovered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>transport</em>&nbsp;</td><td>Pointer to a <a class="el" href="lbm_8h.html#07f7bc3e6e4fe05c89ff2c3e4e6aa489" title="Structure that holds formatted and parsed transport source strings.">lbm_transport_source_info_t</a>, describing the transport session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hop_count</em>&nbsp;</td><td>Current hop count for the transport session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cost</em>&nbsp;</td><td>Current cumulative cost for the transport session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied when setting "source_cost_evaluation_function" context attribute. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Application-determined cost for this source as an unsigned 32-bit number. To permanently reject this source, return <a class="el" href="lbm_8h.html#ede9b7b462cd83fd6e46346260a134ca">LBM_SRC_COST_FUNCTION_REJECT</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1c4371e4c1113403ea0fb11bce39491f"></a><!-- doxytag: member="lbm.h::lbm_src_event_flight_size_notification_t" ref="1c4371e4c1113403ea0fb11bce39491f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__src__event__flight__size__notification__t__stct.html">lbm_src_event_flight_size_notification_t_stct</a>  <a class="el" href="structlbm__src__event__flight__size__notification__t__stct.html">lbm_src_event_flight_size_notification_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used to indicate a state change in flight size status 
</div>
</div><p>
<a class="anchor" name="207823d3c63aea90d4865b641839c259"></a><!-- doxytag: member="lbm.h::lbm_src_event_sequence_number_info_t" ref="207823d3c63aea90d4865b641839c259" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__src__event__sequence__number__info__t__stct.html">lbm_src_event_sequence_number_info_t_stct</a>  <a class="el" href="structlbm__src__event__sequence__number__info__t__stct.html">lbm_src_event_sequence_number_info_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with UM sources that informs the application the sequence numbers used with a message.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#091b5806bf18d10ebd0d9117e0c70229" title="Extended send of a message to the topic associated with a UM source.">lbm_src_send_ex</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7b945939b994bf1e7163d55b2256f3fb"></a><!-- doxytag: member="lbm.h::lbm_src_event_ume_ack_ex_info_t" ref="7b945939b994bf1e7163d55b2256f3fb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__src__event__ume__ack__ex__info__t__stct.html">lbm_src_event_ume_ack_ex_info_t_stct</a>  <a class="el" href="structlbm__src__event__ume__ack__ex__info__t__stct.html">lbm_src_event_ume_ack_ex_info_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with UMP sources to indicate message acknowledgment by the store and UMP receivers (extended form). 
</div>
</div><p>
<a class="anchor" name="cedfa758947867f55085a48150f9a17d"></a><!-- doxytag: member="lbm.h::lbm_src_event_ume_ack_info_t" ref="cedfa758947867f55085a48150f9a17d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__src__event__ume__ack__info__t__stct.html">lbm_src_event_ume_ack_info_t_stct</a>  <a class="el" href="structlbm__src__event__ume__ack__info__t__stct.html">lbm_src_event_ume_ack_info_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with UMP sources to indicate message acknowledgment by the store and UMP receivers. 
</div>
</div><p>
<a class="anchor" name="5ef1981e96c8f4a3f4c7b75aee02ffab"></a><!-- doxytag: member="lbm.h::lbm_src_event_ume_deregistration_ex_t" ref="5ef1981e96c8f4a3f4c7b75aee02ffab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__src__event__ume__deregistration__ex__t__stct.html">lbm_src_event_ume_deregistration_ex_t_stct</a>  <a class="el" href="structlbm__src__event__ume__deregistration__ex__t__stct.html">lbm_src_event_ume_deregistration_ex_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with UMP sources to indicate successful deregistration (extended form). 
</div>
</div><p>
<a class="anchor" name="6882015f7887a89297176d3af343679c"></a><!-- doxytag: member="lbm.h::lbm_src_event_ume_registration_complete_ex_t" ref="6882015f7887a89297176d3af343679c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__src__event__ume__registration__complete__ex__t__stct.html">lbm_src_event_ume_registration_complete_ex_t_stct</a>  <a class="el" href="structlbm__src__event__ume__registration__complete__ex__t__stct.html">lbm_src_event_ume_registration_complete_ex_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with UMP sources to indicate successful registration to quorum or to all stores involved. 
</div>
</div><p>
<a class="anchor" name="008e15024174fd5d7645ced0d2e64d2c"></a><!-- doxytag: member="lbm.h::lbm_src_event_ume_registration_ex_t" ref="008e15024174fd5d7645ced0d2e64d2c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__src__event__ume__registration__ex__t__stct.html">lbm_src_event_ume_registration_ex_t_stct</a>  <a class="el" href="structlbm__src__event__ume__registration__ex__t__stct.html">lbm_src_event_ume_registration_ex_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with UMP sources to indicate successful registration (extended form). 
</div>
</div><p>
<a class="anchor" name="b7fc3babd8a74705e4308cd316aa936a"></a><!-- doxytag: member="lbm.h::lbm_src_event_ume_registration_t" ref="b7fc3babd8a74705e4308cd316aa936a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__src__event__ume__registration__t__stct.html">lbm_src_event_ume_registration_t_stct</a>  <a class="el" href="structlbm__src__event__ume__registration__t__stct.html">lbm_src_event_ume_registration_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with UMP sources to indicate successful registration. 
</div>
</div><p>
<a class="anchor" name="6afbb8091fbcb687199349516d5f9f7e"></a><!-- doxytag: member="lbm.h::lbm_src_event_umq_message_id_info_t" ref="6afbb8091fbcb687199349516d5f9f7e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__src__event__umq__message__id__info__t__stct.html">lbm_src_event_umq_message_id_info_t_stct</a>  <a class="el" href="structlbm__src__event__umq__message__id__info__t__stct.html">lbm_src_event_umq_message_id_info_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#091b5806bf18d10ebd0d9117e0c70229" title="Extended send of a message to the topic associated with a UM source.">lbm_src_send_ex</a> A structure used with UMQ sending applications that informs the application of the UMQ Message ID used with a message. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c9fd57ff21d7cb28b4590e632749b65c"></a><!-- doxytag: member="lbm.h::lbm_src_event_umq_registration_complete_ex_t" ref="c9fd57ff21d7cb28b4590e632749b65c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__src__event__umq__registration__complete__ex__t__stct.html">lbm_src_event_umq_registration_complete_ex_t_stct</a>  <a class="el" href="structlbm__src__event__umq__registration__complete__ex__t__stct.html">lbm_src_event_umq_registration_complete_ex_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with UMQ sources to indicate successful source registration to quorum or to all queue instances involved. 
</div>
</div><p>
<a class="anchor" name="57ee4ae23bc7e04eaafbf701a44ac547"></a><!-- doxytag: member="lbm.h::lbm_src_event_umq_stability_ack_info_ex_t" ref="57ee4ae23bc7e04eaafbf701a44ac547" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__src__event__umq__stability__ack__info__ex__t__stct.html">lbm_src_event_umq_stability_ack_info_ex_t_stct</a>  <a class="el" href="structlbm__src__event__umq__stability__ack__info__ex__t__stct.html">lbm_src_event_umq_stability_ack_info_ex_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with UMQ source applications to indicate message acknowledgment by a queue instance. 
</div>
</div><p>
<a class="anchor" name="4a142e22ec153e2e9015f1b4364cdd71"></a><!-- doxytag: member="lbm.h::lbm_src_event_umq_ulb_message_info_ex_t" ref="4a142e22ec153e2e9015f1b4364cdd71" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__src__event__umq__ulb__message__info__ex__t__stct.html">lbm_src_event_umq_ulb_message_info_ex_t_stct</a>  <a class="el" href="structlbm__src__event__umq__ulb__message__info__ex__t__stct.html">lbm_src_event_umq_ulb_message_info_ex_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with UMQ ULB source applications to indicate message events. 
</div>
</div><p>
<a class="anchor" name="f0c6681ab1fcaf8faf66e597859ee94a"></a><!-- doxytag: member="lbm.h::lbm_src_event_umq_ulb_receiver_info_ex_t" ref="f0c6681ab1fcaf8faf66e597859ee94a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__src__event__umq__ulb__receiver__info__ex__t__stct.html">lbm_src_event_umq_ulb_receiver_info_ex_t_stct</a>  <a class="el" href="structlbm__src__event__umq__ulb__receiver__info__ex__t__stct.html">lbm_src_event_umq_ulb_receiver_info_ex_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with UMQ ULB source applications to indicate receiver events. 
</div>
</div><p>
<a class="anchor" name="4a090ffb298662b540d2fbd4f8add876"></a><!-- doxytag: member="lbm.h::lbm_src_event_wakeup_t" ref="4a090ffb298662b540d2fbd4f8add876" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__src__event__wakeup__t__stct.html">lbm_src_event_wakeup_t_stct</a>  <a class="el" href="structlbm__src__event__wakeup__t__stct.html">lbm_src_event_wakeup_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used to indicate the type of source that is now unblocked. 
</div>
</div><p>
<a class="anchor" name="6fd5cb88fa3780abcb236951d236ffce"></a><!-- doxytag: member="lbm.h::lbm_src_notify_func_t" ref="6fd5cb88fa3780abcb236951d236ffce" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__src__notify__func__t__stct.html">lbm_src_notify_func_t_stct</a>  <a class="el" href="structlbm__src__notify__func__t__stct.html">lbm_src_notify_func_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with options to set/get a specific callback information 
</div>
</div><p>
<a class="anchor" name="849a5ac10cd71a981a8a781239bc09e9"></a><!-- doxytag: member="lbm.h::lbm_src_notify_function_cb" ref="849a5ac10cd71a981a8a781239bc09e9" args="(const char *topic_str, const char *src_str, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(*) <a class="el" href="lbm_8h.html#849a5ac10cd71a981a8a781239bc09e9">lbm_src_notify_function_cb</a>(const char *topic_str, const char *src_str, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by <a class="el" href="lbm_8h.html#b67f641d5a0ad1a9fe53d415da58d961" title="Set an option for the given UM context attribute.">lbm_context_attr_setopt()</a> with option "resolver_source_notification_function". NOTE: this application callback is always made from the context thread, and is therefore limited in the UM API calls it can make. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#6fd5cb88fa3780abcb236951d236ffce" title="Structure that holds the callback for source notifications.">lbm_src_notify_func_t</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>topic_str</em>&nbsp;</td><td>Name of topic for which a source has been found. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_str</em>&nbsp;</td><td>Source as a string. Format depends on transport type. For string formats and examples, see <a class="el" href="structlbm__transport__source__info__t__stct.html" title="Structure that holds formatted and parsed transport source strings.">lbm_transport_source_info_t_stct</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in the lbm_src_notify_func_t passed to the <a class="el" href="lbm_8h.html#b67f641d5a0ad1a9fe53d415da58d961" title="Set an option for the given UM context attribute.">lbm_context_attr_setopt()</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 always. </dd></dl>

</div>
</div><p>
<a class="anchor" name="21504de56612c7c6e4be655402b47a37"></a><!-- doxytag: member="lbm.h::lbm_src_send_ex_info_t" ref="21504de56612c7c6e4be655402b47a37" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__src__send__ex__info__t__stct.html">lbm_src_send_ex_info_t_stct</a>  <a class="el" href="structlbm__src__send__ex__info__t__stct.html">lbm_src_send_ex_info_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#091b5806bf18d10ebd0d9117e0c70229" title="Extended send of a message to the topic associated with a UM source.">lbm_src_send_ex</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3d6965a7fc6ab72db6e416b06eeefaab"></a><!-- doxytag: member="lbm.h::lbm_src_transport_stats_daemon_t" ref="3d6965a7fc6ab72db6e416b06eeefaab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__src__transport__stats__daemon__t__stct.html">lbm_src_transport_stats_daemon_t_stct</a>  <a class="el" href="structlbm__src__transport__stats__daemon__t__stct.html">lbm_src_transport_stats_daemon_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This structure holds statistics for source transports using the daemon mode. NOTE: daemon mode is deprecated and no longer available; this structure is retained for for backward compatibility only. 
</div>
</div><p>
<a class="anchor" name="0a0c54fd8e9a7008f1db0126373fca92"></a><!-- doxytag: member="lbm.h::lbm_src_transport_stats_t" ref="0a0c54fd8e9a7008f1db0126373fca92" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__src__transport__stats__t__stct.html">lbm_src_transport_stats_t_stct</a>  <a class="el" href="structlbm__src__transport__stats__t__stct.html">lbm_src_transport_stats_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This structure holds statistics for all source transports. The structure is filled in when statistics for source transports are requested. 
</div>
</div><p>
<a class="anchor" name="55fedf757c6c5bc6df031fc1446d21bb"></a><!-- doxytag: member="lbm.h::lbm_str_hash_func_ex_t" ref="55fedf757c6c5bc6df031fc1446d21bb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__str__hash__func__ex__t__stct.html">lbm_str_hash_func_ex_t_stct</a>  <a class="el" href="structlbm__str__hash__func__ex__t__stct.html">lbm_str_hash_func_ex_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with options to set/get a specific hash function information. 
</div>
</div><p>
<a class="anchor" name="21ae55d313d8f4feb9e9a64f1c5a566c"></a><!-- doxytag: member="lbm.h::lbm_str_hash_function_cb" ref="21ae55d313d8f4feb9e9a64f1c5a566c" args="(const char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef lbm_ulong_t(*) <a class="el" href="lbm_8h.html#21ae55d313d8f4feb9e9a64f1c5a566c">lbm_str_hash_function_cb</a>(const char *str)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by <a class="el" href="lbm_8h.html#b67f641d5a0ad1a9fe53d415da58d961" title="Set an option for the given UM context attribute.">lbm_context_attr_setopt()</a> with option "resolver_string_hash_function". NOTE: this application callback is always made from the context thread, and is therefore limited in the UM API calls it can make. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>String to be hashed. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>hash value 0..(lbm_ulong_t)-1 </dd></dl>

</div>
</div><p>
<a class="anchor" name="c177f556e1e760198d10149bd6abbd8a"></a><!-- doxytag: member="lbm.h::lbm_str_hash_function_cb_ex" ref="c177f556e1e760198d10149bd6abbd8a" args="(const char *str, size_t strlen, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef lbm_ulong_t(*) <a class="el" href="lbm_8h.html#c177f556e1e760198d10149bd6abbd8a">lbm_str_hash_function_cb_ex</a>(const char *str, size_t strlen, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by <a class="el" href="lbm_8h.html#b67f641d5a0ad1a9fe53d415da58d961" title="Set an option for the given UM context attribute.">lbm_context_attr_setopt()</a> with option "resolver_string_hash_function_ex". NOTE: this application callback is always made from the context thread, and is therefore limited in the UM API calls it can make. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>String to be hashed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>strlen</em>&nbsp;</td><td>Length of str IF AVAILABLE, (lbm_ulong_t)-1 if not calculated by lbm </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in in the lbm_str_hash_func_ex_t passed to the <a class="el" href="lbm_8h.html#b67f641d5a0ad1a9fe53d415da58d961" title="Set an option for the given UM context attribute.">lbm_context_attr_setopt()</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>hash value 0..(lbm_ulong_t)-1 </dd></dl>

</div>
</div><p>
<a class="anchor" name="147d905636bb3b870ba5c0096c3f66b9"></a><!-- doxytag: member="lbm.h::lbm_timer_cb_proc" ref="147d905636bb3b870ba5c0096c3f66b9" args="(lbm_context_t *ctx, const void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(*) <a class="el" href="lbm_8h.html#147d905636bb3b870ba5c0096c3f66b9">lbm_timer_cb_proc</a>(lbm_context_t *ctx, const void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by <a class="el" href="lbm_8h.html#6ddbee95ee1eb4e6b98b177f84157f8a" title="Schedule a timer that calls proc when it expires.">lbm_schedule_timer()</a>. If this application callback is set without an event queue, it is called from the context thread and is limited in the API calls that it can make. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Context running the timer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in <a class="el" href="lbm_8h.html#6ddbee95ee1eb4e6b98b177f84157f8a" title="Schedule a timer that calls proc when it expires.">lbm_schedule_timer()</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 always. </dd></dl>

</div>
</div><p>
<a class="anchor" name="00b4a00d4c5a4892743027ea6cab128b"></a><!-- doxytag: member="lbm.h::lbm_timeval_t" ref="00b4a00d4c5a4892743027ea6cab128b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__timeval__t__stct.html">lbm_timeval_t_stct</a>  <a class="el" href="structlbm__timeval__t__stct.html">lbm_timeval_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure included in UM messages to indicate when the message was received by UM. A message timestamp using this can be up to 500 milliseconds prior to actual receipt time, and hence, is not suitable when accurate message-arrival-time measurements are needed. 
</div>
</div><p>
<a class="anchor" name="07f7bc3e6e4fe05c89ff2c3e4e6aa489"></a><!-- doxytag: member="lbm.h::lbm_transport_source_info_t" ref="07f7bc3e6e4fe05c89ff2c3e4e6aa489" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__transport__source__info__t__stct.html">lbm_transport_source_info_t_stct</a>  <a class="el" href="structlbm__transport__source__info__t__stct.html">lbm_transport_source_info_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This structure holds the fields used to format and/or parse transport source strings. The format of these strings depends mainly on the transport type, as shown below.<p>
<ul>
<li>TCP:src_ip:src_port[topic_idx] <br>
 example: <code>TCP:192.168.0.4:45789[1539853954]</code></li>
</ul>
<ul>
<li>LBTRM:src_ip:src_port:session_id:mc_group:dest_port[topic_idx] <br>
 example: <code>LBTRM:10.29.3.88:14390:e0679abb:231.13.13.13:14400[1539853954]</code></li>
</ul>
<ul>
<li>LBT-RU:src_ip:src_port:session_id[topic_idx] (session_id optional, per configuration option transport_lbtru_use_session_id) <br>
 example: <code>LBT-RU:192.168.3.189:34678[1539853954]</code></li>
</ul>
<ul>
<li>LBT-IPC:session_id:transport_id[topic_idx] <br>
 example: <code>LBT-IPC:6481f8d4:20000[1539853954]</code></li>
</ul>
<ul>
<li>LBT-RDMA:src_ip:src_port:session_id[topic_idx] <br>
 example: <code>LBT-RDMA:192.168.3.189:34678:6471e9c4[1539853954]</code></li>
</ul>
Please note that the topic index field (topic_idx) may or may not be present depending on your version of UM and/or the setting for configuration option source_includes_topic_index. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#fa35ad2c7d5d473ffeda6727022f9b94" title="Format a UM transport source string from its components.">lbm_transport_source_format</a> <a class="el" href="lbm_8h.html#30bf33dce2021f6ea8915b45f511af56" title="Parse a UM transport source string into its components.">lbm_transport_source_parse</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="3ce940fe5841daa6e761bc1e9b0a7c6f"></a><!-- doxytag: member="lbm.h::lbm_ucast_resolver_entry_t" ref="3ce940fe5841daa6e761bc1e9b0a7c6f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__ucast__resolver__entry__t__stct.html">lbm_ucast_resolver_entry_t_stct</a>  <a class="el" href="structlbm__ucast__resolver__entry__t__stct.html">lbm_ucast_resolver_entry_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with options to get/set information about unicast resolver daemons. 
</div>
</div><p>
<a class="anchor" name="f1c3a6d1eb8b5ef6e3539389fabe6d91"></a><!-- doxytag: member="lbm.h::lbm_ume_ctx_rcv_ctx_notification_create_function_cb" ref="f1c3a6d1eb8b5ef6e3539389fabe6d91" args="(const ume_liveness_receiving_context_t *rcv, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void*(*) <a class="el" href="lbm_8h.html#f1c3a6d1eb8b5ef6e3539389fabe6d91">lbm_ume_ctx_rcv_ctx_notification_create_function_cb</a>(const <a class="el" href="structume__liveness__receiving__context__t__stct.html">ume_liveness_receiving_context_t</a> *rcv, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by <a class="el" href="lbm_8h.html#b67f641d5a0ad1a9fe53d415da58d961" title="Set an option for the given UM context attribute.">lbm_context_attr_setopt()</a> with option "lbm_context_attr_ume_receiver_liveness_notify_func". NOTE: this application callback is always made from the context thread and is therefore limited in the UM API calls it can make. <dl class="see" compact><dt><b>See also:</b></dt><dd>lbm_ume_rcv_ctx_notification_func_t </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>const</em>&nbsp;</td><td>struct ume_liveness_receiving_context_t </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in the lbm_ume_rcv_ctx_notification_func_t passed to <a class="el" href="lbm_8h.html#b67f641d5a0ad1a9fe53d415da58d961" title="Set an option for the given UM context attribute.">lbm_context_attr_setopt()</a> with the "ume_receiver_context_detection_function" attribute. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>void pointer to be set for the "unresponsive" event when this ume_liveness_receiving_context_t is declared unresponsive. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c73a46984b624d7a1b8aa3decb476bdb"></a><!-- doxytag: member="lbm.h::lbm_ume_ctx_rcv_ctx_notification_delete_function_cb" ref="c73a46984b624d7a1b8aa3decb476bdb" args="(const ume_liveness_receiving_context_t *rcv, void *clientd, void *source_clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(*) <a class="el" href="lbm_8h.html#c73a46984b624d7a1b8aa3decb476bdb">lbm_ume_ctx_rcv_ctx_notification_delete_function_cb</a>(const <a class="el" href="structume__liveness__receiving__context__t__stct.html">ume_liveness_receiving_context_t</a> *rcv, void *clientd, void *source_clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by <a class="el" href="lbm_8h.html#b67f641d5a0ad1a9fe53d415da58d961" title="Set an option for the given UM context attribute.">lbm_context_attr_setopt()</a> with option "lbm_context_attr_ume_receiver_liveness_notify_func". NOTE: this application callback is always made from the context thread and is therefore limited in the UM API calls it can make. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#a192b884ef005240730d1f79af456bcc" title="Structure that holds the application callback for receiving context status notifications...">lbm_ume_ctx_rcv_ctx_notification_func_t</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>const</em>&nbsp;</td><td>struct lbm_ume_liveness_rcv_context_t </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in the lbm_ume_ctx_rcv_ctx_notification_func_t passed to <a class="el" href="lbm_8h.html#b67f641d5a0ad1a9fe53d415da58d961" title="Set an option for the given UM context attribute.">lbm_context_attr_setopt()</a> with the "ume_receiver_context_deletion_function" attribute. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if success -1 if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a192b884ef005240730d1f79af456bcc"></a><!-- doxytag: member="lbm.h::lbm_ume_ctx_rcv_ctx_notification_func_t" ref="a192b884ef005240730d1f79af456bcc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__ume__ctx__rcv__ctx__notification__func__t__stct.html">lbm_ume_ctx_rcv_ctx_notification_func_t_stct</a>  <a class="el" href="structlbm__ume__ctx__rcv__ctx__notification__func__t__stct.html">lbm_ume_ctx_rcv_ctx_notification_func_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A Structure used with options to set/get a specific callback function 
</div>
</div><p>
<a class="anchor" name="864aeb7e5113d0d496950cf75ae3cda9"></a><!-- doxytag: member="lbm.h::lbm_ume_rcv_recovery_info_ex_func_info_t" ref="864aeb7e5113d0d496950cf75ae3cda9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__ume__rcv__recovery__info__ex__func__info__t__stct.html">lbm_ume_rcv_recovery_info_ex_func_info_t_stct</a>  <a class="el" href="structlbm__ume__rcv__recovery__info__ex__func__info__t__stct.html">lbm_ume_rcv_recovery_info_ex_func_info_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with UMP receiver recovery sequence number information callbacks to pass in information as well as return low sequence number information.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#c318ae4d0d80e5595ce572558102c7b5" title="Structure that holds the application callback for recovery sequence number information...">lbm_ume_rcv_recovery_info_ex_func_t</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c318ae4d0d80e5595ce572558102c7b5"></a><!-- doxytag: member="lbm.h::lbm_ume_rcv_recovery_info_ex_func_t" ref="c318ae4d0d80e5595ce572558102c7b5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__ume__rcv__recovery__info__ex__func__t__stct.html">lbm_ume_rcv_recovery_info_ex_func_t_stct</a>  <a class="el" href="structlbm__ume__rcv__recovery__info__ex__func__t__stct.html">lbm_ume_rcv_recovery_info_ex_func_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A struct used with options to set/get a specific callback function 
</div>
</div><p>
<a class="anchor" name="cfa85f6293da6b9cdffcc595f2dfcf51"></a><!-- doxytag: member="lbm.h::lbm_ume_rcv_recovery_info_ex_function_cb" ref="cfa85f6293da6b9cdffcc595f2dfcf51" args="(lbm_ume_rcv_recovery_info_ex_func_info_t *info, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(*) <a class="el" href="lbm_8h.html#cfa85f6293da6b9cdffcc595f2dfcf51">lbm_ume_rcv_recovery_info_ex_function_cb</a>(<a class="el" href="structlbm__ume__rcv__recovery__info__ex__func__info__t__stct.html">lbm_ume_rcv_recovery_info_ex_func_info_t</a> *info, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by <a class="el" href="lbm_8h.html#1afc75f0fb3601d072b3463e7acf16a6" title="Set an option value within the given receiver topic attribute.">lbm_rcv_topic_attr_setopt()</a> with option "ume_recovery_sequence_number_info_function". NOTE: this application callback is always made from the context thread, and is therefore limited in the UM API calls it can make. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#c318ae4d0d80e5595ce572558102c7b5" title="Structure that holds the application callback for recovery sequence number information...">lbm_ume_rcv_recovery_info_ex_func_t</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>Structure to hold recovery sequence number information in an extended form </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in the lbm_ume_rcv_recovery_info_ex_func_t passed to <a class="el" href="lbm_8h.html#1afc75f0fb3601d072b3463e7acf16a6" title="Set an option value within the given receiver topic attribute.">lbm_rcv_topic_attr_setopt()</a> with the "ume_recovery_sequence_number_info_function" attribute. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 always </dd></dl>

</div>
</div><p>
<a class="anchor" name="55204ac3b6f89d64faa89286196b26a9"></a><!-- doxytag: member="lbm.h::lbm_ume_rcv_regid_ex_func_info_t" ref="55204ac3b6f89d64faa89286196b26a9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__ume__rcv__regid__ex__func__info__t__stct.html">lbm_ume_rcv_regid_ex_func_info_t_stct</a>  <a class="el" href="structlbm__ume__rcv__regid__ex__func__info__t__stct.html">lbm_ume_rcv_regid_ex_func_info_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with UMP receiver registration ID callbacks to pass in information.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#570a021e283e9175826e579580dd79fc" title="Structure that holds the application callback for registration ID setting.">lbm_ume_rcv_regid_func_t</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1145cdaf45b6f93b335d4fd97cbc68e9"></a><!-- doxytag: member="lbm.h::lbm_ume_rcv_regid_ex_func_t" ref="1145cdaf45b6f93b335d4fd97cbc68e9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__ume__rcv__regid__ex__func__t__stct.html">lbm_ume_rcv_regid_ex_func_t_stct</a>  <a class="el" href="structlbm__ume__rcv__regid__ex__func__t__stct.html">lbm_ume_rcv_regid_ex_func_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with options to set/get a specific callback function 
</div>
</div><p>
<a class="anchor" name="8c069dbea00f437936404ea554182c7a"></a><!-- doxytag: member="lbm.h::lbm_ume_rcv_regid_ex_function_cb" ref="8c069dbea00f437936404ea554182c7a" args="(lbm_ume_rcv_regid_ex_func_info_t *info, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef lbm_uint_t(*) <a class="el" href="lbm_8h.html#8c069dbea00f437936404ea554182c7a">lbm_ume_rcv_regid_ex_function_cb</a>(<a class="el" href="structlbm__ume__rcv__regid__ex__func__info__t__stct.html">lbm_ume_rcv_regid_ex_func_info_t</a> *info, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by <a class="el" href="lbm_8h.html#1afc75f0fb3601d072b3463e7acf16a6" title="Set an option value within the given receiver topic attribute.">lbm_rcv_topic_attr_setopt()</a> with option "ume_registration_extended_function". NOTE: this application callback is always made from the context thread, and is therefore limited in the UM API calls it can make. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#1145cdaf45b6f93b335d4fd97cbc68e9" title="Structure that holds the application callback for registration ID setting, extended...">lbm_ume_rcv_regid_ex_func_t</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>Structure holding registration information in an extended form </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in the lbm_ume_rcv_regid_ex_func_t passed to <a class="el" href="lbm_8h.html#1afc75f0fb3601d072b3463e7acf16a6" title="Set an option value within the given receiver topic attribute.">lbm_rcv_topic_attr_setopt()</a> with the "ume_registration_extended_function" attribute. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Registration ID to be used by receiver for given source and topic. </dd></dl>

</div>
</div><p>
<a class="anchor" name="570a021e283e9175826e579580dd79fc"></a><!-- doxytag: member="lbm.h::lbm_ume_rcv_regid_func_t" ref="570a021e283e9175826e579580dd79fc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__ume__rcv__regid__func__t__stct.html">lbm_ume_rcv_regid_func_t_stct</a>  <a class="el" href="structlbm__ume__rcv__regid__func__t__stct.html">lbm_ume_rcv_regid_func_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with options to set/get a specific callback function 
</div>
</div><p>
<a class="anchor" name="f533113cc21d841ee498fa1b79e3faa8"></a><!-- doxytag: member="lbm.h::lbm_ume_rcv_regid_function_cb" ref="f533113cc21d841ee498fa1b79e3faa8" args="(const char *src_str, lbm_uint_t src_regid, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef lbm_uint_t(*) <a class="el" href="lbm_8h.html#f533113cc21d841ee498fa1b79e3faa8">lbm_ume_rcv_regid_function_cb</a>(const char *src_str, lbm_uint_t src_regid, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by <a class="el" href="lbm_8h.html#1afc75f0fb3601d072b3463e7acf16a6" title="Set an option value within the given receiver topic attribute.">lbm_rcv_topic_attr_setopt()</a> with option "ume_registration_function". NOTE: this application callback is always made from the context thread, and is therefore limited in the UM API calls it can make. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#570a021e283e9175826e579580dd79fc" title="Structure that holds the application callback for registration ID setting.">lbm_ume_rcv_regid_func_t</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src_str</em>&nbsp;</td><td>Name of the source for the ID. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_regid</em>&nbsp;</td><td>Registration ID for the source for this topic. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in the lbm_ume_rcv_regid_func_t passed to <a class="el" href="lbm_8h.html#1afc75f0fb3601d072b3463e7acf16a6" title="Set an option value within the given receiver topic attribute.">lbm_rcv_topic_attr_setopt()</a> with the "ume_registration_function" attribute. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Registration ID to be used by receiver for given source and topic. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7a7b4983b4abbbafee7175490f7af9d2"></a><!-- doxytag: member="lbm.h::lbm_ume_src_force_reclaim_func_t" ref="7a7b4983b4abbbafee7175490f7af9d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__ume__src__force__reclaim__func__t__stct.html">lbm_ume_src_force_reclaim_func_t_stct</a>  <a class="el" href="structlbm__ume__src__force__reclaim__func__t__stct.html">lbm_ume_src_force_reclaim_func_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with options to set/get a specific callback function 
</div>
</div><p>
<a class="anchor" name="7304cc6156d5a8d6749176ad60112a44"></a><!-- doxytag: member="lbm.h::lbm_ume_src_force_reclaim_function_cb" ref="7304cc6156d5a8d6749176ad60112a44" args="(const char *topic_str, lbm_uint_t seqnum, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(*) <a class="el" href="lbm_8h.html#7304cc6156d5a8d6749176ad60112a44">lbm_ume_src_force_reclaim_function_cb</a>(const char *topic_str, lbm_uint_t seqnum, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by <a class="el" href="lbm_8h.html#96ea052dce2e6376684cbf2003407cbf" title="Set an option value within the given source topic attribute.">lbm_src_topic_attr_setopt()</a> with option "ume_force_reclaim_function". NOTE: this application callback is always made from the context thread and is therefore limited in the UM API calls it can make. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#7a7b4983b4abbbafee7175490f7af9d2" title="Structure that holds the application callback for forced reclamation notifications...">lbm_ume_src_force_reclaim_func_t</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>topic_str</em>&nbsp;</td><td>Name of the topic for the reclaim </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>seqnum</em>&nbsp;</td><td>Sequence Number that is reclaimed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in the lbm_ume_src_force_reclaim_func_t passed to <a class="el" href="lbm_8h.html#96ea052dce2e6376684cbf2003407cbf" title="Set an option value within the given source topic attribute.">lbm_src_topic_attr_setopt()</a> with the "ume_force_reclaim_function" attribute. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 always. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a86a12d5efc42a997eb6b61334241bc0"></a><!-- doxytag: member="lbm.h::lbm_ume_store_entry_t" ref="a86a12d5efc42a997eb6b61334241bc0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__ume__store__entry__t__stct.html">lbm_ume_store_entry_t_stct</a>  <a class="el" href="structlbm__ume__store__entry__t__stct.html">lbm_ume_store_entry_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with options to get/set information for a UMP store 
</div>
</div><p>
<a class="anchor" name="6322c18b4e126e9ad594401cbba9cf13"></a><!-- doxytag: member="lbm.h::lbm_ume_store_group_entry_t" ref="6322c18b4e126e9ad594401cbba9cf13" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__ume__store__group__entry__t__stct.html">lbm_ume_store_group_entry_t_stct</a>  <a class="el" href="structlbm__ume__store__group__entry__t__stct.html">lbm_ume_store_group_entry_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with options to get/set information for a UMP store group 
</div>
</div><p>
<a class="anchor" name="b6e8607b85d13bf38275a8632d7c801a"></a><!-- doxytag: member="lbm.h::lbm_ume_store_name_entry_t" ref="b6e8607b85d13bf38275a8632d7c801a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__ume__store__name__entry__t__stct.html">lbm_ume_store_name_entry_t_stct</a>  <a class="el" href="structlbm__ume__store__name__entry__t__stct.html">lbm_ume_store_name_entry_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with options to get/set information for a UMP store 
</div>
</div><p>
<a class="anchor" name="f038a0415aaf7dc4285a944bc93e5ea2"></a><!-- doxytag: member="lbm.h::lbm_umq_index_info_t" ref="f038a0415aaf7dc4285a944bc93e5ea2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__umq__index__info__t__stct.html">lbm_umq_index_info_t_stct</a>  <a class="el" href="structlbm__umq__index__info__t__stct.html">lbm_umq_index_info_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with UM sources and receivers to associated UMQ Indices with messages. 
</div>
</div><p>
<a class="anchor" name="b8b20fc8f822cdc1b8e78960b59d5739"></a><!-- doxytag: member="lbm.h::lbm_umq_msg_total_lifetime_info_t" ref="b8b20fc8f822cdc1b8e78960b59d5739" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__umq__msg__total__lifetime__info__t__stct.html">lbm_umq_msg_total_lifetime_info_t_stct</a>  <a class="el" href="structlbm__umq__msg__total__lifetime__info__t__stct.html">lbm_umq_msg_total_lifetime_info_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with UMQ sources to specify a message's total lifetime. 
</div>
</div><p>
<a class="anchor" name="6a09e48df4c9dc0df449988b57375c6d"></a><!-- doxytag: member="lbm.h::lbm_umq_msgid_t" ref="6a09e48df4c9dc0df449988b57375c6d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__umq__msgid__t__stct.html">lbm_umq_msgid_t_stct</a>  <a class="el" href="structlbm__umq__msgid__t__stct.html">lbm_umq_msgid_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#492725803c2f09e54bef51edf03caa78">lbm_umq_regid_t</a> A structure used with UMQ messages to identify a message uniquely. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7405e170505e0acb7325cb20f1a3c800"></a><!-- doxytag: member="lbm.h::lbm_umq_queue_entry_t" ref="7405e170505e0acb7325cb20f1a3c800" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__umq__queue__entry__t__stct.html">lbm_umq_queue_entry_t_stct</a>  <a class="el" href="structlbm__umq__queue__entry__t__stct.html">lbm_umq_queue_entry_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A struct used with options to get/set Registration ID information for UMQ queues 
</div>
</div><p>
<a class="anchor" name="492725803c2f09e54bef51edf03caa78"></a><!-- doxytag: member="lbm.h::lbm_umq_regid_t" ref="492725803c2f09e54bef51edf03caa78" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef lbm_uint64_t <a class="el" href="lbm_8h.html#492725803c2f09e54bef51edf03caa78">lbm_umq_regid_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Registration ID used for UMQ contexts for both sources and receivers 
</div>
</div><p>
<a class="anchor" name="34f1be95e2447180c700d059e9e6bfa6"></a><!-- doxytag: member="lbm.h::lbm_umq_ulb_application_set_attr_t" ref="34f1be95e2447180c700d059e9e6bfa6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__umq__ulb__application__set__attr__t__stct.html">lbm_umq_ulb_application_set_attr_t_stct</a>  <a class="el" href="structlbm__umq__ulb__application__set__attr__t__stct.html">lbm_umq_ulb_application_set_attr_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A struct used with options to get/set UMQ ULB application set attributes 
</div>
</div><p>
<a class="anchor" name="ad05190303cdd73c93b04913a917d717"></a><!-- doxytag: member="lbm.h::lbm_umq_ulb_receiver_type_attr_t" ref="ad05190303cdd73c93b04913a917d717" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__umq__ulb__receiver__type__attr__t__stct.html">lbm_umq_ulb_receiver_type_attr_t_stct</a>  <a class="el" href="structlbm__umq__ulb__receiver__type__attr__t__stct.html">lbm_umq_ulb_receiver_type_attr_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A struct used with options to get/set UMQ ULB receiver type attributes 
</div>
</div><p>
<a class="anchor" name="6699be947ebb422869633f68f1191c21"></a><!-- doxytag: member="lbm.h::lbm_umq_ulb_receiver_type_entry_t" ref="6699be947ebb422869633f68f1191c21" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__umq__ulb__receiver__type__entry__t__stct.html">lbm_umq_ulb_receiver_type_entry_t_stct</a>  <a class="el" href="structlbm__umq__ulb__receiver__type__entry__t__stct.html">lbm_umq_ulb_receiver_type_entry_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A struct used with options to get/set UMQ ULB Receiver Type entries 
</div>
</div><p>
<a class="anchor" name="7b6a386398e2006a07c3387d444f9ec1"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_compare_func_t" ref="7b6a386398e2006a07c3387d444f9ec1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__wildcard__rcv__compare__func__t__stct.html">lbm_wildcard_rcv_compare_func_t_stct</a>  <a class="el" href="structlbm__wildcard__rcv__compare__func__t__stct.html">lbm_wildcard_rcv_compare_func_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with options to set/get a specific application callback pattern type. 
</div>
</div><p>
<a class="anchor" name="f9c6d7a8a5fb9eced362df6480fb52aa"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_compare_function_cb" ref="f9c6d7a8a5fb9eced362df6480fb52aa" args="(const char *topic_str, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(*) <a class="el" href="lbm_8h.html#f9c6d7a8a5fb9eced362df6480fb52aa">lbm_wildcard_rcv_compare_function_cb</a>(const char *topic_str, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by <a class="el" href="lbm_8h.html#cec52fdb461e1f903b319e086d1d3e10" title="Set an option value within the given wildcard receiver attribute.">lbm_wildcard_rcv_attr_setopt()</a> with option "pattern_callback". NOTE: this application callback is always made from the context thread, and is therefore limited in the UM API calls it can make. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#7b6a386398e2006a07c3387d444f9ec1" title="Structure that holds the application callback pattern type information for wildcard...">lbm_wildcard_rcv_compare_func_t</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>topic_str</em>&nbsp;</td><td>Name of topic to be checked for match. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in the lbm_wildcard_rcv_compare_func_t passed to <a class="el" href="lbm_8h.html#cec52fdb461e1f903b319e086d1d3e10" title="Set an option value within the given wildcard receiver attribute.">lbm_wildcard_rcv_attr_setopt()</a> with the "pattern_callback" attribute. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for match and 1 for no match. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e65a28c201d693e7b51e8906bd39d260"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_create_func_t" ref="e65a28c201d693e7b51e8906bd39d260" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__wildcard__rcv__create__func__t__stct.html">lbm_wildcard_rcv_create_func_t_stct</a>  <a class="el" href="structlbm__wildcard__rcv__create__func__t__stct.html">lbm_wildcard_rcv_create_func_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with options to set/get a specific wildcard topic receiver creation callback type. 
</div>
</div><p>
<a class="anchor" name="759437ce7a508ce80e7ddad3df6c63b8"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_create_function_cb" ref="759437ce7a508ce80e7ddad3df6c63b8" args="(const char *topic_str, lbm_rcv_topic_attr_t *attr, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(*) <a class="el" href="lbm_8h.html#759437ce7a508ce80e7ddad3df6c63b8">lbm_wildcard_rcv_create_function_cb</a>(const char *topic_str, lbm_rcv_topic_attr_t *attr, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by <a class="el" href="lbm_8h.html#cec52fdb461e1f903b319e086d1d3e10" title="Set an option value within the given wildcard receiver attribute.">lbm_wildcard_rcv_attr_setopt()</a> with option "receiver_create_callback". NOTE: this application callback is always made from the context thread, and is therefore limited in the UM API calls it can make. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#e65a28c201d693e7b51e8906bd39d260" title="Structure that holds the receiver creation callback information for wildcard receivers...">lbm_wildcard_rcv_create_func_t</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>topic_str</em>&nbsp;</td><td>Name of topic which was matched, and for which a receiver will be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to an lbm_rcv_topic_attr_t which has been initialized with the receiver options which will be used to create the receiver. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in the lbm_wildcard_rcv_create_func_t passed to <a class="el" href="lbm_8h.html#cec52fdb461e1f903b319e086d1d3e10" title="Set an option value within the given wildcard receiver attribute.">lbm_wildcard_rcv_attr_setopt()</a> with the "receiver_create_callback" attribute. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Always return 0. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f9e0c6fb332c40bfcd999e13fa60cb26"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_delete_func_t" ref="f9e0c6fb332c40bfcd999e13fa60cb26" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlbm__wildcard__rcv__delete__func__t__stct.html">lbm_wildcard_rcv_delete_func_t_stct</a>  <a class="el" href="structlbm__wildcard__rcv__delete__func__t__stct.html">lbm_wildcard_rcv_delete_func_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used with options to set/get a specific wildcard topic receiver deletion callback type. 
</div>
</div><p>
<a class="anchor" name="222399ef16d02322f7eac8dbe865c8fc"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_delete_function_cb" ref="222399ef16d02322f7eac8dbe865c8fc" args="(const char *topic_str, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(*) <a class="el" href="lbm_8h.html#222399ef16d02322f7eac8dbe865c8fc">lbm_wildcard_rcv_delete_function_cb</a>(const char *topic_str, void *clientd)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set by <a class="el" href="lbm_8h.html#cec52fdb461e1f903b319e086d1d3e10" title="Set an option value within the given wildcard receiver attribute.">lbm_wildcard_rcv_attr_setopt()</a> with option "receiver_delete_callback". NOTE: this application callback is always made from the context thread, and is therefore limited in the UM API calls it can make. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#f9e0c6fb332c40bfcd999e13fa60cb26" title="Structure that holds the receiver deletion callback information for wildcard receivers...">lbm_wildcard_rcv_delete_func_t</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>topic_str</em>&nbsp;</td><td>Name of topic which was matched, and for which a receiver will be deleted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data pointer supplied in the lbm_wildcard_rcv_delete_func_t passed to <a class="el" href="lbm_8h.html#cec52fdb461e1f903b319e086d1d3e10" title="Set an option value within the given wildcard receiver attribute.">lbm_wildcard_rcv_attr_setopt()</a> with the "receiver_delete_callback" attribute. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Always return 0. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a9087bc433e8c17ecc50195a8094ad9c"></a><!-- doxytag: member="lbm.h::ume_liveness_receiving_context_t" ref="a9087bc433e8c17ecc50195a8094ad9c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structume__liveness__receiving__context__t__stct.html">ume_liveness_receiving_context_t_stct</a>  <a class="el" href="structume__liveness__receiving__context__t__stct.html">ume_liveness_receiving_context_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A structure used to hold a receiving context's user rcv regid and session id. Source contexts use this information to track receiver liveness. 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="f12d7293287405db2b965aacbb2a2b4d"></a><!-- doxytag: member="lbm.h::lbm_apphdr_chain_append_elem" ref="f12d7293287405db2b965aacbb2a2b4d" args="(lbm_apphdr_chain_t *chain, lbm_apphdr_chain_elem_t *elem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_apphdr_chain_append_elem           </td>
          <td>(</td>
          <td class="paramtype">lbm_apphdr_chain_t *&nbsp;</td>
          <td class="paramname"> <em>chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__apphdr__chain__elem__t__stct.html">lbm_apphdr_chain_elem_t</a> *&nbsp;</td>
          <td class="paramname"> <em>elem</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chain</em>&nbsp;</td><td>Pointer to an app header chain. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>elem</em>&nbsp;</td><td>Pointer to a user-created app header element. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for success, -1 for failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="40a3fe706dc6cf4a6bd23ebe721ce636"></a><!-- doxytag: member="lbm.h::lbm_apphdr_chain_create" ref="40a3fe706dc6cf4a6bd23ebe721ce636" args="(lbm_apphdr_chain_t **chain)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_apphdr_chain_create           </td>
          <td>(</td>
          <td class="paramtype">lbm_apphdr_chain_t **&nbsp;</td>
          <td class="paramname"> <em>chain</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chain</em>&nbsp;</td><td>Pointer to a pointer to an app header chain. This will be filled in with the newly created chain. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for success, -1 for failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="4f468c363d3d1735507be95fe4638d09"></a><!-- doxytag: member="lbm.h::lbm_apphdr_chain_delete" ref="4f468c363d3d1735507be95fe4638d09" args="(lbm_apphdr_chain_t *chain)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_apphdr_chain_delete           </td>
          <td>(</td>
          <td class="paramtype">lbm_apphdr_chain_t *&nbsp;</td>
          <td class="paramname"> <em>chain</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chain</em>&nbsp;</td><td>Pointer to an app header chain. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for success, -1 for failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="a3b027a74322c1683e68ea86207b187f"></a><!-- doxytag: member="lbm.h::lbm_apphdr_chain_iter_create" ref="a3b027a74322c1683e68ea86207b187f" args="(lbm_apphdr_chain_iter_t **chain_iter, lbm_apphdr_chain_t *chain)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_apphdr_chain_iter_create           </td>
          <td>(</td>
          <td class="paramtype">lbm_apphdr_chain_iter_t **&nbsp;</td>
          <td class="paramname"> <em>chain_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_apphdr_chain_t *&nbsp;</td>
          <td class="paramname"> <em>chain</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chain_iter</em>&nbsp;</td><td>Pointer to a pointer to an lbm_apphdr_chain_iter_t structure to be filled in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chain</em>&nbsp;</td><td>Pointer to an app header chain from which to create the iterator. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if the iterator points to the first element in the chain, -1 if there are no elements in the chain </dd></dl>

</div>
</div><p>
<a class="anchor" name="316dcfdb28460ee670cc6399d6d94b9f"></a><!-- doxytag: member="lbm.h::lbm_apphdr_chain_iter_create_from_msg" ref="316dcfdb28460ee670cc6399d6d94b9f" args="(lbm_apphdr_chain_iter_t **chain_iter, lbm_msg_t *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_apphdr_chain_iter_create_from_msg           </td>
          <td>(</td>
          <td class="paramtype">lbm_apphdr_chain_iter_t **&nbsp;</td>
          <td class="paramname"> <em>chain_iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chain_iter</em>&nbsp;</td><td>Pointer to a pointer to an lbm_apphdr_chain_elem_t structure to be filled in </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Pointer to a UM message from which to retrieve the app header chain. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if the iterator points to the first element in the chain, -1 if there are no elements in the chain </dd></dl>

</div>
</div><p>
<a class="anchor" name="db432d65e72c04a7d5866bed9961e673"></a><!-- doxytag: member="lbm.h::lbm_apphdr_chain_iter_current" ref="db432d65e72c04a7d5866bed9961e673" args="(lbm_apphdr_chain_iter_t **chain_iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL <a class="el" href="structlbm__apphdr__chain__elem__t__stct.html">lbm_apphdr_chain_elem_t</a>* lbm_apphdr_chain_iter_current           </td>
          <td>(</td>
          <td class="paramtype">lbm_apphdr_chain_iter_t **&nbsp;</td>
          <td class="paramname"> <em>chain_iter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chain_iter</em>&nbsp;</td><td>Pointer to pointer to an lbm_apphdr_chain_iter_t iterator. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>lbm_apphdr_chain_elem_t pointer to the current app header chain element. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2fe460bfd35bf3d9f492dae02a08e77c"></a><!-- doxytag: member="lbm.h::lbm_apphdr_chain_iter_delete" ref="2fe460bfd35bf3d9f492dae02a08e77c" args="(lbm_apphdr_chain_iter_t *chain_iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_apphdr_chain_iter_delete           </td>
          <td>(</td>
          <td class="paramtype">lbm_apphdr_chain_iter_t *&nbsp;</td>
          <td class="paramname"> <em>chain_iter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chain_iter</em>&nbsp;</td><td>Pointer to an lbm_apphdr_chain_iter_t created by one of the lbm_apphdr_chain_iter_create functions. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for success, -1 for failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="b04ca3bf4fee83b3f97bc0c1586f880a"></a><!-- doxytag: member="lbm.h::lbm_apphdr_chain_iter_done" ref="b04ca3bf4fee83b3f97bc0c1586f880a" args="(lbm_apphdr_chain_iter_t **chain_iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_apphdr_chain_iter_done           </td>
          <td>(</td>
          <td class="paramtype">lbm_apphdr_chain_iter_t **&nbsp;</td>
          <td class="paramname"> <em>chain_iter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chain_iter</em>&nbsp;</td><td>Pointer to pointer to an lbm_apphdr_chain_iter_t iterator. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 if there is a next element in an app header chain, 0 otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a4c079a614ffd5b547b30047749585e9"></a><!-- doxytag: member="lbm.h::lbm_apphdr_chain_iter_first" ref="a4c079a614ffd5b547b30047749585e9" args="(lbm_apphdr_chain_iter_t **chain_iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_apphdr_chain_iter_first           </td>
          <td>(</td>
          <td class="paramtype">lbm_apphdr_chain_iter_t **&nbsp;</td>
          <td class="paramname"> <em>chain_iter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chain_iter</em>&nbsp;</td><td>Pointer to pointer to an lbm_apphdr_chain_iter_t iterator. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6729d5b35c12874bc82be08ce708339a"></a><!-- doxytag: member="lbm.h::lbm_apphdr_chain_iter_next" ref="6729d5b35c12874bc82be08ce708339a" args="(lbm_apphdr_chain_iter_t **chain_iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_apphdr_chain_iter_next           </td>
          <td>(</td>
          <td class="paramtype">lbm_apphdr_chain_iter_t **&nbsp;</td>
          <td class="paramname"> <em>chain_iter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chain_iter</em>&nbsp;</td><td>Pointer to pointer to an lbm_apphdr_chain_iter_t iterator. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success, -1 for failure if there is no next element in the chain (iterator is unmodified). </dd></dl>

</div>
</div><p>
<a class="anchor" name="bec0367ec9851d2bfd64c889a6cffca2"></a><!-- doxytag: member="lbm.h::lbm_async_operation_cancel" ref="bec0367ec9851d2bfd64c889a6cffca2" args="(lbm_async_operation_handle_t handle, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_async_operation_cancel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lbm_8h.html#f4ae0671728c6941e2a991ec695d2ebb">lbm_async_operation_handle_t</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calling this function will cause the associated aynchronous operation's async operation callback function to be called with a canceled status. If the operation could not be canceled (either it has already completed, it never existed, or it is currently executing and past the point of no return), then -1 is returned and <a class="el" href="lbm_8h.html#f3a827eb26d87be5b1a6b9fd3a4b63aa" title="Return the error number last encountered by this thread.">lbm_errnum()</a> is set to indicate why the operation could not be canceled. Otherwise, 0 is returned for a successful cancel, indicating that the operation was found and guaranteed to have been truly canceled.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is generally not safe to call this function from within an asynchronous operation callback for the same handle that is being canceled. There is one exception: it is safe to call cancel on a handle from within the initial LBM_ASYNC_OP_STATUS_IN_PROGRESS that delivers the handle; this is in fact a reasonable way to simulate a non-blocking synchronous call. <p>
Once an operation has been canceled, any associated <a class="el" href="structlbm__async__operation__info__t.html" title="Results struct returned via the user-specified asynchronous operation callback from...">lbm_async_operation_info_t</a> objects are no longer valid and should not be accessed. This includes access to the opinfo parameter from within an initial LBM_ASYNC_OP_STATUS_IN_PROGRESS callback at any point in that callback after cancel has been called. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Handle to the asynchronous operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags to affect the behavior of the cancel. ORed set of values. <ul>
<li><code>LBM_ASYNC_OPERATION_CANCEL_FLAG_NONBLOCK</code> - If operation cannot be canceled immediately, return without canceling. The default behavior is to block until the operation can be successfully canceled. </li>
</ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure or 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="abec52c36b62aec1fde817444f74698b"></a><!-- doxytag: member="lbm.h::lbm_async_operation_status" ref="abec52c36b62aec1fde817444f74698b" args="(lbm_async_operation_handle_t handle, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_async_operation_status           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lbm_8h.html#f4ae0671728c6941e2a991ec695d2ebb">lbm_async_operation_handle_t</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calling this function will cause the associated aynchronous operation's async operation callback function to be called with current status information. This is a merely a polling mechanism, and the information returned is guaranteed to be correct only for the duration of the async operation callback function. It may change immediately afterwards.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from within an asynchronous operation callback for the same handle that status is being requested for. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>Handle to the asynchronous operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags to affect the behavior of the status request. ORed set of values. <ul>
<li><code>LBM_ASYNC_OPERATION_STATUS_FLAG_NONBLOCK</code> - If the operation's status cannot be retrieved immediately, just return without blocking. The default behavior is to block until the operation's status can be retrieved. </li>
</ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure or 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="150a4b140b9999c5eba12cf89cc3522c"></a><!-- doxytag: member="lbm.h::lbm_auth_set_credentials" ref="150a4b140b9999c5eba12cf89cc3522c" args="(lbm_context_t *ctx, const char *name, size_t name_len, const char *passwd, size_t passwd_len, lbm_cred_callback_fn cbfn, void *clientd, int auth_required)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_auth_set_credentials           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>name_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>passwd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>passwd_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_cred_callback_fn&nbsp;</td>
          <td class="paramname"> <em>cbfn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>clientd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>auth_required</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calling this function will set the credential of the user and make the requirement for the authentication. There are two ways to set credential: either setting the user's name and password parameters or passing the callback function pointer to retrieve credential information. The callback function method will override the credentials set by the input parameters. Once the parameter of auth_required is set to "1", the authentication results will be examed and errors will be reported if authenticatin checks fail. If the "auth_required" is set to "0", then the authentication failure will be ignored and there is no impact on the undergoing process.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>LBM context object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the user name string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name_len</em>&nbsp;</td><td>the length of the user name string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>passwd</em>&nbsp;</td><td>the user password string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>passwd_len</em>&nbsp;</td><td>the length of the user password string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbfn</em>&nbsp;</td><td>the callback function pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>the parameter of the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>auth_required</em>&nbsp;</td><td>the variable to require authentication service </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure or 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="572ecd55a7c8d3ccd3025cd2e4efed54"></a><!-- doxytag: member="lbm.h::lbm_authstorage_addtpnam" ref="572ecd55a7c8d3ccd3025cd2e4efed54" args="(const char *username, const char *pass, unsigned char flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_authstorage_addtpnam           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>username</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calling this function will generate new credential entry for the user and save it to the password file. Setting parameter of "flags" to "1" will overwrite the existing entry for the same user.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>username</em>&nbsp;</td><td>the user's name string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pass</em>&nbsp;</td><td>the password string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>overwritting flag. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>negative values for Failure or 0 and passitive values for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ce4921719de7dec82869837ba90441e7"></a><!-- doxytag: member="lbm.h::lbm_authstorage_checkpermission" ref="ce4921719de7dec82869837ba90441e7" args="(char *username, char *command)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_authstorage_checkpermission           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>username</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>command</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calling this function will check if the user is authorized to execute the specified command.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>username</em>&nbsp;</td><td>the user's name string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>command</em>&nbsp;</td><td>the command string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure or 0 for Denial or 1 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c923d58b2b471cffe6ed1d598d48cbc0"></a><!-- doxytag: member="lbm.h::lbm_authstorage_close_storage_xml" ref="c923d58b2b471cffe6ed1d598d48cbc0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL void lbm_authstorage_close_storage_xml           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calling this function will release the storage object created by <a class="el" href="lbm_8h.html#ebfd20af929219cffcb2f21e2581b7ba" title="Create the storage object from XML password file.">lbm_authstorage_open_storage_xml()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None.</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="029a239074f0ede982ff3931ce8011ab"></a><!-- doxytag: member="lbm.h::lbm_authstorage_deltpnam" ref="029a239074f0ede982ff3931ce8011ab" args="(const char *username)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_authstorage_deltpnam           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>username</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calling this function will remove the credential entry for the user from the password file.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>username</em>&nbsp;</td><td>the user's name string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure or 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fc8c273ea8be3eadc9ed56861b5ff493"></a><!-- doxytag: member="lbm.h::lbm_authstorage_load_roletable" ref="fc8c273ea8be3eadc9ed56861b5ff493" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_authstorage_load_roletable           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calling this function will create an internal data object to hold the role table from the password file.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None.</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure or 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ebfd20af929219cffcb2f21e2581b7ba"></a><!-- doxytag: member="lbm.h::lbm_authstorage_open_storage_xml" ref="ebfd20af929219cffcb2f21e2581b7ba" args="(char *filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_authstorage_open_storage_xml           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calling this function will create the storage object which contains all users' authentication and authorization information from the XML password file with the name specified in the input parameter. If that file does not exist, a default password information will be used instead.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>the xml file name string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success or negative for failure (-1:invalid parameter; -2: storage exist; -3: creation failed) </dd></dl>

</div>
</div><p>
<a class="anchor" name="c105adb81eb1a0642a3551fbe4ac5af4"></a><!-- doxytag: member="lbm.h::lbm_authstorage_print_roletable" ref="c105adb81eb1a0642a3551fbe4ac5af4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_authstorage_print_roletable           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calling this function will print out the role table saved in the internal data object created by <a class="el" href="lbm_8h.html#fc8c273ea8be3eadc9ed56861b5ff493" title="Load the role table from the password file.">lbm_authstorage_load_roletable()</a> function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None.</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure or 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e02c55b6630ac4d61613120edf9e76b3"></a><!-- doxytag: member="lbm.h::lbm_authstorage_roletable_add_role_action" ref="e02c55b6630ac4d61613120edf9e76b3" args="(const char *rolename, const char *action)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_authstorage_roletable_add_role_action           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>rolename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>action</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calling this function will authorize users assuming the specified role to perform the assigned action.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rolename</em>&nbsp;</td><td>the role name string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>action</em>&nbsp;</td><td>the action name string </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure or 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fb8e187295fd6b50e74fe5fdece7a6d3"></a><!-- doxytag: member="lbm.h::lbm_authstorage_unload_roletable" ref="fb8e187295fd6b50e74fe5fdece7a6d3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_authstorage_unload_roletable           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calling this function will release the role table saved in the internal data object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None.</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure or 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="238478b2f89bab6884e7f65c741572d0"></a><!-- doxytag: member="lbm.h::lbm_authstorage_user_add_role" ref="238478b2f89bab6884e7f65c741572d0" args="(const char *username, const char *role)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_authstorage_user_add_role           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>username</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>role</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calling this function will add a new role entry for the specified user to the password file.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>username</em>&nbsp;</td><td>the user's name string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>role</em>&nbsp;</td><td>the role string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure or 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="76a9011498d326bc845ca90ccafc6ab8"></a><!-- doxytag: member="lbm.h::lbm_authstorage_user_del_role" ref="76a9011498d326bc845ca90ccafc6ab8" args="(const char *username, const char *role)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_authstorage_user_del_role           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>username</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>role</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calling this function will remove the role entry for the specified user from the password file.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>username</em>&nbsp;</td><td>the user's name string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>role</em>&nbsp;</td><td>the role string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure or 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ea6845ad513f07a994d23d3c50201436"></a><!-- doxytag: member="lbm.h::lbm_cancel_fd" ref="ea6845ad513f07a994d23d3c50201436" args="(lbm_context_t *ctx, lbm_handle_t handle, lbm_ulong_t ev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_cancel_fd           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_ulong_t&nbsp;</td>
          <td class="paramname"> <em>ev</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cancel a previously registered file descriptor/socket event. Note that there are rare circumstances where this function can return while the fd callback may still be executing. If the application needs to know when all possible processing on the fd is complete, it must use <a class="el" href="lbm_8h.html#55bed50f2627d24371ab9acae1f27f33" title="Extended cancel a previously registered file descriptor/socket event.">lbm_cancel_fd_ex()</a>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#50d8ea5a6ebb5f1f0c6c5d9155c09657" title="Register a file descriptor/socket for events that calls proc when a given event occurs...">lbm_register_fd</a> </dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not recommended to call this function from a context thread callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the UM context object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>file descriptor/socket of interest for event. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ev</em>&nbsp;</td><td>One or more of LBM_FD_EVENT_* (ORed to together). Mask of events to cancel. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="55bed50f2627d24371ab9acae1f27f33"></a><!-- doxytag: member="lbm.h::lbm_cancel_fd_ex" ref="55bed50f2627d24371ab9acae1f27f33" args="(lbm_context_t *ctx, lbm_handle_t handle, lbm_ulong_t ev, lbm_event_queue_cancel_cb_info_t *cbinfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_cancel_fd_ex           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_ulong_t&nbsp;</td>
          <td class="paramname"> <em>ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__event__queue__cancel__cb__info__t__stct.html">lbm_event_queue_cancel_cb_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cbinfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cancel a previously registered file descriptor/socket event, with an application callback indicating when the fd is fully canceled. This extended version of the fd cancel function requires the configuration option queue_cancellation_callbacks_enabled be set to 1.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#50d8ea5a6ebb5f1f0c6c5d9155c09657" title="Register a file descriptor/socket for events that calls proc when a given event occurs...">lbm_register_fd</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the UM context object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>file descriptor/socket of interest for event. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ev</em>&nbsp;</td><td>Mask of events to cancel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbinfo</em>&nbsp;</td><td>Cancellation callback information, containing the event queue, function pointer, and client data for the callback. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ac8fc2f828cdcd6a44282c950ee01fb0"></a><!-- doxytag: member="lbm.h::lbm_cancel_timer" ref="ac8fc2f828cdcd6a44282c950ee01fb0" args="(lbm_context_t *ctx, int id, void **clientdp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_cancel_timer           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>clientdp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cancel a previously scheduled timer. The timer is identified by the return value of the <a class="el" href="lbm_8h.html#6ddbee95ee1eb4e6b98b177f84157f8a" title="Schedule a timer that calls proc when it expires.">lbm_schedule_timer()</a> function. If the passed-in timer ID is not valid, this cancel function returns success, which occurs if the passed-in timer ID has already fired or if the timer ID is garbage. Note that there are rare circumstances where this function can return while the timer callback may still be executing. If the application needs to know when all possible processing on the timer is complete, it must use <a class="el" href="lbm_8h.html#cd48cd37dda3e76c9daa7b7a939846e4" title="Extended cancel a previously scheduled timer identified by id.">lbm_cancel_timer_ex()</a>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#6ddbee95ee1eb4e6b98b177f84157f8a" title="Schedule a timer that calls proc when it expires.">lbm_schedule_timer</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the UM context object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>The identifier specifying the timer to cancel </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientdp</em>&nbsp;</td><td>Pointer to a client data pointer. This function sets it to the client data pointer supplied by the <a class="el" href="lbm_8h.html#6ddbee95ee1eb4e6b98b177f84157f8a" title="Schedule a timer that calls proc when it expires.">lbm_schedule_timer()</a>. If the caller does not need the client data, it can pass NULL as <em>clientdp</em>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cd48cd37dda3e76c9daa7b7a939846e4"></a><!-- doxytag: member="lbm.h::lbm_cancel_timer_ex" ref="cd48cd37dda3e76c9daa7b7a939846e4" args="(lbm_context_t *ctx, int id, void **clientdp, lbm_event_queue_cancel_cb_info_t *cbinfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_cancel_timer_ex           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>clientdp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__event__queue__cancel__cb__info__t__stct.html">lbm_event_queue_cancel_cb_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cbinfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cancel a previously scheduled timer, with an application callback indicating when the timer is fully canceled. The timer is identified by the return value of the <a class="el" href="lbm_8h.html#6ddbee95ee1eb4e6b98b177f84157f8a" title="Schedule a timer that calls proc when it expires.">lbm_schedule_timer()</a> function. If the passed-in timer ID is not valid, this cancel function returns success, which occurs if the passed-in timer ID has already fired or if the timer ID is garbage. This extended version of the timer cancel function requires the configuration option queue_cancellation_callbacks_enabled be set to 1.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#6ddbee95ee1eb4e6b98b177f84157f8a" title="Schedule a timer that calls proc when it expires.">lbm_schedule_timer</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the UM context object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>The identifier specifying the timer to cancel </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientdp</em>&nbsp;</td><td>Pointer to a client data pointer. This function sets it to the client data pointer supplied by the <a class="el" href="lbm_8h.html#6ddbee95ee1eb4e6b98b177f84157f8a" title="Schedule a timer that calls proc when it expires.">lbm_schedule_timer()</a>. If the caller does not need the client data, it can pass NULL as <em>clientdp</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbinfo</em>&nbsp;</td><td>Cancellation callback information, containing the event queue, function pointer, and client data for the callback. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ecac05969bba0d6057589ca03dfe60a2"></a><!-- doxytag: member="lbm.h::lbm_config" ref="ecac05969bba0d6057589ca03dfe60a2" args="(const char *fname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_config           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fname</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fname</em>&nbsp;</td><td>String containing the file name or URL (tftp or http) that contains the options to parse and set. File names with a ".xml" extension will be passed to <a class="el" href="lbm_8h.html#b1dc9d6fa0a9af0399a61a8d6029cf73" title="Load a UM XML configuration file.">lbm_config_xml_file()</a> with a NULL application name. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b1dc9d6fa0a9af0399a61a8d6029cf73"></a><!-- doxytag: member="lbm.h::lbm_config_xml_file" ref="b1dc9d6fa0a9af0399a61a8d6029cf73" args="(const char *url, const char *application_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_config_xml_file           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>application_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse the xml configuration file specified by url, and apply the configuration for the given application name. UM XML configuration may only be loaded once in the lifetime of a process. If the LBM_UMM_INFO or LBM_XML_CONFIG_FILENAME environment variables are set and they are successful in setting UM XML configuration, this API will have no effect and return -1. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>url</em>&nbsp;</td><td>String containing the path to the XML configuration file. A URL beginning with <a href="http://">http://</a> or <a href="ftp://">ftp://</a> may also be provided. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>application_name</em>&nbsp;</td><td>The name of this application which must match an application tag in the XML configuration file. This parameter may be NULL, in which case the application tag with no name is matched. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c3cb9ed202d10200b9e621f499556159"></a><!-- doxytag: member="lbm.h::lbm_config_xml_string" ref="c3cb9ed202d10200b9e621f499556159" args="(const char *xml_data, const char *application_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_config_xml_string           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>xml_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>application_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parse the xml configuration data contained in xml_data, and apply the configuration for the given application name. UM XML configuration may only be loaded once in the lifetime of a process. If the LBM_UMM_INFO or LBM_XML_CONFIG_FILENAME environment variables are set and they are successful in setting UM XML configuration, this API will have no effect and return -1. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xml_data</em>&nbsp;</td><td>String containing UM XML configuration data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>application_name</em>&nbsp;</td><td>The name of this application which must match an application tag in the XML configuration data. This parameter may be NULL, in which case the application tag with no name is matched. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="066c0eb289bf4afcefac86a1109fca1e"></a><!-- doxytag: member="lbm.h::lbm_context_attr_create" ref="066c0eb289bf4afcefac86a1109fca1e" args="(lbm_context_attr_t **attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_attr_create           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_attr_t **&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is allocated and filled with the current default values that are used by lbm_context_t objects and may have been modified by a previously loaded configuration file.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a pointer to a UM context attribute structure. Will be filled in by this function to point to the newly created lbm_context_attr_t object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="04c6b79859bc07f4cc6c9008242e77f7"></a><!-- doxytag: member="lbm.h::lbm_context_attr_create_default" ref="04c6b79859bc07f4cc6c9008242e77f7" args="(lbm_context_attr_t **attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_attr_create_default           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_attr_t **&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is allocated and filled with the initial or factory default values built into LBM that are used by lbm_context_t objects.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a pointer to a UM context attribute structure. Will be filled in by this function to point to the newly created lbm_context_attr_t object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="04d99cc97d32f359888c5befcc50512e"></a><!-- doxytag: member="lbm.h::lbm_context_attr_create_from_xml" ref="04d99cc97d32f359888c5befcc50512e" args="(lbm_context_attr_t **attr, const char *context_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_attr_create_from_xml           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_attr_t **&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>context_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is allocated and filled with the current default values that are used by lbm_context_t objects and may have been modified by a previously loaded configuration file. Then, if an XML configuration file has been loaded, the attribute object is further filled with the defaults for the given context name. If the context name is not permitted by the XML configuration, -1 is returned and no attribute object is created.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a pointer to a UM context attribute structure. Will be filled in by this function to point to the newly created lbm_context_attr_t object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>context_name</em>&nbsp;</td><td>The context name used to lookup this context in the XML configuration. A NULL value is permitted, and will match unnamed contexts defined in the XML. The context name is also written into the attribute object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9c0a3c1f4a8854d8ec5585392c817c85"></a><!-- doxytag: member="lbm.h::lbm_context_attr_delete" ref="9c0a3c1f4a8854d8ec5585392c817c85" args="(lbm_context_attr_t *attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_attr_delete           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is cleaned up and deleted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM context attribute object as returned by <a class="el" href="lbm_8h.html#066c0eb289bf4afcefac86a1109fca1e" title="Create and fill a UM context attribute object with the current default values.">lbm_context_attr_create</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="43f6029ad772e29b61c2a5c78f961073"></a><!-- doxytag: member="lbm.h::lbm_context_attr_dump" ref="43f6029ad772e29b61c2a5c78f961073" args="(lbm_context_attr_t *cattr, int *size, lbm_config_option_t *opts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_attr_dump           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_attr_t *&nbsp;</td>
          <td class="paramname"> <em>cattr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_config_option_t *&nbsp;</td>
          <td class="paramname"> <em>opts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The config object is filled with context configuration options <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cattr</em>&nbsp;</td><td>The context attribute object to retrieve the attributes from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the opts array. Will return the number of items that were set in opts </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opts</em>&nbsp;</td><td>The options array to fill </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6dc1f21c3be74fbed3f96800cfd6a0b0"></a><!-- doxytag: member="lbm.h::lbm_context_attr_dup" ref="6dc1f21c3be74fbed3f96800cfd6a0b0" args="(lbm_context_attr_t **attr, const lbm_context_attr_t *original)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_attr_dup           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_attr_t **&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lbm_context_attr_t *&nbsp;</td>
          <td class="paramname"> <em>original</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A new attribute object is created as a copy of an existing object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a pointer to a UM context attribute structure. Will be filled in by this function to point to the newly created lbm_context_attr_t object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>original</em>&nbsp;</td><td>Pointer to a UM context attribute object as returned by <a class="el" href="lbm_8h.html#066c0eb289bf4afcefac86a1109fca1e" title="Create and fill a UM context attribute object with the current default values.">lbm_context_attr_create</a> or <a class="el" href="lbm_8h.html#04c6b79859bc07f4cc6c9008242e77f7" title="Create and fill a UM context attribute object with the initial default values.">lbm_context_attr_create_default</a>, from which <em>attr</em> is initialized. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0e578b4f0005589f6558d15e55be8483"></a><!-- doxytag: member="lbm.h::lbm_context_attr_getopt" ref="0e578b4f0005589f6558d15e55be8483" args="(lbm_context_attr_t *attr, const char *optname, void *optval, size_t *optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_attr_getopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM context attributed object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the option value structure to be filled. The structure of the option values are specific to the options themselves. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>Length (in bytes) of the <em>optval</em> structure when passed in. Upon return, this is set to the size of the optval filled in structure. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a59c23a0e0800eed74e5c3c3b8a668ae"></a><!-- doxytag: member="lbm.h::lbm_context_attr_option_size" ref="a59c23a0e0800eed74e5c3c3b8a668ae" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_attr_option_size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function returns the number of entries that are of type "context"<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of entries that are of type "context" </dd></dl>

</div>
</div><p>
<a class="anchor" name="3a97ec59981f5b863b0b40faf82eceb8"></a><!-- doxytag: member="lbm.h::lbm_context_attr_set_from_xml" ref="3a97ec59981f5b863b0b40faf82eceb8" args="(lbm_context_attr_t *attr, const char *context_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_attr_set_from_xml           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>context_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is filled with the default values for the given context name, if an XML configuration file has been loaded. If the context name is not permitted by the XML configuration, -1 is returned and no values are set.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a UM context attribute structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>context_name</em>&nbsp;</td><td>The context name used to lookup this context in the XML configuration. A NULL value is permitted, and will match unnamed contexts defined in the XML. The context name is also written into the attribute object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b67f641d5a0ad1a9fe53d415da58d961"></a><!-- doxytag: member="lbm.h::lbm_context_attr_setopt" ref="b67f641d5a0ad1a9fe53d415da58d961" args="(lbm_context_attr_t *attr, const char *optname, const void *optval, size_t optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_attr_setopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used before the context is created. NOTE: the attribute object must first be initialized with the corresponding _attr_create() function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM context attribute object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the option value structure. The structure of the option values are specific to the options themselves. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>Length (in bytes) of the <em>optval</em> structure. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2db2f7a5a7195106d49089f21a2ecced"></a><!-- doxytag: member="lbm.h::lbm_context_attr_str_getopt" ref="2db2f7a5a7195106d49089f21a2ecced" args="(lbm_context_attr_t *attr, const char *optname, char *optval, size_t *optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_attr_str_getopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM context attributed object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the string to be filled in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>Maximum length (in bytes) of the <em>string</em> when passed in. Upon return, this is set to the size of the formatted string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f45c2cec5557da4057a0c96f305d6a40"></a><!-- doxytag: member="lbm.h::lbm_context_attr_str_setopt" ref="f45c2cec5557da4057a0c96f305d6a40" args="(lbm_context_attr_t *attr, const char *optname, const char *optval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_attr_str_setopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used before the context is created. NOTE: the attribute object must first be initialized with the corresponding _attr_create() function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM context attributed object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>String containing the option value. The format of the string is specific to the option itself. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8058947690bd0995bc2c59d4a61b462f"></a><!-- doxytag: member="lbm.h::lbm_context_create" ref="8058947690bd0995bc2c59d4a61b462f" args="(lbm_context_t **ctxp, const lbm_context_attr_t *attr, lbm_daemon_event_cb_proc proc, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_create           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t **&nbsp;</td>
          <td class="paramname"> <em>ctxp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lbm_context_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lbm_8h.html#3d21707bec0da738e48a6166a56f3f06">lbm_daemon_event_cb_proc</a>&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>clientd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This creates an instance of the UM main processing element, a UM context. Sources and Receivers are created from a UM context and work within that context. For the Embedded operational mode, a thread is spawned to handle event processing. For Sequential operational mode, the application "donates" an execution thread by calling <a class="el" href="lbm_8h.html#d9416b1f0b474b5d4c4f39bb3c4bda77" title="Process internal events in the given UM context object.">lbm_context_process_events()</a>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#962bfceb336c65191ba08497ac70602b" title="Delete a UM context object.">lbm_context_delete()</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctxp</em>&nbsp;</td><td>A pointer to a pointer to a UM context object. Will be filled in by this function to point to the newly created lbm_context_t object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a UM context attribute object. A value of NULL will use default attributes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>A callback function to call when events occur on the UM daemon connection. NOTE: daemon mode is no longer available; this parameter is retained for for backward compatibility only. Please pass NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data to pass into the UM daemon event callback. NOTE: daemon mode is no longer available; this parameter is retained for for backward compatibility only. Please pass NULL. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="962bfceb336c65191ba08497ac70602b"></a><!-- doxytag: member="lbm.h::lbm_context_delete" ref="962bfceb336c65191ba08497ac70602b" args="(lbm_context_t *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_delete           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from a context thread callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to a UM context object to delete. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4018719af554eac487e60172d35e871a"></a><!-- doxytag: member="lbm.h::lbm_context_delete_ex" ref="4018719af554eac487e60172d35e871a" args="(lbm_context_t *ctx, lbm_event_queue_cancel_cb_info_t *cbinfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_delete_ex           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__event__queue__cancel__cb__info__t__stct.html">lbm_event_queue_cancel_cb_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cbinfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from a context thread callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to a UM context object to delete. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbinfo</em>&nbsp;</td><td>Cancellation callback information, containing the event queue, function pointer, and client data for the callback. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="b9a61cde092850b61acc474f9b45d7a0"></a><!-- doxytag: member="lbm.h::lbm_context_dump" ref="b9a61cde092850b61acc474f9b45d7a0" args="(lbm_context_t *ctx, int *size, lbm_config_option_t *opts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_dump           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_config_option_t *&nbsp;</td>
          <td class="paramname"> <em>opts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The config object is filled with context configuration options <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>The context object to retrieve the attributes from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the opts array. Will return the number of items that were set in opts </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opts</em>&nbsp;</td><td>The options array to fill </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fdb049743c04a16a1e2dd8c6fe121148"></a><!-- doxytag: member="lbm.h::lbm_context_from_rcv" ref="fdb049743c04a16a1e2dd8c6fe121148" args="(lbm_rcv_t *rcv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL lbm_context_t* lbm_context_from_rcv           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>rcv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>Pointer to a UM receiver object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the UM context object associated with the UM receiver object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1fe217c6b1ecc8b796e8e1977a1a0f7a"></a><!-- doxytag: member="lbm.h::lbm_context_from_src" ref="1fe217c6b1ecc8b796e8e1977a1a0f7a" args="(lbm_src_t *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL lbm_context_t* lbm_context_from_src           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to a UM source object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the UM context object associated with the UM source object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="924008a73d7ee244027443e1d9ac5cd6"></a><!-- doxytag: member="lbm.h::lbm_context_from_wildcard_rcv" ref="924008a73d7ee244027443e1d9ac5cd6" args="(lbm_wildcard_rcv_t *wcrcv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL lbm_context_t* lbm_context_from_wildcard_rcv           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>wcrcv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wcrcv</em>&nbsp;</td><td>Pointer to a UM wildcard receiver object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the LBM context object associated with the LBM wildcard receiver object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="560203dca8edb43c74db155bb958e6ae"></a><!-- doxytag: member="lbm.h::lbm_context_get_name" ref="560203dca8edb43c74db155bb958e6ae" args="(lbm_context_t *ctx, char *name, size_t *size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_get_name           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to an existing UM context object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Pointer to a buffer into which is stored the context name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Pointer to a variable holding the size of the buffer. If the buffer is not large enough, this will be filled in with the required size. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="4e8a7c286aecb0dfa9a216149d8bcae8"></a><!-- doxytag: member="lbm.h::lbm_context_getopt" ref="4e8a7c286aecb0dfa9a216149d8bcae8" args="(lbm_context_t *ctx, const char *optname, void *optval, size_t *optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_getopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to a UM context object where the option is stored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the option value structure. The structure of the option values are specific to the options themselves. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>When passed, this is the max length (in bytes) of the <em>optval</em> structure. When returned, this is the length of the filled in <em>optval</em> structure. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="00e558f182c07f4187de00ce6132ad20"></a><!-- doxytag: member="lbm.h::lbm_context_lbtipc_unblock" ref="00e558f182c07f4187de00ce6132ad20" args="(lbm_context_t *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_lbtipc_unblock           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When transport_lbtipc_receiver_operational_mode is set to LBM_CTX_ATTR_OP_SEQUENTIAL (or "sequential"), then it is the responsibility of the application to explicitly process LBT-IPC messages for the UM context. This function allows an application to cause <a class="el" href="lbm_8h.html#8729a284ef9f01f329fbf0edbc147227" title="Process LBT-IPC messages received.">lbm_context_process_lbtipc_messages()</a> to immediately return instead of continuing to process messages.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the UM context object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d9416b1f0b474b5d4c4f39bb3c4bda77"></a><!-- doxytag: member="lbm.h::lbm_context_process_events" ref="d9416b1f0b474b5d4c4f39bb3c4bda77" args="(lbm_context_t *ctx, lbm_ulong_t msec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_process_events           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_ulong_t&nbsp;</td>
          <td class="paramname"> <em>msec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When opmode is set to LBM_CTX_ATTR_OP_SEQUENTIAL (or "sequential"), then it is the responsibility of the application to explicitly process events for the UM context. This function will process timers and file descriptor/socket events for internal processing as well as API timer and file descriptor/socket events. The application thread that is processing events must remain active until the context is deleted.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from a context thread callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the UM context object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msec</em>&nbsp;</td><td>Continue event processing loop for at least <em>msec</em> milliseconds before returning. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>It is the responsibility of the application to "unblock" this function using "lbm_context_unblock()" and cease further calls before deleting the UM context. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8729a284ef9f01f329fbf0edbc147227"></a><!-- doxytag: member="lbm.h::lbm_context_process_lbtipc_messages" ref="8729a284ef9f01f329fbf0edbc147227" args="(lbm_context_t *ctx, lbm_ulong_t msec, lbm_ulong_t loop_count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_process_lbtipc_messages           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_ulong_t&nbsp;</td>
          <td class="paramname"> <em>msec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_ulong_t&nbsp;</td>
          <td class="paramname"> <em>loop_count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When transport_lbtipc_receiver_operational_mode is set to LBM_CTX_ATTR_OP_SEQUENTIAL (or "sequential"), then it is the responsibility of the application to explicitly process LBT-IPC messages for the UM context. This function will satisfy that requirement.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from a context thread callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the UM context object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msec</em>&nbsp;</td><td>Only used if transport_lbtipc_receiver_thread_behavior is set to "pend". The timeout in milliseconds of the pend waiting for new data (actual Operating System resolution may vary). Defaults to no timeout on Operating Systems that do not support a timeout (e.g. Mac OS X). A value of zero will result in "busy_wait" like behavior on all Operating Systems. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>loop_count</em>&nbsp;</td><td>Number of loops before returning whether or not data has been received. Zero results in looping forever. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>It is the responsibility of the application to "unblock" this function using <a class="el" href="lbm_8h.html#00e558f182c07f4187de00ce6132ad20" title="Unblock a sequential mode LBT-IPC processing loop.">lbm_context_lbtipc_unblock()</a> and cease further calls before deleting the UM context. </dd></dl>

</div>
</div><p>
<a class="anchor" name="374f135dddf7794130509f97b1e96cf8"></a><!-- doxytag: member="lbm.h::lbm_context_rcv_immediate_msgs" ref="374f135dddf7794130509f97b1e96cf8" args="(lbm_context_t *ctx, lbm_immediate_msg_cb_proc proc, void *clientd, lbm_event_queue_t *evq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_rcv_immediate_msgs           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lbm_8h.html#7947fbc8b37e649ff36cc9ca66ef2dc7">lbm_immediate_msg_cb_proc</a>&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>clientd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to a UM context object that listens for messages. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>Pointer to a function to call when a message arrives. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data passed when a message is delivered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>Optional Event Queue to place messages on when they arrive. If NULL causes <em>proc</em> to be called from context thread. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bdefbb3bd3ff3a3b2ec6e20ca2f5dc19"></a><!-- doxytag: member="lbm.h::lbm_context_rcv_immediate_topic_msgs" ref="bdefbb3bd3ff3a3b2ec6e20ca2f5dc19" args="(lbm_context_t *ctx, lbm_immediate_msg_cb_proc proc, void *clientd, lbm_event_queue_t *evq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_rcv_immediate_topic_msgs           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lbm_8h.html#7947fbc8b37e649ff36cc9ca66ef2dc7">lbm_immediate_msg_cb_proc</a>&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>clientd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to a UM context object that listens for messages. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>Pointer to a function to call when a message arrives. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data passed when a message is delivered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>Optional Event Queue to place messages on when they arrive. If NULL causes <em>proc</em> to be called from context thread. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="32329ebe3c2179efdada11a8766cfa79"></a><!-- doxytag: member="lbm.h::lbm_context_reactor_only_create" ref="32329ebe3c2179efdada11a8766cfa79" args="(lbm_context_t **ctxp, const lbm_context_attr_t *attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_reactor_only_create           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t **&nbsp;</td>
          <td class="paramname"> <em>ctxp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lbm_context_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This creates an instance of the UM main processing element, a UM context. However, this version of the context is only usable for timer and file descriptor event handling. It can not be used for source or receiver creation, etc. For the Embedded operational mode, a thread is spawned to handle event processing. For Sequential operational mode, the application "donates" an execution thread by calling <a class="el" href="lbm_8h.html#d9416b1f0b474b5d4c4f39bb3c4bda77" title="Process internal events in the given UM context object.">lbm_context_process_events()</a>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#8058947690bd0995bc2c59d4a61b462f" title="Create and initialize an lbm_context_t object.">lbm_context_create</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctxp</em>&nbsp;</td><td>A pointer to a pointer to a UM context object. Will be filled in by this function to point to the newly created lbm_context_t object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a UM context attribute object. A value of NULL will use default attributes. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e776bad129eb68dfd548d1f7d70ae848"></a><!-- doxytag: member="lbm.h::lbm_context_reset_im_rcv_transport_stats" ref="e776bad129eb68dfd548d1f7d70ae848" args="(lbm_context_t *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_reset_im_rcv_transport_stats           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the UM context to reset statistics for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stats</em>&nbsp;</td><td>Pointer to a stats structure to fill in. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure and 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c4ea73752995bb541b9eacad59815bd0"></a><!-- doxytag: member="lbm.h::lbm_context_reset_im_src_transport_stats" ref="c4ea73752995bb541b9eacad59815bd0" args="(lbm_context_t *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_reset_im_src_transport_stats           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the UM context to reset statistics for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stats</em>&nbsp;</td><td>Pointer to a stats structure to fill in. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure and 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9920a312bc7b52f20133ddbdd430a075"></a><!-- doxytag: member="lbm.h::lbm_context_reset_rcv_transport_stats" ref="9920a312bc7b52f20133ddbdd430a075" args="(lbm_context_t *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_reset_rcv_transport_stats           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the UM context to reset statistics for. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure and 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fe25aeb42965853a836488a4ed6d905e"></a><!-- doxytag: member="lbm.h::lbm_context_reset_src_transport_stats" ref="fe25aeb42965853a836488a4ed6d905e" args="(lbm_context_t *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_reset_src_transport_stats           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the UM context to reset statistics for. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure and 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="11a95d8df314fb8dd95e6fa428dc1d64"></a><!-- doxytag: member="lbm.h::lbm_context_reset_stats" ref="11a95d8df314fb8dd95e6fa428dc1d64" args="(lbm_context_t *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_reset_stats           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the UM context to reset statistics for. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure and 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3a167b88f0a789dce27eb77160a9d2f2"></a><!-- doxytag: member="lbm.h::lbm_context_retrieve_im_rcv_transport_stats" ref="3a167b88f0a789dce27eb77160a9d2f2" args="(lbm_context_t *ctx, int *num, int size, lbm_rcv_transport_stats_t *stats)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_retrieve_im_rcv_transport_stats           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__rcv__transport__stats__t__stct.html">lbm_rcv_transport_stats_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stats</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the UM context to retrieve statistics for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>Pointer to an integer that must hold the maximum number of elements in the stats array when passed in. Upon return, this value is set to the number of sources filled in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size in bytes of each entry in <em>stats</em> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stats</em>&nbsp;</td><td>Array of lbm_rcv_transport_stats_t objects to fill in transport stats for. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure and 0 for Success. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If -1 is returned, and <a class="el" href="lbm_8h.html#f3a827eb26d87be5b1a6b9fd3a4b63aa" title="Return the error number last encountered by this thread.">lbm_errnum()</a> returns LBM_EINVAL, then <em>*num</em> may contain a larger number than the value originally passed into this function. This return value represents the number of lbm_rcv_transport_stats_t objects required in the <em>stats</em> array and can be used to dynamically determine how many entries are needed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="deb93551e63dcb44a871f2fd97d3b87f"></a><!-- doxytag: member="lbm.h::lbm_context_retrieve_im_src_transport_stats" ref="deb93551e63dcb44a871f2fd97d3b87f" args="(lbm_context_t *ctx, int *num, int size, lbm_src_transport_stats_t *stats)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_retrieve_im_src_transport_stats           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__src__transport__stats__t__stct.html">lbm_src_transport_stats_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stats</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the UM context to retrieve statistics for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>Pointer to an integer that must hold the maximum number of elements in the stats array when passed in. Upon return, this value is set to the number of sources filled in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size in bytes of each entry in <em>stats</em> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stats</em>&nbsp;</td><td>Array of lbm_src_transport_stats_t objects to fill in transport stats for. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure and 0 for Success. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If -1 is returned, and <a class="el" href="lbm_8h.html#f3a827eb26d87be5b1a6b9fd3a4b63aa" title="Return the error number last encountered by this thread.">lbm_errnum()</a> returns LBM_EINVAL, then <em>*num</em> may contain a larger number than the value originally passed into this function. This return value represents the number of lbm_src_transport_stats_t objects required in the <em>stats</em> array and can be used to dynamically determine how many entries are needed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="147a3639e45780731e3a2a37adb529f2"></a><!-- doxytag: member="lbm.h::lbm_context_retrieve_rcv_transport_stats" ref="147a3639e45780731e3a2a37adb529f2" args="(lbm_context_t *ctx, int *num, lbm_rcv_transport_stats_t *stats)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_retrieve_rcv_transport_stats           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__rcv__transport__stats__t__stct.html">lbm_rcv_transport_stats_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stats</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the UM context to retrieve statistics for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>Pointer to an integer that must hold the maximum number of elements in the stats array when passed in. Upon return, this value is set to the number of sources filled in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stats</em>&nbsp;</td><td>Array of lbm_rcv_transport_stats_t objects to fill in transport stats for. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure and 0 for Success. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If -1 is returned, and <a class="el" href="lbm_8h.html#f3a827eb26d87be5b1a6b9fd3a4b63aa" title="Return the error number last encountered by this thread.">lbm_errnum()</a> returns LBM_EINVAL, then <em>*num</em> may contain a larger number than the value originally passed into this function. This return value represents the number of lbm_rcv_transport_stats_t objects required in the <em>stats</em> array and can be used to dynamically determine how many entries are needed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="14e652f7827e5abfe07fcd3522b19b44"></a><!-- doxytag: member="lbm.h::lbm_context_retrieve_src_transport_stats" ref="14e652f7827e5abfe07fcd3522b19b44" args="(lbm_context_t *ctx, int *num, lbm_src_transport_stats_t *stats)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_retrieve_src_transport_stats           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__src__transport__stats__t__stct.html">lbm_src_transport_stats_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stats</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the UM context to retrieve statistics for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>Pointer to an integer that must hold the maximum number of elements in the stats array when passed in. Upon return, this value is set to the number of sources filled in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stats</em>&nbsp;</td><td>Array of lbm_src_transport_stats_t objects to fill in transport stats for. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure and 0 for Success. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If -1 is returned, and <a class="el" href="lbm_8h.html#f3a827eb26d87be5b1a6b9fd3a4b63aa" title="Return the error number last encountered by this thread.">lbm_errnum()</a> returns LBM_EINVAL, then <em>*num</em> may contain a larger number than the value originally passed into this function. This return value represents the number of lbm_src_transport_stats_t objects required in the <em>stats</em> array and can be used to dynamically determine how many entries are needed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a8f2d2e5b28e2c97911117acb099c48e"></a><!-- doxytag: member="lbm.h::lbm_context_retrieve_stats" ref="a8f2d2e5b28e2c97911117acb099c48e" args="(lbm_context_t *ctx, lbm_context_stats_t *stats)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_retrieve_stats           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__context__stats__t__stct.html">lbm_context_stats_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stats</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the UM context to retrieve statistics for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stats</em>&nbsp;</td><td>Pointer to a stats structure to fill in. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure and 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="32682ab7b6432a84e5d3e26c30ad6c9c"></a><!-- doxytag: member="lbm.h::lbm_context_set_name" ref="32682ab7b6432a84e5d3e26c30ad6c9c" args="(lbm_context_t *ctx, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_set_name           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to an existing UM context object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The context name. Context names are limited in length to 128 characters (not including the final null) and restricted to alphanumeric characters, hyphens, and underscores. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7debaa78e85dac5ce8db71a5e1935b65"></a><!-- doxytag: member="lbm.h::lbm_context_setopt" ref="7debaa78e85dac5ce8db71a5e1935b65" args="(lbm_context_t *ctx, const char *optname, const void *optval, size_t optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_setopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Only those options that can be set during operation may be specified. See "Options That May Be Set During Operation" (doc/Config/maybesetduringoperation.html) in The UM Configuration Guide. For API functions that can access any option, see lbm_context_attr_*(). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to a UM context object where the option is to be set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the option value structure. The structure of the option values are specific to the options themselves. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>Length (in bytes) of the <em>optval</em> structure. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="50146c00b603ee92376958034df8d3b4"></a><!-- doxytag: member="lbm.h::lbm_context_str_getopt" ref="50146c00b603ee92376958034df8d3b4" args="(lbm_context_t *ctx, const char *optname, char *optval, size_t *optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_str_getopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to a UM context object where the option is stored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>String to hold the option value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>When passed, this is the max length (in bytes) of the string. When returned, this is the length of the filled in option value. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6ac71262b2016486e02c217536503744"></a><!-- doxytag: member="lbm.h::lbm_context_str_setopt" ref="6ac71262b2016486e02c217536503744" args="(lbm_context_t *ctx, const char *optname, const char *optval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_str_setopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Only those options that can be set during operation may be specified. See "Options That May Be Set During Operation" (doc/Config/maybesetduringoperation.html) in The UM Configuration Guide. For API functions that can access any option, see lbm_context_attr_*(). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to a UM context object where the option is to be set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>String containing the option value. The format of the string is specific to the options themselves. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e6dd7c56acf916ef66658cc1ebc7a525"></a><!-- doxytag: member="lbm.h::lbm_context_topic_resolution_request" ref="e6dd7c56acf916ef66658cc1ebc7a525" args="(lbm_context_t *ctx, lbm_ushort_t flags, lbm_ulong_t interval_msec, lbm_ulong_t duration_sec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_topic_resolution_request           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_ushort_t&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_ulong_t&nbsp;</td>
          <td class="paramname"> <em>interval_msec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_ulong_t&nbsp;</td>
          <td class="paramname"> <em>duration_sec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to a UM context object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags indicating desired requests. ORed set of values. <ul>
<li><code>LBM_TOPIC_RES_REQUEST_ADVERTISEMENT</code> - Request advertisements from quiescent sources. </li>
<li><code>LBM_TOPIC_RES_REQUEST_QUERY</code> - Request queries from quiescent receivers. </li>
<li><code>LBM_TOPIC_RES_REQUEST_WILDCARD_QUERY</code> - Request queries from quiescent wildcard receivers. </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interval_msec</em>&nbsp;</td><td>Interval between requests in milliseconds. Less than 10 should be used with caution. Less than 5 is not recommended. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>duration_sec</em>&nbsp;</td><td>Minimum duration of requests in seconds. Actual duration can be longer depending upon the interval. A value of zero will result in 1 request and the interval will be meaningless. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="d3d4137ff9ac0a1d4431c9d75ee3708c"></a><!-- doxytag: member="lbm.h::lbm_context_unblock" ref="d3d4137ff9ac0a1d4431c9d75ee3708c" args="(lbm_context_t *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_context_unblock           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When opmode is set to LBM_CTX_ATTR_OP_SEQUENTIAL (or "sequential"), then it is the responsibility of the application to explicitly process events for the UM context. This function allows an application to cause lbm_process_events() to immediately return instead of continuing to process events. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the UM context object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="46908e2e0546293b0ae217d12f007751"></a><!-- doxytag: member="lbm.h::lbm_create_random_id" ref="46908e2e0546293b0ae217d12f007751" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL lbm_uint64_t lbm_create_random_id           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a random 64 bit long. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ac6015a6a8e914c6e621e3b28940fe87"></a><!-- doxytag: member="lbm.h::lbm_ctx_umq_get_inflight" ref="ac6015a6a8e914c6e621e3b28940fe87" args="(lbm_context_t *ctx, const char *qname, int *inflight, lbm_flight_size_set_inflight_cb_proc proc, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_ctx_umq_get_inflight           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>qname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>inflight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lbm_8h.html#c26b2f61ff3e92ff1e1b44f82bbf193b">lbm_flight_size_set_inflight_cb_proc</a>&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>clientd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#c26b2f61ff3e92ff1e1b44f82bbf193b" title="Application callback for lbm_*_flight_size_set_inflight().">lbm_flight_size_set_inflight_cb_proc</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the context. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>qname</em>&nbsp;</td><td>Name of the queue. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inflight</em>&nbsp;</td><td>Pointer to an int whose value will be filled in to reflect the current inflight. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>Optional callback that allows an application to set the current inflight. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Optional client data passed into the proc. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success, -1 for failure if the proc returns a negative value. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f9a26658b4ad8348f31369f77f9922de"></a><!-- doxytag: member="lbm.h::lbm_ctx_umq_queue_topic_list" ref="f9a26658b4ad8348f31369f77f9922de" args="(lbm_context_t *ctx, const char *queue_name, lbm_async_operation_func_t *async_opfunc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_ctx_umq_queue_topic_list           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>queue_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__async__operation__func__t.html">lbm_async_operation_func_t</a> *&nbsp;</td>
          <td class="paramname"> <em>async_opfunc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The returned list of topics is complete once the asynchronous operation callback is called with an LBM_ASYNC_OP_STATUS_COMPLETE. Each returned lbm_umq_queue_topic_t object also contains the application sets associated with that topic and receiver type IDs associated with each application set.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#2925e71ec6de6fbc4e062719d2241afb" title="Structure that holds queue topic information and can be used as a handle to a queue...">lbm_umq_queue_topic_t</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>LBM context object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>queue_name</em>&nbsp;</td><td>Name of the queue to retrieve a topic list from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>async_opfunc</em>&nbsp;</td><td>The asynchronous operation callback the topic list will be delivered to. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fa8497a41108dc0ea2ba233db4636aca"></a><!-- doxytag: member="lbm.h::lbm_debug_dump" ref="fa8497a41108dc0ea2ba233db4636aca" args="(const char *filename, int append)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_debug_dump           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>append</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>to open and dump debug log events to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>append</em>&nbsp;</td><td>Flag to indicate that the dump should be appended to the file or overwrite the file </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0bd19501e6a545a2e5ec555ff257288a"></a><!-- doxytag: member="lbm.h::lbm_debug_filename" ref="0bd19501e6a545a2e5ec555ff257288a" args="(const char *filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL void lbm_debug_filename           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>May be overridden by environment variable </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>to open and send log events to </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="712771b8dcd34466c83bc63fa4186371"></a><!-- doxytag: member="lbm.h::lbm_debug_mask" ref="712771b8dcd34466c83bc63fa4186371" args="(lbm_uint64_t mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL void lbm_debug_mask           </td>
          <td>(</td>
          <td class="paramtype">lbm_uint64_t&nbsp;</td>
          <td class="paramname"> <em>mask</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>May be overridden by environment variable </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>of debug log events to log (contact support for more information) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d74f47a1e021b2422b80c0bf8d03f7a9"></a><!-- doxytag: member="lbm.h::lbm_deserialize_response" ref="d74f47a1e021b2422b80c0bf8d03f7a9" args="(lbm_context_t *ctx, lbm_serialized_response_t *serialized_response)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL lbm_response_t* lbm_deserialize_response           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__serialized__response__t__stct.html">lbm_serialized_response_t</a> *&nbsp;</td>
          <td class="paramname"> <em>serialized_response</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
De-serializes a serialized UM response object, making it usable for <a class="el" href="lbm_8h.html#0bbc01b600ccc2ae874474e35955eb85" title="Send a response for a given resp response.">lbm_send_response()</a>. Note that the returned lbm_response_t object should be treated as any other normal response object, and deleted by the application using <a class="el" href="lbm_8h.html#95bbc6a8adcdc3217ee3ee4d24f3a70e" title="Delete a UM response object.">lbm_response_delete()</a> as appropriate.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>A pointer to a UM context object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>serialized_response</em>&nbsp;</td><td>A pointer to a serialized UM response object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to a lbm_response_t object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="22a4650d3a5b649c84a0c05adedcc055"></a><!-- doxytag: member="lbm.h::lbm_errmsg" ref="22a4650d3a5b649c84a0c05adedcc055" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL const char* lbm_errmsg           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to a static char array holding the error message. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f3a827eb26d87be5b1a6b9fd3a4b63aa"></a><!-- doxytag: member="lbm.h::lbm_errnum" ref="f3a827eb26d87be5b1a6b9fd3a4b63aa" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_errnum           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Integer error number. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c06b127bae882dd5fb68b7044fdceb5f"></a><!-- doxytag: member="lbm.h::lbm_event_dispatch" ref="c06b127bae882dd5fb68b7044fdceb5f" args="(lbm_event_queue_t *evq, lbm_ulong_t tmo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_event_dispatch           </td>
          <td>(</td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_ulong_t&nbsp;</td>
          <td class="paramname"> <em>tmo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>Event Queue that holds the events to dispatch. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tmo</em>&nbsp;</td><td>The number of milliseconds to block before returning from the function. Note that if no events are posted, the call will continue to block even after the time has past. See <a href="https://communities.informatica.com/infakb/faq/5/Pages/80007.aspx">https://communities.informatica.com/infakb/faq/5/Pages/80007.aspx</a> for details. In addition to numeric values, the following special values are valid: <ul>
<li><code>LBM_EVENT_QUEUE_BLOCK</code> - block indefinitely processing events. </li>
<li><code>LBM_EVENT_QUEUE_POLL</code> - poll and dispatch a single event and return. </li>
</ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt; 0 for Success (number returned is the number of events serviced) or -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f4b1b274cb142acefe0826673ecffdbe"></a><!-- doxytag: member="lbm.h::lbm_event_dispatch_unblock" ref="f4b1b274cb142acefe0826673ecffdbe" args="(lbm_event_queue_t *evq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_event_dispatch_unblock           </td>
          <td>(</td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function enqueues a special event into the event queue that, when processed, causes the thread calling lbm_event_dispatch to return.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>Event Queue on which to enqueue the UNBLOCK event. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a481173def2062eb78401c4b5dee8fa7"></a><!-- doxytag: member="lbm.h::lbm_event_queue_attr_create" ref="a481173def2062eb78401c4b5dee8fa7" args="(lbm_event_queue_attr_t **attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_event_queue_attr_create           </td>
          <td>(</td>
          <td class="paramtype">lbm_event_queue_attr_t **&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is allocated and filled with the current default values that are used by lbm_event_queue_t objects and may have been modified by a previously loaded configuration file.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a pointer to a UM event queue attribute structure. Will be filled in by this function to point to the newly created lbm_event_queue_attr_t object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8a410dd3ec412042412f7206b33f543a"></a><!-- doxytag: member="lbm.h::lbm_event_queue_attr_create_default" ref="8a410dd3ec412042412f7206b33f543a" args="(lbm_event_queue_attr_t **attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_event_queue_attr_create_default           </td>
          <td>(</td>
          <td class="paramtype">lbm_event_queue_attr_t **&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is allocated and filled with the initial or factory default values built into LBM that are used by lbm_event_queue_t objects that concern receivers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a pointer to a UM event queue attribute structure. Will be filled in by this function to point to the newly created lbm_event_queue_attr_t object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f85b737d29883af1e7be47a6e9057c6b"></a><!-- doxytag: member="lbm.h::lbm_event_queue_attr_create_from_xml" ref="f85b737d29883af1e7be47a6e9057c6b" args="(lbm_event_queue_attr_t **attr, const char *event_queue_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_event_queue_attr_create_from_xml           </td>
          <td>(</td>
          <td class="paramtype">lbm_event_queue_attr_t **&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>event_queue_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is allocated and filled with the current default values that are used by lbm_event_queue_t objects and may have been modified by a previously loaded configuration file. Then, if an XML configuration file has been loaded, the attribute object is further filled with the defaults for the given event queue name. If the event queue name is not permitted by the XML configuration, -1 is returned and no attribute object is created.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a pointer to a UM event queue attribute structure. Will be filled in by this function to point to the newly created lbm_event_queue_attr_t object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event_queue_name</em>&nbsp;</td><td>The event queue name used to lookup this event queue in the XML configuration. A NULL value is permitted, and will match unnamed event queues defined in the XML. The event queue name is also written into the attribute object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="dec58e6e7eccd469bc66499b27445cb9"></a><!-- doxytag: member="lbm.h::lbm_event_queue_attr_delete" ref="dec58e6e7eccd469bc66499b27445cb9" args="(lbm_event_queue_attr_t *attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_event_queue_attr_delete           </td>
          <td>(</td>
          <td class="paramtype">lbm_event_queue_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is cleaned up and deleted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM event queue attribute object as returned by <a class="el" href="lbm_8h.html#a481173def2062eb78401c4b5dee8fa7" title="Create and fill a UM event queue attribute object with the current default values...">lbm_event_queue_attr_create</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="09bc0d170eadffe1eb1c30d421074125"></a><!-- doxytag: member="lbm.h::lbm_event_queue_attr_dump" ref="09bc0d170eadffe1eb1c30d421074125" args="(lbm_event_queue_attr_t *eattr, int *size, lbm_config_option_t *opts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_event_queue_attr_dump           </td>
          <td>(</td>
          <td class="paramtype">lbm_event_queue_attr_t *&nbsp;</td>
          <td class="paramname"> <em>eattr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_config_option_t *&nbsp;</td>
          <td class="paramname"> <em>opts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The config object is filled with event queue configuration options <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eattr</em>&nbsp;</td><td>The event queue attribute object to retrieve the attributes from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the opts array. Will return the number of items that were set in opts </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opts</em>&nbsp;</td><td>The options array to fill </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c596c3c5a7483bfef0d888f88e0ffa00"></a><!-- doxytag: member="lbm.h::lbm_event_queue_attr_dup" ref="c596c3c5a7483bfef0d888f88e0ffa00" args="(lbm_event_queue_attr_t **attr, const lbm_event_queue_attr_t *original)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_event_queue_attr_dup           </td>
          <td>(</td>
          <td class="paramtype">lbm_event_queue_attr_t **&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lbm_event_queue_attr_t *&nbsp;</td>
          <td class="paramname"> <em>original</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A new attribute object is created as a copy of an existing object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a pointer to a UM event queue attribute structure. Will be filled in by this function to point to the newly created lbm_event_queue_attr_t object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>original</em>&nbsp;</td><td>Pointer to a UM event queue attribute object as returned by <a class="el" href="lbm_8h.html#a481173def2062eb78401c4b5dee8fa7" title="Create and fill a UM event queue attribute object with the current default values...">lbm_event_queue_attr_create</a> or <a class="el" href="lbm_8h.html#8a410dd3ec412042412f7206b33f543a" title="Create and fill a UM event queue attribute object with the initial default values...">lbm_event_queue_attr_create_default</a>, from which <em>attr</em> is initialized. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4ed2752e3a7617dcb636c05151331302"></a><!-- doxytag: member="lbm.h::lbm_event_queue_attr_getopt" ref="4ed2752e3a7617dcb636c05151331302" args="(lbm_event_queue_attr_t *attr, const char *optname, void *optval, size_t *optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_event_queue_attr_getopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_event_queue_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM event queue attribute object where the option is stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the option value structure. The structure of the option values are specific to the options themselves. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>When passed, this is the max length (in bytes) of the <em>optval</em> structure. When returned, this is the length of the filled in <em>optval</em> structure. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9dfe270c08d183e0f18544d32aa63d9a"></a><!-- doxytag: member="lbm.h::lbm_event_queue_attr_option_size" ref="9dfe270c08d183e0f18544d32aa63d9a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_event_queue_attr_option_size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function returns the number of entries that are of type "event queue"<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of entries that are of type "event queue" </dd></dl>

</div>
</div><p>
<a class="anchor" name="8f376258a2ab5199d8cf8b852ad8a2f8"></a><!-- doxytag: member="lbm.h::lbm_event_queue_attr_set_from_xml" ref="8f376258a2ab5199d8cf8b852ad8a2f8" args="(lbm_event_queue_attr_t *attr, const char *event_queue_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_event_queue_attr_set_from_xml           </td>
          <td>(</td>
          <td class="paramtype">lbm_event_queue_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>event_queue_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is filled with the default values for the given event queue name, if an XML configuration file has been loaded. If the event queue name is not permitted by the XML configuration, -1 is returned and no values are set.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a UM event queue attribute structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>event_queue_name</em>&nbsp;</td><td>The event queue name used to lookup this event queue in the XML configuration. A NULL value is permitted, and will match unnamed event queues defined in the XML. The event queue name is also written into the attribute object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="522ba1e3a48a383693ab84bbc1242751"></a><!-- doxytag: member="lbm.h::lbm_event_queue_attr_setopt" ref="522ba1e3a48a383693ab84bbc1242751" args="(lbm_event_queue_attr_t *attr, const char *optname, const void *optval, size_t optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_event_queue_attr_setopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_event_queue_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used before the event queue is created. NOTE: the attribute object must first be initialized with the corresponding _attr_create() function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM event queue attribute object where the option is to be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the option value structure. The structure of the option values are specific to the options themselves. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>Length (in bytes) of the <em>optval</em> structure. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ea2de962dcdcc1c575d38bd256414988"></a><!-- doxytag: member="lbm.h::lbm_event_queue_attr_str_getopt" ref="ea2de962dcdcc1c575d38bd256414988" args="(lbm_event_queue_attr_t *attr, const char *optname, char *optval, size_t *optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_event_queue_attr_str_getopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_event_queue_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM event queue attribute object where the option is stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>String to be filled in with the option value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>When passed, this is the max length (in bytes) of the string. When returned, this is the length of the filled in option value. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e142407377587720566411c40bcba19f"></a><!-- doxytag: member="lbm.h::lbm_event_queue_attr_str_setopt" ref="e142407377587720566411c40bcba19f" args="(lbm_event_queue_attr_t *attr, const char *optname, const char *optval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_event_queue_attr_str_setopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_event_queue_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used before the event queue is created. NOTE: the attribute object must first be initialized with the corresponding _attr_create() function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM event queue attribute object where the option is to be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>String containing the option value. The format of the string is specific to the options themselves. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c7ebe02319363c84bef08f34be7865ec"></a><!-- doxytag: member="lbm.h::lbm_event_queue_create" ref="c7ebe02319363c84bef08f34be7865ec" args="(lbm_event_queue_t **evqp, lbm_event_queue_monitor_proc proc, void *clientd, const lbm_event_queue_attr_t *attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_event_queue_create           </td>
          <td>(</td>
          <td class="paramtype">lbm_event_queue_t **&nbsp;</td>
          <td class="paramname"> <em>evqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lbm_8h.html#1b4b56862044a11671aebac3ecd15b3a">lbm_event_queue_monitor_proc</a>&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>clientd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lbm_event_queue_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function creates an event queue that may be passed in several functions in order for events/callbacks to be queued for execution.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>evqp</em>&nbsp;</td><td>A pointer to a pointer for the lbm_event_queue_t object created to be stored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>Pointer to function to call when monitoring the event queue. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data returned in the callback proc <em>proc</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to an event queue attribute object or NULL for default attributes. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="189f4c0178374d488acacf592c3015e4"></a><!-- doxytag: member="lbm.h::lbm_event_queue_delete" ref="189f4c0178374d488acacf592c3015e4" args="(lbm_event_queue_t *evq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_event_queue_delete           </td>
          <td>(</td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>An event queue should not be deleted before all other dependent objects (source, receivers, and timers using the event queue) have also been deleted or canceled. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>Event Queue to be deleted. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1ffd0581c0ee8993f12094149f9a960b"></a><!-- doxytag: member="lbm.h::lbm_event_queue_dump" ref="1ffd0581c0ee8993f12094149f9a960b" args="(lbm_event_queue_t *evq, int *size, lbm_config_option_t *opts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_event_queue_dump           </td>
          <td>(</td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_config_option_t *&nbsp;</td>
          <td class="paramname"> <em>opts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The config object is filled with event queue configuration options <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>The event queue object to retrieve the attributes from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the opts array. Will return the number of items that were set in opts </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opts</em>&nbsp;</td><td>The options array to fill </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c1d492d2d5abdce67cca76d50d7940d6"></a><!-- doxytag: member="lbm.h::lbm_event_queue_from_rcv" ref="c1d492d2d5abdce67cca76d50d7940d6" args="(lbm_rcv_t *rcv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL lbm_event_queue_t* lbm_event_queue_from_rcv           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>rcv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>Pointer to a UM receiver object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the UM event queue object associated with the UM receiver object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2326c9d45600ea1265eb1338fd05193c"></a><!-- doxytag: member="lbm.h::lbm_event_queue_from_src" ref="2326c9d45600ea1265eb1338fd05193c" args="(lbm_src_t *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL lbm_event_queue_t* lbm_event_queue_from_src           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to a UM source object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the UM event queue object associated with the UM source object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2814e8e961a67478e5f06469250df922"></a><!-- doxytag: member="lbm.h::lbm_event_queue_from_wildcard_rcv" ref="2814e8e961a67478e5f06469250df922" args="(lbm_wildcard_rcv_t *wcrcv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL lbm_event_queue_t* lbm_event_queue_from_wildcard_rcv           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>wcrcv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wcrcv</em>&nbsp;</td><td>Pointer to a UM wildcard receiver object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the LBM event queue object associated with the LBM wildcard receiver object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b5c77cb8b7818a9658edcb84fc857807"></a><!-- doxytag: member="lbm.h::lbm_event_queue_getopt" ref="b5c77cb8b7818a9658edcb84fc857807" args="(lbm_event_queue_t *evq, const char *optname, void *optval, size_t *optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_event_queue_getopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>Pointer to a UM event queue object where the option is stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the option value structure. The structure of the option values are specific to the options themselves. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>When passed, this is the max length (in bytes) of the <em>optval</em> structure. When returned, this is the length of the filled in <em>optval</em> structure. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1838b8382eb314eed96e6ed48c0d1f5b"></a><!-- doxytag: member="lbm.h::lbm_event_queue_reset_stats" ref="1838b8382eb314eed96e6ed48c0d1f5b" args="(lbm_event_queue_t *evq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_event_queue_reset_stats           </td>
          <td>(</td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>Pointer to the UM event queue to reset statistics for. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure and 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="eb9ed445a630f0db48f8c9d24bf23178"></a><!-- doxytag: member="lbm.h::lbm_event_queue_retrieve_stats" ref="eb9ed445a630f0db48f8c9d24bf23178" args="(lbm_event_queue_t *evq, lbm_event_queue_stats_t *stats)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_event_queue_retrieve_stats           </td>
          <td>(</td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__event__queue__stats__t__stct.html">lbm_event_queue_stats_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stats</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>Pointer to the UM event queue to retrieve statistics for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stats</em>&nbsp;</td><td>Pointer to a stats structure to fill in. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure and 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4851096cebcf925e0e348bacec32aef0"></a><!-- doxytag: member="lbm.h::lbm_event_queue_setopt" ref="4851096cebcf925e0e348bacec32aef0" args="(lbm_event_queue_t *evq, const char *optname, const void *optval, size_t optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_event_queue_setopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Only those options that can be set during operation may be specified. See "Options That May Be Set During Operation" (doc/Config/maybesetduringoperation.html) in The UM Configuration Guide. For API functions that can access any option, see lbm_event_queue_attr_*(). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>Pointer to a UM event queue where the option is to be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the option value structure. The structure of the option values are specific to the options themselves. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>Length (in bytes) of the <em>optval</em> structure. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d94310754a9f685693f789a017c7bb7e"></a><!-- doxytag: member="lbm.h::lbm_event_queue_shutdown" ref="d94310754a9f685693f789a017c7bb7e" args="(lbm_event_queue_t *evq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_event_queue_shutdown           </td>
          <td>(</td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>Event Queue to shutdown. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b0a5134ef39fc7054e5d164f0a1889f7"></a><!-- doxytag: member="lbm.h::lbm_event_queue_size" ref="b0a5134ef39fc7054e5d164f0a1889f7" args="(lbm_event_queue_t *evq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_event_queue_size           </td>
          <td>(</td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This call is only supported when the queue_size_warning config variable is set. If not set, then this function will return -1 and set an EINVAL error.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>Event Queue to determine the size for. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>&gt; 0 indicates the size of the event queue and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5ab263a1c33ba7a9b4ffa72a6a54075c"></a><!-- doxytag: member="lbm.h::lbm_event_queue_str_getopt" ref="5ab263a1c33ba7a9b4ffa72a6a54075c" args="(lbm_event_queue_t *evq, const char *optname, char *optval, size_t *optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_event_queue_str_getopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>Pointer to a UM event queue object where the option is stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>String to be filled in with the option value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>When passed, this is the max length (in bytes) of the string. When returned, this is the length of the filled in with the option value. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e470da93b9bfbcf213afde0a9a95113e"></a><!-- doxytag: member="lbm.h::lbm_event_queue_str_setopt" ref="e470da93b9bfbcf213afde0a9a95113e" args="(lbm_event_queue_t *evq, const char *optname, const char *optval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_event_queue_str_setopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Only those options that can be set during operation may be specified. See "Options That May Be Set During Operation" (doc/Config/maybesetduringoperation.html) in The UM Configuration Guide. For API functions that can access any option, see lbm_event_queue_attr_*(). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>Pointer to a UM event queue object where the option is to be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>String containing the option value. The format of the string is specific to the options themselves. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4e9c820cb8d8c126c3b86d885e09cc29"></a><!-- doxytag: member="lbm.h::lbm_get_jms_msg_id" ref="4e9c820cb8d8c126c3b86d885e09cc29" args="(lbm_uint64_t source_id, lbm_uint64_t seqno_id, char *topic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL char* lbm_get_jms_msg_id           </td>
          <td>(</td>
          <td class="paramtype">lbm_uint64_t&nbsp;</td>
          <td class="paramname"> <em>source_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_uint64_t&nbsp;</td>
          <td class="paramname"> <em>seqno_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>topic</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a JMS Message ID string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c208c246a6e856e24e1130060e1806c3"></a><!-- doxytag: member="lbm.h::lbm_hf_rcv_create" ref="c208c246a6e856e24e1130060e1806c3" args="(lbm_hf_rcv_t **hfrcvp, lbm_context_t *ctx, lbm_topic_t *topic, lbm_rcv_cb_proc proc, void *clientd, lbm_event_queue_t *evq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hf_rcv_create           </td>
          <td>(</td>
          <td class="paramtype">lbm_hf_rcv_t **&nbsp;</td>
          <td class="paramname"> <em>hfrcvp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_topic_t *&nbsp;</td>
          <td class="paramname"> <em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lbm_8h.html#e2d650dd4830971ca0b6197298eddcdd">lbm_rcv_cb_proc</a>&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>clientd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from a context thread callback. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#a7491c50fefbc2b70f8035fce7ac1477" title="Create a UM receiver that will receive messages sent to the given topic.">lbm_rcv_create</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hfrcvp</em>&nbsp;</td><td>A pointer to a pointer to a UM Hot Failover (HF) receiver object. Will be filled in by this function to point to the newly created lbm_fd_rcv_t object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the LBM context object associated with the sender. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>topic</em>&nbsp;</td><td>Pointer to the LBM topic object associated with the desired receiver topic. </td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Topic references should not be reused. Each <a class="el" href="lbm_8h.html#c208c246a6e856e24e1130060e1806c3" title="Create and LBM receiver that will receive LBM Hot Failover (HF) messages sent to...">lbm_hf_rcv_create()</a> call should be preceded by a call to <a class="el" href="lbm_8h.html#3de8a6a659896f76475c453683db4e18" title="Turn a Topic string into a UM topic object usable by receivers.">lbm_rcv_topic_lookup()</a>. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>Pointer to a function to call when messages arrive. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Pointer to client data that is passed when data arrives and <em>proc</em> is called. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>Optional Event Queue to place message events on when they arrive. If NULL causes <em>proc</em> to be called from context thread. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bc68152bcf4d18ef1d31d8f6a15ac080"></a><!-- doxytag: member="lbm.h::lbm_hf_rcv_delete" ref="bc68152bcf4d18ef1d31d8f6a15ac080" args="(lbm_hf_rcv_t *hfrcv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hf_rcv_delete           </td>
          <td>(</td>
          <td class="paramtype">lbm_hf_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>hfrcv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete a UM Hot Failover (HF) receiver object. Note that this function can return while the receivercallback may still be executing if receiver events are being delivered via an event queue. If the application needs to know when all possible processing on the receiver is complete, it must use <a class="el" href="lbm_8h.html#755bd1ee0a12622098b618cef46d254f" title="Extended delete a UM Hot Failover (HF) receiver object. See https://communities.informatica...">lbm_hf_rcv_delete_ex()</a>.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from a context thread callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hfrcv</em>&nbsp;</td><td>Pointer to a UM HF receiver object to delete. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="755bd1ee0a12622098b618cef46d254f"></a><!-- doxytag: member="lbm.h::lbm_hf_rcv_delete_ex" ref="755bd1ee0a12622098b618cef46d254f" args="(lbm_hf_rcv_t *hfrcv, lbm_event_queue_cancel_cb_info_t *cbinfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hf_rcv_delete_ex           </td>
          <td>(</td>
          <td class="paramtype">lbm_hf_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>hfrcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__event__queue__cancel__cb__info__t__stct.html">lbm_event_queue_cancel_cb_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cbinfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete a UM Hot Failover (HF) receiver object, with an application callback indicating when the receiver is fully canceled. This extended version of the receiver delete function requires the configuration option queue_cancellation_callbacks_enabled be set to 1.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from a context thread callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hfrcv</em>&nbsp;</td><td>Pointer to a UM HF receiver object to delete. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbinfo</em>&nbsp;</td><td>Cancellation callback information, containing the event queue, function pointer, and client data for the callback. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="87b75906aec93c267cf526e40ef5be71"></a><!-- doxytag: member="lbm.h::lbm_hf_rcv_from_rcv" ref="87b75906aec93c267cf526e40ef5be71" args="(lbm_rcv_t *rcv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL lbm_hf_rcv_t* lbm_hf_rcv_from_rcv           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>rcv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>Pointer to a UM receiver object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to a UM HF receiver for the receiver object or NULL if none exists. </dd></dl>

</div>
</div><p>
<a class="anchor" name="456ac9ab0b0d12107be75d3839522ecf"></a><!-- doxytag: member="lbm.h::lbm_hf_rcv_topic_dump" ref="456ac9ab0b0d12107be75d3839522ecf" args="(lbm_hf_rcv_t *hfrcv, int *size, lbm_config_option_t *opts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hf_rcv_topic_dump           </td>
          <td>(</td>
          <td class="paramtype">lbm_hf_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>hfrcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_config_option_t *&nbsp;</td>
          <td class="paramname"> <em>opts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The config object is filled with receiver configuration options <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hfrcv</em>&nbsp;</td><td>The HF receiver object to retrieve the attributes from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the opts array. Will return the number of items that were set in opts </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opts</em>&nbsp;</td><td>The options array to fill </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b5f6226d21dd4294bbad7d9f3e7c0bf6"></a><!-- doxytag: member="lbm.h::lbm_hf_src_create" ref="b5f6226d21dd4294bbad7d9f3e7c0bf6" args="(lbm_src_t **srcp, lbm_context_t *ctx, lbm_topic_t *topic, lbm_src_cb_proc proc, void *clientd, lbm_event_queue_t *evq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hf_src_create           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t **&nbsp;</td>
          <td class="paramname"> <em>srcp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_topic_t *&nbsp;</td>
          <td class="paramname"> <em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lbm_8h.html#7503c005ce424fa049494e37b708d396">lbm_src_cb_proc</a>&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>clientd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#b8dd76271bf9df7a5f88476d431f523e" title="Create a UM source that will send messages to the given topic.">lbm_src_create</a> </dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from a context thread callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>srcp</em>&nbsp;</td><td>A pointer to a pointer to a UM source object. Will be filled in by this function to point to the newly created lbm_src_t object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the LBM context object associated with the sender. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>topic</em>&nbsp;</td><td>Pointer to the LBM topic object associated with the destination of messages sent by the source. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>Pointer to a function to call when events occur related to the source. If NULL, then events are not delivered to the source. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Pointer to client data that is passed when <em>proc</em> is called. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>Optional Event Queue to place events on when they occur. If NULL causes <em>proc</em> to be called from context thread. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="eff48e558306b4bd869af2d99dcf5f4c"></a><!-- doxytag: member="lbm.h::lbm_hf_src_send" ref="eff48e558306b4bd869af2d99dcf5f4c" args="(lbm_src_t *src, const char *msg, size_t len, lbm_uint_t sqn, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hf_src_send           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_uint_t&nbsp;</td>
          <td class="paramname"> <em>sqn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The LBM source must have been created with lbm_hf_src_create and not lbm_src_create <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#91f4b9cb04fe1323ec56833211cc5cb7" title="Send a message to the topic associated with a UM source.">lbm_src_send</a></dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not recommended to call this function from a context thread callback. If called from a context thread callback, use the LBM_SRC_NONBLOCK flag and handle any LBM_EWOULDBLOCK errors internally. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to the LBM source to send from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Pointer to the data to send in this message </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Length (in bytes) of the data to send in this message </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sqn</em>&nbsp;</td><td>The application sequence number to associate with this message. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags indicating various conditions. ORed set of values. <ul>
<li><code>LBM_MSG_START_BATCH</code> - Message starts a batch of messages </li>
<li><code>LBM_MSG_END_BATCH</code> - Message ends a batch of messages. Batch should be sent to the implicit batching buffer. </li>
<li><code>LBM_MSG_COMPLETE_BATCH</code> - Message constitutes a complete batch and should be sent to the implicit batching buffer. </li>
<li><code>LBM_MSG_FLUSH</code> - Message is to be sent ASAP (not implicitly or explicitly batched). This also flushes waiting messages that were explicitly or implicitly batched. </li>
<li><code>LBM_SRC_NONBLOCK</code> - If message could not be sent immediately return and error and signal LBM_EWOULDBLOCK. </li>
<li><code>LBM_SRC_BLOCK</code> - Block the caller indefinitely until the message is sent. (This behavior is the default if neither LBM_SRC_NONBLOCK nor LBM_SRC_BLOCK are supplied.) </li>
</ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure or 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c515c1425d9b3f04f1e2cea5d66d3005"></a><!-- doxytag: member="lbm.h::lbm_hf_src_send_ex" ref="c515c1425d9b3f04f1e2cea5d66d3005" args="(lbm_src_t *src, const char *msg, size_t len, lbm_uint_t sqn, int flags, lbm_src_send_ex_info_t *exinfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hf_src_send_ex           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_uint_t&nbsp;</td>
          <td class="paramname"> <em>sqn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__src__send__ex__info__t__stct.html">lbm_src_send_ex_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>exinfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The LBM source must have been created with lbm_hf_src_create and not lbm_src_create <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#091b5806bf18d10ebd0d9117e0c70229" title="Extended send of a message to the topic associated with a UM source.">lbm_src_send_ex</a></dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>If called from a context thread callback, use the LBM_SRC_NONBLOCK flag and handle any LBM_EWOULDBLOCK errors internally. <p>
Calling this function from a context thread callback for stability and confirmation events could cause a deadlock </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to the LBM source to send from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Pointer to the data to send in this message </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Length (in bytes) of the data to send in this message </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sqn</em>&nbsp;</td><td>The application sequence number to associate with this message. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags indicating various conditions. ORed set of values. <ul>
<li><code>LBM_MSG_START_BATCH</code> - Message starts a batch of messages </li>
<li><code>LBM_MSG_END_BATCH</code> - Message ends a batch of messages. Batch should be sent to the implicit batching buffer. </li>
<li><code>LBM_MSG_COMPLETE_BATCH</code> - Message constitutes a complete batch and should be sent to the implicit batching buffer. </li>
<li><code>LBM_MSG_FLUSH</code> - Message is to be sent ASAP (not implicitly or explicitly batched). This also flushes waiting messages that were explicitly or implicitly batched. </li>
<li><code>LBM_SRC_NONBLOCK</code> - If message could not be sent immediately return and error and signal LBM_EWOULDBLOCK. </li>
<li><code>LBM_SRC_BLOCK</code> - Block the caller indefinitely until the message is sent. (This behavior is the default if neither LBM_SRC_NONBLOCK nor LBM_SRC_BLOCK are supplied.) </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>exinfo</em>&nbsp;</td><td>Pointer to lbm_src_send_ex_info_t options that includes the 32 or 64 bit hot-failover sequence number to send. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure or 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9f7ed3785938fcfd4771965d6430c4f2"></a><!-- doxytag: member="lbm.h::lbm_hf_src_send_rcv_reset" ref="9f7ed3785938fcfd4771965d6430c4f2" args="(lbm_src_t *src, int flags, lbm_src_send_ex_info_t *exinfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hf_src_send_rcv_reset           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__src__send__ex__info__t__stct.html">lbm_src_send_ex_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>exinfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send a message that instructs hot-failover receivers to reset their state. In, and only in, the case that hf receivers cannot be manually restarted, this function can be used to allow delivering of previously sent sequence numbers. The hot-failover receiver will deliver a message of type LBM_MSG_HF_RESET and will include the new expected sequence number. The sequence number contained with the reset will be used as the next expected sequence number to be sent. The LBM source must have been created with lbm_hf_src_create and not lbm_src_create.<p>
NOTE: The best way to reset a hot-failover receiver's state is to restart the receiver itself. This function should be used only when that is impossible.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to the LBM source to send from, must be a hot failover source </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>exinfo</em>&nbsp;</td><td>Pointer to the lbm_src_send_ex_info_t containing the hf sequence number </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure or 0 for Success </dd></dl>

</div>
</div><p>
<a class="anchor" name="713c05423f7bf1767a29727c07aa4447"></a><!-- doxytag: member="lbm.h::lbm_hf_src_sendv" ref="713c05423f7bf1767a29727c07aa4447" args="(lbm_src_t *src, const lbm_iovec_t *iov, int num, lbm_uint_t sqn, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hf_src_sendv           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlbm__iovec__t__stct.html">lbm_iovec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_uint_t&nbsp;</td>
          <td class="paramname"> <em>sqn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The LBM source must have been created with lbm_hf_src_create and not lbm_src_create. The message is specified as an array of iovecs.<p>
NOTE: Unlike lbm_src_sendv, which by default sends N number of messages where N is the length of the iovec; lbm_hf_src_sendv will gather the elements of the array into one message. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#713c05423f7bf1767a29727c07aa4447" title="Send a set of Hot Failover (HF) messages to the topic associated with a UM source...">lbm_hf_src_sendv</a></dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not recommended to call this function from a context thread callback. If called from a context thread callback, use the LBM_SRC_NONBLOCK flag and handle any LBM_EWOULDBLOCK errors internally. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to the LBM source to send from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iov</em>&nbsp;</td><td>Pointer to an array of iovecs that hold message information. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>Number of elements of the iov array to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sqn</em>&nbsp;</td><td>The application sequence number to associate with this message. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags indicating various conditions. ORed set of values. <ul>
<li><code>LBM_MSG_START_BATCH</code> - Messages start a batch of messages </li>
<li><code>LBM_MSG_END_BATCH</code> - Messages end a batch of messages. Batch should be sent to the implicit batching buffer. </li>
<li><code>LBM_MSG_COMPLETE_BATCH</code> - Messages constitute a complete batch and should be sent to the implicit batching buffer. </li>
<li><code>LBM_MSG_FLUSH</code> - Messages are to be sent ASAP (not implicitly batched or explicitly batched). </li>
<li><code>LBM_SRC_NONBLOCK</code> - If messages could not be sent immediately return and error and signal LBM_EWOULDBLOCK. </li>
<li><code>LBM_SRC_BLOCK</code> - Block the caller indefinitely until the messages are all sent. (This behavior is the default if neither LBM_SRC_NONBLOCK nor LBM_SRC_BLOCK are supplied.) </li>
</ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure or 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cb6f42a8811cb998b4b19748b190f39b"></a><!-- doxytag: member="lbm.h::lbm_hf_src_sendv_ex" ref="cb6f42a8811cb998b4b19748b190f39b" args="(lbm_src_t *src, const lbm_iovec_t *iov, int num, lbm_uint_t sqn, int flags, lbm_src_send_ex_info_t *exinfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hf_src_sendv_ex           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlbm__iovec__t__stct.html">lbm_iovec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_uint_t&nbsp;</td>
          <td class="paramname"> <em>sqn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__src__send__ex__info__t__stct.html">lbm_src_send_ex_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>exinfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The LBM source must have been created with lbm_hf_src_create and not lbm_src_create. The message is specified as an array of iovecs.<p>
NOTE: Unlike lbm_src_sendv, which by default sends N number of LBM Messages where N is the length of the iovec array; lbm_hf_src_sendv will gather the elements of the array into a single message. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#cb6f42a8811cb998b4b19748b190f39b" title="Extended send of a set of Hot Failover (HF) messages to the topic associated with...">lbm_hf_src_sendv_ex</a></dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>If called from a context thread callback, use the LBM_SRC_NONBLOCK flag and handle any LBM_EWOULDBLOCK errors internally. <p>
Calling this function from a context thread callback for stability and confirmation events could cause a deadlock </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to the LBM source to send from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iov</em>&nbsp;</td><td>Pointer to an array of iovecs that hold message information. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>Number of elements of the iov array to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sqn</em>&nbsp;</td><td>The application sequence number to associate with this message. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags indicating various conditions. ORed set of values. <ul>
<li><code>LBM_MSG_START_BATCH</code> - Message starts a batch of messages </li>
<li><code>LBM_MSG_END_BATCH</code> - Message ends a batch of messages. Batch should be sent to the implicit batching buffer. </li>
<li><code>LBM_MSG_COMPLETE_BATCH</code> - Message constitutes a complete batch and should be sent to the implicit batching buffer. </li>
<li><code>LBM_MSG_FLUSH</code> - Message is to be sent ASAP (not implicitly or explicitly batched). This also flushes waiting messages that were explicitly or implicitly batched. </li>
<li><code>LBM_SRC_NONBLOCK</code> - If message could not be sent immediately return and error and signal LBM_EWOULDBLOCK. </li>
<li><code>LBM_SRC_BLOCK</code> - Block the caller indefinitely until the message is sent. (This behavior is the default if neither LBM_SRC_NONBLOCK nor LBM_SRC_BLOCK are supplied.) </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>exinfo</em>&nbsp;</td><td>Pointer to lbm_src_send_ex_info_t options which includes the 32 or 64 bit hot-failover sequence number to send. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure or 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0e904e14d61eee45af197c17f7e3dc08"></a><!-- doxytag: member="lbm.h::lbm_hfx_attr_create" ref="0e904e14d61eee45af197c17f7e3dc08" args="(lbm_hfx_attr_t **attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hfx_attr_create           </td>
          <td>(</td>
          <td class="paramtype">lbm_hfx_attr_t **&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is allocated and filled with the current default values that are used by lbm_hfx_t objects and may have been modified by a previously loaded configuration file.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a pointer to a UM hfx attributes structure. Will be filled in by this function to point to the newly created lbm_hfx_attr_t object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="f2d3f43eacfbae9045b1ddad32aadc35"></a><!-- doxytag: member="lbm.h::lbm_hfx_attr_create_default" ref="f2d3f43eacfbae9045b1ddad32aadc35" args="(lbm_hfx_attr_t **attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hfx_attr_create_default           </td>
          <td>(</td>
          <td class="paramtype">lbm_hfx_attr_t **&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is allocated and filled with the initial or factory default values built into LBM that are used by lbm_hfx_t objects.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a pointer to a UM hfx attribute structure. Will be filled in by this function to point to the newly created lbm_hfx_attr_t object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="abc739544b1a28481e9b4bc51bb49705"></a><!-- doxytag: member="lbm.h::lbm_hfx_attr_create_from_xml" ref="abc739544b1a28481e9b4bc51bb49705" args="(lbm_hfx_attr_t **attr, const char *topicname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hfx_attr_create_from_xml           </td>
          <td>(</td>
          <td class="paramtype">lbm_hfx_attr_t **&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>topicname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is allocated and filled with the current default values that are used by lbm_hfx_t objects and may have been modified by a previously loaded configuration file. Then, if an XML configuration file has been loaded, the attribute object is further filled with the defaults for the given topic name. If the topic name is not permitted by the XML configuration, -1 is returned and no attribute object is created.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a pointer to a UM hfx attribute structure. Will be filled in by this function to point to the newly created lbm_hfx_attr_t object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>topicname</em>&nbsp;</td><td>The topic name used to lookup this topic in the XML configuration. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ca9ea90e0eba56105bac459d9a1f1887"></a><!-- doxytag: member="lbm.h::lbm_hfx_attr_delete" ref="ca9ea90e0eba56105bac459d9a1f1887" args="(lbm_hfx_attr_t *attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hfx_attr_delete           </td>
          <td>(</td>
          <td class="paramtype">lbm_hfx_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is cleaned up and deleted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM hfx attribute object as returned by <a class="el" href="lbm_8h.html#0e904e14d61eee45af197c17f7e3dc08" title="Create and fill a UM HFX attribute object with the current default values.">lbm_hfx_attr_create</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a2d03b7f229f00e15fd0de8bcde812e4"></a><!-- doxytag: member="lbm.h::lbm_hfx_attr_dump" ref="a2d03b7f229f00e15fd0de8bcde812e4" args="(lbm_hfx_attr_t *attr, int *size, lbm_config_option_t *opts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hfx_attr_dump           </td>
          <td>(</td>
          <td class="paramtype">lbm_hfx_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_config_option_t *&nbsp;</td>
          <td class="paramname"> <em>opts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The config object is filled with HFX configuration options <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cattr</em>&nbsp;</td><td>The HFX attribute object to retrieve the attributes from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the opts array. Will return the number of items that were set in opts </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opts</em>&nbsp;</td><td>The options array to fill </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c4cf1936d4930ef818760983795e74ed"></a><!-- doxytag: member="lbm.h::lbm_hfx_attr_dup" ref="c4cf1936d4930ef818760983795e74ed" args="(lbm_hfx_attr_t **attr, const lbm_hfx_attr_t *original)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hfx_attr_dup           </td>
          <td>(</td>
          <td class="paramtype">lbm_hfx_attr_t **&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lbm_hfx_attr_t *&nbsp;</td>
          <td class="paramname"> <em>original</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A new attribute object is created as a copy of an existing object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a pointer to a UM hfx attribute structure. Will be filled in by this function to point to the newly created lbm_hfx_attr_t object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>original</em>&nbsp;</td><td>Pointer to a UM hfx attribute object as returned by <a class="el" href="lbm_8h.html#0e904e14d61eee45af197c17f7e3dc08" title="Create and fill a UM HFX attribute object with the current default values.">lbm_hfx_attr_create</a> or <a class="el" href="lbm_8h.html#f2d3f43eacfbae9045b1ddad32aadc35" title="Create and fill a UM HFX attribute object with the initial default values.">lbm_hfx_attr_create_default</a>, from which <em>attr</em> is initialized. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ba74867edbabed89d7890ed84d3c7d38"></a><!-- doxytag: member="lbm.h::lbm_hfx_attr_getopt" ref="ba74867edbabed89d7890ed84d3c7d38" args="(lbm_hfx_attr_t *attr, const char *optname, void *optval, size_t *optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hfx_attr_getopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_hfx_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM hfx attributed object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the option value structure to be filled. The structure of the option values are specific to the options themselves. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>Length (in bytes) of the <em>optval</em> structure when passed in. Upon return, this is set to the size of the optval filled in structure. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9c34470a88469310e77cd90314f9f42c"></a><!-- doxytag: member="lbm.h::lbm_hfx_attr_option_size" ref="9c34470a88469310e77cd90314f9f42c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hfx_attr_option_size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of entries that are of type "hfx" </dd></dl>

</div>
</div><p>
<a class="anchor" name="2b9f7629e9b17a14d3189b4c42bb7e4f"></a><!-- doxytag: member="lbm.h::lbm_hfx_attr_set_from_xml" ref="2b9f7629e9b17a14d3189b4c42bb7e4f" args="(lbm_hfx_attr_t *attr, const char *topicname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hfx_attr_set_from_xml           </td>
          <td>(</td>
          <td class="paramtype">lbm_hfx_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>topicname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is filled with the default values for the given topic name, if an XML configuration file has been loaded. If the topic name is not permitted by the XML configuration, -1 is returned and no values are set.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a UM hfx attribute structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>topicname</em>&nbsp;</td><td>The topic name used to lookup this topic in the XML configuration. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9bb4203d659a9d87ee736fb800b40294"></a><!-- doxytag: member="lbm.h::lbm_hfx_attr_setopt" ref="9bb4203d659a9d87ee736fb800b40294" args="(lbm_hfx_attr_t *attr, const char *optname, const void *optval, size_t optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hfx_attr_setopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_hfx_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used before the hfx is created. NOTE: the attribute object must first be initialized with the corresponding _attr_create() function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM hfx attribute object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the option value structure. The structure of the option values are specific to the options themselves. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>Length (in bytes) of the <em>optval</em> structure. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ddb7392c84f3fab0bc45d716b9721e5a"></a><!-- doxytag: member="lbm.h::lbm_hfx_attr_str_getopt" ref="ddb7392c84f3fab0bc45d716b9721e5a" args="(lbm_hfx_attr_t *attr, const char *optname, char *optval, size_t *optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hfx_attr_str_getopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_hfx_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM hfx attributed object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the string to be filled in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>Maximum length (in bytes) of the <em>string</em> when passed in. Upon return, this is set to the size of the formatted string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="efb36e1505005ef7c9b32904bf85a817"></a><!-- doxytag: member="lbm.h::lbm_hfx_attr_str_setopt" ref="efb36e1505005ef7c9b32904bf85a817" args="(lbm_hfx_attr_t *attr, const char *optname, const char *optval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hfx_attr_str_setopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_hfx_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used before the hfx is created. NOTE: the attribute object must first be initialized with the corresponding _attr_create() function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM hfx attributed object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>String containing the option value. The format of the string is specific to the option itself. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="82e9efbf70242d83ab287916ac497645"></a><!-- doxytag: member="lbm.h::lbm_hfx_create" ref="82e9efbf70242d83ab287916ac497645" args="(lbm_hfx_t **hfxp, lbm_hfx_attr_t *cattr, const char *symbol, lbm_rcv_cb_proc proc, lbm_event_queue_t *evq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hfx_create           </td>
          <td>(</td>
          <td class="paramtype">lbm_hfx_t **&nbsp;</td>
          <td class="paramname"> <em>hfxp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_hfx_attr_t *&nbsp;</td>
          <td class="paramname"> <em>cattr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lbm_8h.html#e2d650dd4830971ca0b6197298eddcdd">lbm_rcv_cb_proc</a>&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#bc9924a0bd826db0c45a42d7199030b1" title="Delete a UM hfx object.">lbm_hfx_delete()</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hfxp</em>&nbsp;</td><td>A pointer to a pointer to a UM hfx object. Will be filled in by this function to point to the newly created lbm_hfx_t object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cattr</em>&nbsp;</td><td>A pointer to a UM hfx attribute object. A value of NULL will use default attributes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>symbol</em>&nbsp;</td><td>The symbol string to be used for all hot failover receivers managed by this HFX. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>Pointer to a function to call when messages arrive. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>Optional Event Queue to place message events on when they arrive. If NULL, causes <em>proc</em> to be called from context thread. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bc9924a0bd826db0c45a42d7199030b1"></a><!-- doxytag: member="lbm.h::lbm_hfx_delete" ref="bc9924a0bd826db0c45a42d7199030b1" args="(lbm_hfx_t *hfx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hfx_delete           </td>
          <td>(</td>
          <td class="paramtype">lbm_hfx_t *&nbsp;</td>
          <td class="paramname"> <em>hfx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from a context thread callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hfx</em>&nbsp;</td><td>Pointer to a UM hfx object to delete. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3b091cdffac78f4d1fff38e79c0cd410"></a><!-- doxytag: member="lbm.h::lbm_hfx_delete_ex" ref="3b091cdffac78f4d1fff38e79c0cd410" args="(lbm_hfx_t *hfx, lbm_event_queue_cancel_cb_info_t *cbinfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hfx_delete_ex           </td>
          <td>(</td>
          <td class="paramtype">lbm_hfx_t *&nbsp;</td>
          <td class="paramname"> <em>hfx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__event__queue__cancel__cb__info__t__stct.html">lbm_event_queue_cancel_cb_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cbinfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#755bd1ee0a12622098b618cef46d254f" title="Extended delete a UM Hot Failover (HF) receiver object. See https://communities.informatica...">lbm_hf_rcv_delete_ex</a> or <p>
<a class="el" href="lbm_8h.html#eb6fc66ee4fdd7f4c9d439af54d45f68" title="Extended delete a UM receiver object.">lbm_rcv_delete_ex</a>, this extended callback can be used whether or not an event queue is associated with the HFX. </dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from a context thread callback. <p>
When deleting an hfx object, wait for the delete_ex callback before deleting any of the associated contexts. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hfx</em>&nbsp;</td><td>Pointer to an LBM hfx object to delete. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbinfo</em>&nbsp;</td><td>Cancellation callback information containing the (optional) event queue, function pointer, and client data for the callback. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7d949468af1c01bb9198154b4891ed19"></a><!-- doxytag: member="lbm.h::lbm_hfx_dump" ref="7d949468af1c01bb9198154b4891ed19" args="(lbm_hfx_t *hfx, int *size, lbm_config_option_t *opts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hfx_dump           </td>
          <td>(</td>
          <td class="paramtype">lbm_hfx_t *&nbsp;</td>
          <td class="paramname"> <em>hfx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_config_option_t *&nbsp;</td>
          <td class="paramname"> <em>opts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The config object is filled with HFX configuration options <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hfx</em>&nbsp;</td><td>The HFX object to retrieve the attributes from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the opts array. Will return the number of items that were set in opts </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opts</em>&nbsp;</td><td>The options array to fill </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="85ba681460754ea1643b1d08ef1a2c22"></a><!-- doxytag: member="lbm.h::lbm_hfx_getopt" ref="85ba681460754ea1643b1d08ef1a2c22" args="(lbm_hfx_t *hfx, const char *optname, void *optval, size_t *optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hfx_getopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_hfx_t *&nbsp;</td>
          <td class="paramname"> <em>hfx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hfx</em>&nbsp;</td><td>Pointer to a UM hfx object where the option is stored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the option value structure. The structure of the option values are specific to the options themselves. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>When passed, this is the max length (in bytes) of the <em>optval</em> structure. When returned, this is the length of the filled in <em>optval</em> structure. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e717b7b9923a6e4277ae9f7409983ffc"></a><!-- doxytag: member="lbm.h::lbm_hfx_rcv_create" ref="e717b7b9923a6e4277ae9f7409983ffc" args="(lbm_hfx_rcv_t **hfrcvp, lbm_hfx_t *hfx, lbm_context_t *ctx, lbm_rcv_topic_attr_t *rattr, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hfx_rcv_create           </td>
          <td>(</td>
          <td class="paramtype">lbm_hfx_rcv_t **&nbsp;</td>
          <td class="paramname"> <em>hfrcvp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_hfx_t *&nbsp;</td>
          <td class="paramname"> <em>hfx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_rcv_topic_attr_t *&nbsp;</td>
          <td class="paramname"> <em>rattr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>clientd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from a context thread callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hfrcvp</em>&nbsp;</td><td>A pointer to a pointer to a UM hfx_rcv_t object. Will be filled in by this function to point to the newly created lbm_hfx_rcv_t object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hfx</em>&nbsp;</td><td>An lbm_hfx_t object created by </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#82e9efbf70242d83ab287916ac497645" title="Create and initialize an lbm_hfx_t object.">lbm_hfx_create</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>The lbm_context_t object on which to create the new receiver. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rattr</em>&nbsp;</td><td>The receiver attributes to be used when creating new hot failover receivers. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Pointer to client data to be delivered when a message is received and the lbm_hfx_t object's proc is called. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="096626db73533d6c39b22765014485b7"></a><!-- doxytag: member="lbm.h::lbm_hfx_rcv_delete" ref="096626db73533d6c39b22765014485b7" args="(lbm_hfx_rcv_t *hfrcv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hfx_rcv_delete           </td>
          <td>(</td>
          <td class="paramtype">lbm_hfx_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>hfrcv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from a context thread callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hfrcv</em>&nbsp;</td><td>Pointer to a UM HFX receiver object to delete. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="08d8cbd7f47af1d7b2199c85ecf7c44c"></a><!-- doxytag: member="lbm.h::lbm_hfx_rcv_delete_ex" ref="08d8cbd7f47af1d7b2199c85ecf7c44c" args="(lbm_hfx_rcv_t *hfrcv, lbm_event_queue_cancel_cb_info_t *cbinfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hfx_rcv_delete_ex           </td>
          <td>(</td>
          <td class="paramtype">lbm_hfx_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>hfrcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__event__queue__cancel__cb__info__t__stct.html">lbm_event_queue_cancel_cb_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cbinfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete a UM Hot Failover receiver object, with an application callback indicating when the receiver is fully cancelled. This extended version of the receiver delete function requires the configuration option queue_cancellation_callbacks_enabled to be set to 1 if an event queue is in use.<p>
Unlike <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#755bd1ee0a12622098b618cef46d254f" title="Extended delete a UM Hot Failover (HF) receiver object. See https://communities.informatica...">lbm_hf_rcv_delete_ex</a> or <p>
<a class="el" href="lbm_8h.html#eb6fc66ee4fdd7f4c9d439af54d45f68" title="Extended delete a UM receiver object.">lbm_rcv_delete_ex</a>, this extended callback can be used whether or not an event queue is associated with the HFX. This allows an application to delete a receiver from a single context and be notified when any messages currently held in the order map are no longer required.</dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from a context thread callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hfrcv</em>&nbsp;</td><td>Pointer to a UM HFX receiver to delete. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbinfo</em>&nbsp;</td><td>Cancellation callback information containing the (optional) event queue, function pointer, and client data for the callback. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ac61570f29d9cd95c42e9bd5e41e0efa"></a><!-- doxytag: member="lbm.h::lbm_hfx_rcv_topic_dump" ref="ac61570f29d9cd95c42e9bd5e41e0efa" args="(lbm_hfx_rcv_t *hfxrcv, int *size, lbm_config_option_t *opts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hfx_rcv_topic_dump           </td>
          <td>(</td>
          <td class="paramtype">lbm_hfx_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>hfxrcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_config_option_t *&nbsp;</td>
          <td class="paramname"> <em>opts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The config object is filled with receiver configuration options <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hfxrcv</em>&nbsp;</td><td>The HFX receiver object to retrieve the attributes from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the opts array. Will return the number of items that were set in opts </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opts</em>&nbsp;</td><td>The options array to fill </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b3b823b82e06584896f1cd89ae141e73"></a><!-- doxytag: member="lbm.h::lbm_hfx_setopt" ref="b3b823b82e06584896f1cd89ae141e73" args="(lbm_hfx_t *hfx, const char *optname, const void *optval, size_t optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hfx_setopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_hfx_t *&nbsp;</td>
          <td class="paramname"> <em>hfx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Only those options that can be set during operation may be specified. See "Options That May Be Set During Operation" (doc/Config/maybesetduringoperation.html) in The UM Configuration Guide. For API functions that can access any option, see lbm_hfx_attr_*(). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hfx</em>&nbsp;</td><td>Pointer to a UM hfx object where the option is to be set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the option value structure. The structure of the option values are specific to the options themselves. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>Length (in bytes) of the <em>optval</em> structure. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="12d43eae4a50cb9e899162c50ff0c25b"></a><!-- doxytag: member="lbm.h::lbm_hfx_str_getopt" ref="12d43eae4a50cb9e899162c50ff0c25b" args="(lbm_hfx_t *hfx, const char *optname, char *optval, size_t *optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hfx_str_getopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_hfx_t *&nbsp;</td>
          <td class="paramname"> <em>hfx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hfx</em>&nbsp;</td><td>Pointer to a UM hfx object where the option is stored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>String to hold the option value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>When passed, this is the max length (in bytes) of the string. When returned, this is the length of the filled in option value. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6402e914f77ff8caac64d6ff7bf62831"></a><!-- doxytag: member="lbm.h::lbm_hfx_str_setopt" ref="6402e914f77ff8caac64d6ff7bf62831" args="(lbm_hfx_t *hfx, const char *optname, const char *optval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_hfx_str_setopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_hfx_t *&nbsp;</td>
          <td class="paramname"> <em>hfx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Only those options that can be set during operation may be specified. See "Options That May Be Set During Operation" (doc/Config/maybesetduringoperation.html) in The UM Configuration Guide. For API functions that can access any option, see lbm_hfx_attr_*(). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hfx</em>&nbsp;</td><td>Pointer to a UM hfx object where the option is to be set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>String containing the option value. The format of the string is specific to the options themselves. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0068d9e57d3a0897217405e9a9068e20"></a><!-- doxytag: member="lbm.h::lbm_is_ume_capable" ref="0068d9e57d3a0897217405e9a9068e20" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_is_ume_capable           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 if the library is capable of UME operations, 0 if the library is not capable of UME operations. </dd></dl>

</div>
</div><p>
<a class="anchor" name="957e542a9bc1172ab5ce29da151b6d05"></a><!-- doxytag: member="lbm.h::lbm_is_umq_capable" ref="957e542a9bc1172ab5ce29da151b6d05" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_is_umq_capable           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 if the library is capable of UMQ operations, 0 if the library is not capable of UMQ operations. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c81ce10cac5b109e1f96ecff8cbf5772"></a><!-- doxytag: member="lbm.h::lbm_license_file" ref="c81ce10cac5b109e1f96ecff8cbf5772" args="(const char *licfile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_license_file           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>licfile</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>licfile</em>&nbsp;</td><td>String containing the name of a file that contains the UM license. This string is the same as that which would otherwise be specified as the value of the LBM_LICENSE_FILENAME environmental variable. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="69282fd2de2f3d773e94c610aa67ebbe"></a><!-- doxytag: member="lbm.h::lbm_license_str" ref="69282fd2de2f3d773e94c610aa67ebbe" args="(const char *licstr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_license_str           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>licstr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>licstr</em>&nbsp;</td><td>String containing the UM license. This string is the same as that which would otherwise be specified as the value of the LBM_LICENSE_INFO environmental variable. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="ae14099b91f2919f424e81f20ca10951"></a><!-- doxytag: member="lbm.h::lbm_log" ref="ae14099b91f2919f424e81f20ca10951" args="(lbm_log_cb_proc proc, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_log           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lbm_8h.html#72ac99d9f07d98bfe2c7c5856d37c2d0">lbm_log_cb_proc</a>&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>clientd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>Function to call when a log message is generated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data to pass when a log message is generated. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on Success and -1 for Failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="aa36f4dcd32603a33c0a2c129dd2c3aa"></a><!-- doxytag: member="lbm.h::lbm_logf" ref="aa36f4dcd32603a33c0a2c129dd2c3aa" args="(int level, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL void lbm_logf           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>Message log level (see LBM_LOG_*). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>format</em>&nbsp;</td><td><code>printf</code> style format string, followed by zero or more arguments. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a5fc1eb324a55b8c800c31460b0f0116"></a><!-- doxytag: member="lbm.h::lbm_msg_delete" ref="a5fc1eb324a55b8c800c31460b0f0116" args="(lbm_msg_t *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_msg_delete           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This should only be called if the message was previously saved via <a class="el" href="lbm_8h.html#2b7788ff58f9e78bc89ea890dad0cccf" title="Instruct UM that the API is going to retain ownership of a UM message object.">lbm_msg_retain()</a>. Any associated lbm_response_t objects for this message are cleaned up automatically in this function.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>A receive callback should never delete the message that was passed in. It should either let UM delete it when the callback returns, or it should retain it and delete it later.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Pointer to a UM message object to delete. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e1b7ca376c99fcbbe6175ad3441b7aeb"></a><!-- doxytag: member="lbm.h::lbm_msg_extract_ume_ack" ref="e1b7ca376c99fcbbe6175ad3441b7aeb" args="(lbm_msg_t *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL lbm_ume_rcv_ack_t* lbm_msg_extract_ume_ack           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#5c2b4c56240b15dadd9a251989c3180f" title="Deletes an ack structure.">lbm_ume_ack_delete</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Pointer to the message object from which to extract the ack structure. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the ack structure for Success, NULL for failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7b47a27da53a3855980769c2e8494141"></a><!-- doxytag: member="lbm.h::lbm_msg_is_fragment" ref="7b47a27da53a3855980769c2e8494141" args="(lbm_msg_t *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_msg_is_fragment           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Pointer to a UM message object to retrieve fragment information from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>Pointer to fragment information structure to fill in. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="aea0bf981a9fe47287db442026ca13ca"></a><!-- doxytag: member="lbm.h::lbm_msg_properties_clear" ref="aea0bf981a9fe47287db442026ca13ca" args="(lbm_msg_properties_t *properties, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_msg_properties_clear           </td>
          <td>(</td>
          <td class="paramtype">lbm_msg_properties_t *&nbsp;</td>
          <td class="paramname"> <em>properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#bda1a4224f1c3e94b10b74051be3dd53" title="Creates a new properties object, used for sending messages with properties.">lbm_msg_properties_create</a> <p>
<a class="el" href="lbm_8h.html#cec18484fc06996fe3b61e76a593d5fb" title="Sets the value of the property with the specified name. Each property name may be...">lbm_msg_properties_set</a> <p>
<a class="el" href="lbm_8h.html#ac0dc50537a458d2a2ca418a394fd21b" title="Gets the value of the property with the specified name.">lbm_msg_properties_get</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>properties</em>&nbsp;</td><td>Properties object from which the named property should be cleared. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>Property to be cleared. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>LBM_OK for success, LBM_FAILURE if the property was not present. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bda1a4224f1c3e94b10b74051be3dd53"></a><!-- doxytag: member="lbm.h::lbm_msg_properties_create" ref="bda1a4224f1c3e94b10b74051be3dd53" args="(lbm_msg_properties_t **properties)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_msg_properties_create           </td>
          <td>(</td>
          <td class="paramtype">lbm_msg_properties_t **&nbsp;</td>
          <td class="paramname"> <em>properties</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#091b5806bf18d10ebd0d9117e0c70229" title="Extended send of a message to the topic associated with a UM source.">lbm_src_send_ex</a> <p>
<a class="el" href="lbm_8h.html#80152f12d64394821a61287e99c5db33" title="Deletes a properties object.">lbm_msg_properties_delete</a> <p>
<a class="el" href="lbm_8h.html#cec18484fc06996fe3b61e76a593d5fb" title="Sets the value of the property with the specified name. Each property name may be...">lbm_msg_properties_set</a> <p>
<a class="el" href="lbm_8h.html#ac0dc50537a458d2a2ca418a394fd21b" title="Gets the value of the property with the specified name.">lbm_msg_properties_get</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>properties</em>&nbsp;</td><td>A pointer to a pointer to be filled in by this function. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>LBM_OK for success, LBM_FAILURE for failure if the memory cannot be allocated. </dd></dl>

</div>
</div><p>
<a class="anchor" name="80152f12d64394821a61287e99c5db33"></a><!-- doxytag: member="lbm.h::lbm_msg_properties_delete" ref="80152f12d64394821a61287e99c5db33" args="(lbm_msg_properties_t *properties)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_msg_properties_delete           </td>
          <td>(</td>
          <td class="paramtype">lbm_msg_properties_t *&nbsp;</td>
          <td class="paramname"> <em>properties</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#091b5806bf18d10ebd0d9117e0c70229" title="Extended send of a message to the topic associated with a UM source.">lbm_src_send_ex</a> <p>
<a class="el" href="lbm_8h.html#bda1a4224f1c3e94b10b74051be3dd53" title="Creates a new properties object, used for sending messages with properties.">lbm_msg_properties_create</a> <p>
<a class="el" href="lbm_8h.html#cec18484fc06996fe3b61e76a593d5fb" title="Sets the value of the property with the specified name. Each property name may be...">lbm_msg_properties_set</a> <p>
<a class="el" href="lbm_8h.html#ac0dc50537a458d2a2ca418a394fd21b" title="Gets the value of the property with the specified name.">lbm_msg_properties_get</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>properties</em>&nbsp;</td><td>A pointer to a properties object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>LBM_OK for success, LBM_FAILURE for failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ac0dc50537a458d2a2ca418a394fd21b"></a><!-- doxytag: member="lbm.h::lbm_msg_properties_get" ref="ac0dc50537a458d2a2ca418a394fd21b" args="(lbm_msg_properties_t *properties, const char *name, void *value, int *type, size_t *size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_msg_properties_get           </td>
          <td>(</td>
          <td class="paramtype">lbm_msg_properties_t *&nbsp;</td>
          <td class="paramname"> <em>properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#091b5806bf18d10ebd0d9117e0c70229" title="Extended send of a message to the topic associated with a UM source.">lbm_src_send_ex</a> <p>
<a class="el" href="lbm_8h.html#bda1a4224f1c3e94b10b74051be3dd53" title="Creates a new properties object, used for sending messages with properties.">lbm_msg_properties_create</a> <p>
<a class="el" href="lbm_8h.html#ac0dc50537a458d2a2ca418a394fd21b" title="Gets the value of the property with the specified name.">lbm_msg_properties_get</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>properties</em>&nbsp;</td><td>The properties object that the new value should be retrieved from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the property to be retrieved </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>A pointer to the memory to be filled in with the value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>A pointer to the type the value should be retrieved as. If the specified type is not compatible with the property, this field will be filled in with the required type. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>A pointer to a size_t holding the size of the memory block available to be filled in. If a block of insufficient size is specified, this field will be filled in with the required size. For string types, the block of memory must be of sufficient size to hold the string as well as the null terminator. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>LBM_OK for success, LBM_FAILURE for failure, and changes the current value of <a class="el" href="lbm_8h.html#f3a827eb26d87be5b1a6b9fd3a4b63aa" title="Return the error number last encountered by this thread.">lbm_errnum()</a> and lbm_errstr(). </dd></dl>

</div>
</div><p>
<a class="anchor" name="a08b2aa8f00b1b97c6d496834a4432dd"></a><!-- doxytag: member="lbm.h::lbm_msg_properties_iter_create" ref="a08b2aa8f00b1b97c6d496834a4432dd" args="(lbm_msg_properties_iter_t **iterp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_msg_properties_iter_create           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlbm__msg__properties__iter__t__stct.html">lbm_msg_properties_iter_t</a> **&nbsp;</td>
          <td class="paramname"> <em>iterp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#cfa02c8316e97baeb9894daa991ef1fb" title="Begin iterating over an.">lbm_msg_properties_iter_first</a> to begin iterating over a properties object. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iterp</em>&nbsp;</td><td>A pointer to a pointer that will be filled in with the newly-created iterator object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>LBM_OK for success, LBM_FAILURE for failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="79db125bc40762da0b462c70f9e8c4b4"></a><!-- doxytag: member="lbm.h::lbm_msg_properties_iter_delete" ref="79db125bc40762da0b462c70f9e8c4b4" args="(lbm_msg_properties_iter_t *iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_msg_properties_iter_delete           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlbm__msg__properties__iter__t__stct.html">lbm_msg_properties_iter_t</a> *&nbsp;</td>
          <td class="paramname"> <em>iter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#a08b2aa8f00b1b97c6d496834a4432dd" title="Creates a new msg properties iterator. The newly created iterator is not associated...">lbm_msg_properties_iter_create</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>A pointer to an iterator created via </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#a08b2aa8f00b1b97c6d496834a4432dd" title="Creates a new msg properties iterator. The newly created iterator is not associated...">lbm_msg_properties_iter_create</a> </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>LBM_OK for success, LBM_FAILURE for failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cfa02c8316e97baeb9894daa991ef1fb"></a><!-- doxytag: member="lbm.h::lbm_msg_properties_iter_first" ref="cfa02c8316e97baeb9894daa991ef1fb" args="(lbm_msg_properties_iter_t *iter, lbm_msg_properties_t *properties)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_msg_properties_iter_first           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlbm__msg__properties__iter__t__stct.html">lbm_msg_properties_iter_t</a> *&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_msg_properties_t *&nbsp;</td>
          <td class="paramname"> <em>properties</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd>lbm_msg_properties_t object, starting at the first element. Calling <a class="el" href="lbm_8h.html#cfa02c8316e97baeb9894daa991ef1fb" title="Begin iterating over an.">lbm_msg_properties_iter_first</a> associates an iterator with a properties object, and sets its current position to the first property available. An iterator can be used to iterate over more than one properties object as long as <a class="el" href="lbm_8h.html#cfa02c8316e97baeb9894daa991ef1fb" title="Begin iterating over an.">lbm_msg_properties_iter_first</a> is called to associate it with each new properties object. <p>
<a class="el" href="lbm_8h.html#2876985a82c92ade238b8196a1ec3da7" title="Iterate to the next property in an.">lbm_msg_properties_iter_next</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>An iterator object allocated via </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#a08b2aa8f00b1b97c6d496834a4432dd" title="Creates a new msg properties iterator. The newly created iterator is not associated...">lbm_msg_properties_iter_create</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>properties</em>&nbsp;</td><td>A properties object, either retrieved from an lbm_msg_t, or created via </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#bda1a4224f1c3e94b10b74051be3dd53" title="Creates a new properties object, used for sending messages with properties.">lbm_msg_properties_create</a> </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>LBM_OK for success, LBM_FAILURE if there are no elements contained in the properties object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2876985a82c92ade238b8196a1ec3da7"></a><!-- doxytag: member="lbm.h::lbm_msg_properties_iter_next" ref="2876985a82c92ade238b8196a1ec3da7" args="(lbm_msg_properties_iter_t *iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_msg_properties_iter_next           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlbm__msg__properties__iter__t__stct.html">lbm_msg_properties_iter_t</a> *&nbsp;</td>
          <td class="paramname"> <em>iter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd>lbm_msg_properties_t object. <p>
<a class="el" href="lbm_8h.html#cfa02c8316e97baeb9894daa991ef1fb" title="Begin iterating over an.">lbm_msg_properties_iter_first</a> <p>
lbm_msg_properties_iter_prev </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>Iterate to the next element in the currently associated lbm_msg_properties_t object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>LBM_OK for success, LBM_FAILURE if the iterator already points to the last element. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cec18484fc06996fe3b61e76a593d5fb"></a><!-- doxytag: member="lbm.h::lbm_msg_properties_set" ref="cec18484fc06996fe3b61e76a593d5fb" args="(lbm_msg_properties_t *properties, const char *name, const void *value, int type, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_msg_properties_set           </td>
          <td>(</td>
          <td class="paramtype">lbm_msg_properties_t *&nbsp;</td>
          <td class="paramname"> <em>properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#091b5806bf18d10ebd0d9117e0c70229" title="Extended send of a message to the topic associated with a UM source.">lbm_src_send_ex</a> <p>
<a class="el" href="lbm_8h.html#bda1a4224f1c3e94b10b74051be3dd53" title="Creates a new properties object, used for sending messages with properties.">lbm_msg_properties_create</a> <p>
<a class="el" href="lbm_8h.html#ac0dc50537a458d2a2ca418a394fd21b" title="Gets the value of the property with the specified name.">lbm_msg_properties_get</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>properties</em>&nbsp;</td><td>The properties object that the new value should be set on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the property to be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The type of value being specified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The size of the value being specified. For string types, the specified number of bytes will be copied, and a null terminator will be appended. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>LBM_OK for success, LBM_FAILURE for failure, and changes the current value of <a class="el" href="lbm_8h.html#f3a827eb26d87be5b1a6b9fd3a4b63aa" title="Return the error number last encountered by this thread.">lbm_errnum()</a> and lbm_errstr(). </dd></dl>

</div>
</div><p>
<a class="anchor" name="2b7788ff58f9e78bc89ea890dad0cccf"></a><!-- doxytag: member="lbm.h::lbm_msg_retain" ref="2b7788ff58f9e78bc89ea890dad0cccf" args="(lbm_msg_t *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_msg_retain           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function should be called from inside a receiver callback function to prevent UM from automatically deleting the message when the callback function returns (LBM's normal behavior).<p>
Once retained, the application has the responsibility to dispose of the message when it is finished with it by calling <a class="el" href="lbm_8h.html#a5fc1eb324a55b8c800c31460b0f0116" title="Delete a UM message object.">lbm_msg_delete()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Pointer to a UM message object to retain. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fa760960c21f502a8cb4c5ec5d97f91b"></a><!-- doxytag: member="lbm.h::lbm_msg_retrieve_fragment_info" ref="fa760960c21f502a8cb4c5ec5d97f91b" args="(lbm_msg_t *msg, lbm_msg_fragment_info_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_msg_retrieve_fragment_info           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__msg__fragment__info__t__stct.html">lbm_msg_fragment_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Pointer to a UM message object </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 for Success and 0 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="60b05990989966403f948bb888c1a87d"></a><!-- doxytag: member="lbm.h::lbm_msg_retrieve_gateway_info" ref="60b05990989966403f948bb888c1a87d" args="(lbm_msg_t *msg, lbm_msg_gateway_info_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_msg_retrieve_gateway_info           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__msg__gateway__info__t__stct.html">lbm_msg_gateway_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Pointer to a UM message object to retrieve gateway information from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>Pointer to gateway information structure to fill in. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="1443be763d9fd4c183b79e95e0b19605"></a><!-- doxytag: member="lbm.h::lbm_msg_retrieve_msgid" ref="1443be763d9fd4c183b79e95e0b19605" args="(lbm_msg_t *msg, lbm_umq_msgid_t *id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_msg_retrieve_msgid           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__umq__msgid__t__stct.html">lbm_umq_msgid_t</a> *&nbsp;</td>
          <td class="paramname"> <em>id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Pointer to a UM message object to retrieve UMQ Message ID info from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>Pointer to UMQ Message ID structure to fill in. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e12a623cc402cb627501599367750500"></a><!-- doxytag: member="lbm.h::lbm_msg_retrieve_umq_index" ref="e12a623cc402cb627501599367750500" args="(lbm_msg_t *msg, lbm_umq_index_info_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_msg_retrieve_umq_index           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__umq__index__info__t__stct.html">lbm_umq_index_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Pointer to a UM message object to retrieve UMQ index info from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>Pointer to UMQ index structure to fill in. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8fbcb30efc0ede0927402ea8d07ffb39"></a><!-- doxytag: member="lbm.h::lbm_msg_ume_can_send_explicit_ack" ref="8fbcb30efc0ede0927402ea8d07ffb39" args="(lbm_msg_t *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_msg_ume_can_send_explicit_ack           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Pointer to a UM message object to acknowledge up to. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 for true and 0 for False. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d920e7ab51a45099390091dd36d26a34"></a><!-- doxytag: member="lbm.h::lbm_msg_ume_send_explicit_ack" ref="d920e7ab51a45099390091dd36d26a34" args="(lbm_msg_t *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_msg_ume_send_explicit_ack           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function causes a UMP Explicit ACK to be sent that acknowledges previous messages since the last UMP Explicit ACK for the source was performed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Pointer to a UM message object to acknowledge up to. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d7f45b2a1839090ec172a176ff6e2477"></a><!-- doxytag: member="lbm.h::lbm_msg_umq_reassign" ref="d7f45b2a1839090ec172a176ff6e2477" args="(lbm_msg_t *msg, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_msg_umq_reassign           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlbm__msg__t__stct.html">lbm_msg_t</a> *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Pointer to a UM message to request to be reassigned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags indicating various conditions. ORed set of values. <ul>
<li><code>LBM_MSG_UMQ_REASSIGN_FLAG_DISCARD</code> - Message should be discarded instead of being assigned. </li>
</ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="24e5bff3a70e571bb12024af67b47cbb"></a><!-- doxytag: member="lbm.h::lbm_multicast_immediate_message" ref="24e5bff3a70e571bb12024af67b47cbb" args="(lbm_context_t *ctx, const char *topic, const char *data, size_t len, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_multicast_immediate_message           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Multicast immediate messages are NOT guaranteed to maintain order. A loss-recovery event can lead to messages received out of order. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to UM context to send from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>topic</em>&nbsp;</td><td>Topic name to send message to or NULL for non-topic. Topic names should be limited to 246 characters (not including the final null). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Pointer to the data to send in this message </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Length (in bytes) of the data to send in this message. Multicast immediate messages must be 7866 bytes or less in length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags indicating various conditions. ORed set of values. <ul>
<li><code>LBM_SRC_NONBLOCK</code> - If message could not be sent immediately return and error and signal LBM_EWOULDBLOCK. </li>
<li><code>LBM_SRC_BLOCK</code> - Block the caller indefinitely until the message is sent. (This behavior is the default if neither LBM_SRC_NONBLOCK nor LBM_SRC_BLOCK are supplied.) </li>
<li><code>LBM_MSG_FLUSH</code> - Messages are to be sent ASAP (not implicitly batched). </li>
</ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure or 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="54f3933e4dd154a9c7bb72598d0d9ef1"></a><!-- doxytag: member="lbm.h::lbm_multicast_immediate_request" ref="54f3933e4dd154a9c7bb72598d0d9ef1" args="(lbm_request_t **reqp, lbm_context_t *ctx, const char *topic, const char *data, size_t len, lbm_request_cb_proc proc, void *clientd, lbm_event_queue_t *evq, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_multicast_immediate_request           </td>
          <td>(</td>
          <td class="paramtype">lbm_request_t **&nbsp;</td>
          <td class="paramname"> <em>reqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lbm_8h.html#f3ef4385bc929e8a7ff94acbeb1eef75">lbm_request_cb_proc</a>&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>clientd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Multicast immediate messages are NOT guaranteed to maintain order. A loss-recovery event can lead to messages received out of order. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reqp</em>&nbsp;</td><td>A pointer to a pointer for the lbm_request_t object created to be stored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to UM context to send from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>topic</em>&nbsp;</td><td>Topic name to send message to or NULL for non-topic. Topic names should be limited to 246 characters (not including the final null). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Buffer to be included as data in the request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Length (in bytes) of the data to send in this message. Multicast immediate messages must be 7866 bytes or less in length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>Pointer to function to call when responses come in for this request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data returned in the callback proc <em>proc</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>Optional Event Queue to place message events on when they occur. If NULL causes <em>proc</em> to be called from context thread. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags used to instruct UM how to handle this message. See <em>lbm_multicast_immediate_message</em> for more information. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="21cb52dc4c0a14484cfc0454a156e2d8"></a><!-- doxytag: member="lbm.h::lbm_queue_immediate_message" ref="21cb52dc4c0a14484cfc0454a156e2d8" args="(lbm_context_t *ctx, const char *qname, const char *topic, const char *data, size_t len, int flags, lbm_src_send_ex_info_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_queue_immediate_message           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>qname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__src__send__ex__info__t__stct.html">lbm_src_send_ex_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to UM context to submit from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>qname</em>&nbsp;</td><td>Queue to submit message to. Queue names should be limited to 246 bytes characters (not including the final NULL). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>topic</em>&nbsp;</td><td>Topic name to send message to. Topic names should be limited to 246 characters (not including the final NULL). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Pointer to the data to send in this message </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Length (in bytes) of the data to send in this message. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags used to instruct UM how to handle this message. See <em>lbm_unicast_immediate_message</em> for more information. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>Pointer to lbm_src_send_ex_info_t options </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a7491c50fefbc2b70f8035fce7ac1477"></a><!-- doxytag: member="lbm.h::lbm_rcv_create" ref="a7491c50fefbc2b70f8035fce7ac1477" args="(lbm_rcv_t **rcvp, lbm_context_t *ctx, lbm_topic_t *topic, lbm_rcv_cb_proc proc, void *clientd, lbm_event_queue_t *evq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_create           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t **&nbsp;</td>
          <td class="paramname"> <em>rcvp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_topic_t *&nbsp;</td>
          <td class="paramname"> <em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lbm_8h.html#e2d650dd4830971ca0b6197298eddcdd">lbm_rcv_cb_proc</a>&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>clientd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The callback <em>proc</em> will be called to deliver data sent to the topics that the receiver has requested.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from a context thread callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcvp</em>&nbsp;</td><td>A pointer to a pointer to a UM receiver object. Will be filled in by this function to point to the newly created lbm_rcv_t object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the UM context object associated with the receiver. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>topic</em>&nbsp;</td><td>Pointer to the UM topic object associated with the desired receiver topic. </td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Topic references should not be reused. Each <a class="el" href="lbm_8h.html#a7491c50fefbc2b70f8035fce7ac1477" title="Create a UM receiver that will receive messages sent to the given topic.">lbm_rcv_create()</a> call should be preceded by a call to <a class="el" href="lbm_8h.html#3de8a6a659896f76475c453683db4e18" title="Turn a Topic string into a UM topic object usable by receivers.">lbm_rcv_topic_lookup()</a>. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>Pointer to a function to call when messages arrive. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Pointer to client data that is passed when data arrives and <em>proc</em> is called. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>Optional Event Queue to place message events on when they arrive. If NULL causes <em>proc</em> to be called from context thread. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8d5e8713f5ae776330b23a1e371f934d"></a><!-- doxytag: member="lbm.h::lbm_rcv_delete" ref="8d5e8713f5ae776330b23a1e371f934d" args="(lbm_rcv_t *rcv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_delete           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>rcv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete a UM receiver object. Note that there are rare circumstances where this function can return while the receiver callback may still be executing. This would only occur if receiver events are being delivered via an event queue. If the application needs to know when all possible processing on the receiver is complete, it must use <a class="el" href="lbm_8h.html#eb6fc66ee4fdd7f4c9d439af54d45f68" title="Extended delete a UM receiver object.">lbm_rcv_delete_ex()</a>.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from a context thread callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>Pointer to a UM receiver object to delete. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="eb6fc66ee4fdd7f4c9d439af54d45f68"></a><!-- doxytag: member="lbm.h::lbm_rcv_delete_ex" ref="eb6fc66ee4fdd7f4c9d439af54d45f68" args="(lbm_rcv_t *rcv, lbm_event_queue_cancel_cb_info_t *cbinfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_delete_ex           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>rcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__event__queue__cancel__cb__info__t__stct.html">lbm_event_queue_cancel_cb_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cbinfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete a UM receiver object, with an application callback indicating when the receiver is fully canceled. This extended version of the receiver delete function requires the configuration option queue_cancellation_callbacks_enabled be set to 1.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from a context thread callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>Pointer to a UM receiver object to delete. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbinfo</em>&nbsp;</td><td>Cancellation callback information, containing the event queue, function pointer, and client data for the callback. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="db7c9dc08d4917ecdbea534c121fdb28"></a><!-- doxytag: member="lbm.h::lbm_rcv_from_hf_rcv" ref="db7c9dc08d4917ecdbea534c121fdb28" args="(lbm_hf_rcv_t *hfrcv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL lbm_rcv_t* lbm_rcv_from_hf_rcv           </td>
          <td>(</td>
          <td class="paramtype">lbm_hf_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>hfrcv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hfrcv</em>&nbsp;</td><td>Pointer to a UM HF receiver object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Pointer to a UM receiver for the LBM HF receiver object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="dd57a97595ac9b23dd456fb7a67f728f"></a><!-- doxytag: member="lbm.h::lbm_rcv_from_hfx_rcv" ref="dd57a97595ac9b23dd456fb7a67f728f" args="(lbm_hfx_rcv_t *hfxrcv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL lbm_rcv_t* lbm_rcv_from_hfx_rcv           </td>
          <td>(</td>
          <td class="paramtype">lbm_hfx_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>hfxrcv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hfxrcv</em>&nbsp;</td><td>A pointer to a UM hfx_rcv_t object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="767c9e2d97255433a787e336498edf59"></a><!-- doxytag: member="lbm.h::lbm_rcv_getopt" ref="767c9e2d97255433a787e336498edf59" args="(lbm_rcv_t *rcv, const char *optname, void *optval, size_t *optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_getopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>rcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>Pointer to a UM receiver object where the option is stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the option value structure. The structure of the option values are specific to the options themselves. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>When passed, this is the max length (in bytes) of the <em>optval</em> structure. When returned, this is the length of the filled in <em>optval</em> structure. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1abe9c827de0247d804d17e821d68eb1"></a><!-- doxytag: member="lbm.h::lbm_rcv_msg_source_clientd" ref="1abe9c827de0247d804d17e821d68eb1" args="(lbm_rcv_t *rcv, const char *source, void *source_clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_msg_source_clientd           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>rcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>source_clientd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>Pointer to the UM receiver to look for the source on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>String version of the source to look for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source_clientd</em>&nbsp;</td><td>Pointer value to set in subsequent messages delivered. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure and 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8624a19b3cab06cadb9540b5795d688b"></a><!-- doxytag: member="lbm.h::lbm_rcv_reset_all_transport_stats" ref="8624a19b3cab06cadb9540b5795d688b" args="(lbm_rcv_t *rcv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_reset_all_transport_stats           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>rcv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>Pointer to the UM receiver to reset statistics for. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure and 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="052109723d62dcfc0e5561891cc7b0d6"></a><!-- doxytag: member="lbm.h::lbm_rcv_reset_transport_stats" ref="052109723d62dcfc0e5561891cc7b0d6" args="(lbm_rcv_t *rcv, const char *source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_reset_transport_stats           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>rcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>source</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>Pointer to the UM receiver to reset statistics for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>String version of the source to reset statistics for. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure and 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f49cc8ea36d829820466790d9857f9de"></a><!-- doxytag: member="lbm.h::lbm_rcv_retrieve_all_transport_stats" ref="f49cc8ea36d829820466790d9857f9de" args="(lbm_rcv_t *rcv, int *num, lbm_rcv_transport_stats_t *stats)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_retrieve_all_transport_stats           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>rcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__rcv__transport__stats__t__stct.html">lbm_rcv_transport_stats_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stats</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>Pointer to the UM receiver to retrieve statistics for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>Pointer to an integer that must hold the maximum number of elements in the stats array when passed in. Upon return, this value is set to the number of sources filled in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stats</em>&nbsp;</td><td>Array of lbm_rcv_transport_stats_t objects to fill in transport stats for. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure and 0 for Success. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If -1 is returned, and <a class="el" href="lbm_8h.html#f3a827eb26d87be5b1a6b9fd3a4b63aa" title="Return the error number last encountered by this thread.">lbm_errnum()</a> returns LBM_EINVAL, then <em>*num</em> may contain a larger number than the value originally passed into this function. This return value represents the number of lbm_rcv_transport_stats_t objects required in the <em>stats</em> array and can be used to dynamically determine how many entries are needed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4094c703f97a7ebe340b985b2ed1ac2b"></a><!-- doxytag: member="lbm.h::lbm_rcv_retrieve_transport_stats" ref="4094c703f97a7ebe340b985b2ed1ac2b" args="(lbm_rcv_t *rcv, const char *source, lbm_rcv_transport_stats_t *stats)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_retrieve_transport_stats           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>rcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__rcv__transport__stats__t__stct.html">lbm_rcv_transport_stats_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stats</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>Pointer to the UM receiver to retrieve statistics for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>String version of the source to retrieve stats for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stats</em>&nbsp;</td><td>Pointer to a stats structure to fill in. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure and 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fc63f0e557452ac8a8b184c72893a279"></a><!-- doxytag: member="lbm.h::lbm_rcv_setopt" ref="fc63f0e557452ac8a8b184c72893a279" args="(lbm_rcv_t *rcv, const char *optname, const void *optval, size_t optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_setopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>rcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Only those options that can be set during operation may be specified. See "Options That May Be Set During Operation" (doc/Config/maybesetduringoperation.html) in The UM Configuration Guide. For API functions that can access any option, see lbm_rcv_topic_attr_*().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>Pointer to a UM receiver object where the option is to be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the option value structure. The structure of the option values are specific to the options themselves. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>Length (in bytes) of the <em>optval</em> structure. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="16cdcbe8c78428c6ac7b447ec89f2a78"></a><!-- doxytag: member="lbm.h::lbm_rcv_str_getopt" ref="16cdcbe8c78428c6ac7b447ec89f2a78" args="(lbm_rcv_t *rcv, const char *optname, char *optval, size_t *optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_str_getopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>rcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>Pointer to a UM receiver object where the option is stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>String to be filled in with the option value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>When passed, this is the max length (in bytes) of the string. When returned, this is the length of the filled in with the option value. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b592a69f45ea303ab21e9290953b57b4"></a><!-- doxytag: member="lbm.h::lbm_rcv_str_setopt" ref="b592a69f45ea303ab21e9290953b57b4" args="(lbm_rcv_t *rcv, const char *optname, const char *optval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_str_setopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>rcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Only those options that can be set during operation may be specified. See "Options That May Be Set During Operation" (doc/Config/maybesetduringoperation.html) in The UM Configuration Guide. For API functions that can access any option, see lbm_rcv_topic_attr_*(). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>Pointer to a UM receiver object where the option is to be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>String containing the option value. The format of the string is specific to the options themselves. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a8304114445d291e6f16472d733ab250"></a><!-- doxytag: member="lbm.h::lbm_rcv_subscribe_channel" ref="a8304114445d291e6f16472d733ab250" args="(lbm_rcv_t *rcv, lbm_uint32_t channel, lbm_rcv_cb_proc proc, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_subscribe_channel           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>rcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_uint32_t&nbsp;</td>
          <td class="paramname"> <em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lbm_8h.html#e2d650dd4830971ca0b6197298eddcdd">lbm_rcv_cb_proc</a>&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>clientd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The callback <em>proc</em> will be called to deliver messages sent with the specified <em>channel</em> number. If NULL is specified for the <em>proc</em>, messages with the specified <em>channel</em> number will be delivered to the receiver's normal callback. If NULL is specified for the <em>proc</em>, any argument passed in for <em>clientd</em> will be ignored.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from a context thread callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>A pointer to a UM receiver object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>A channel number to subscribe to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>Pointer to a function to call when messages arrive. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Pointer to clientd data that is passed when data arrives and <em>proc</em> is called. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="7570d49deff46d63d636956e7a0dd2c4"></a><!-- doxytag: member="lbm.h::lbm_rcv_topic_attr_create" ref="7570d49deff46d63d636956e7a0dd2c4" args="(lbm_rcv_topic_attr_t **attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_topic_attr_create           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_topic_attr_t **&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is allocated and filled with the current default values that are used by lbm_topic_t objects that concern receivers and may have been modified by a previously loaded configuration file.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a pointer to a UM receiver topic attribute structure. Will be filled in by this function to point to the newly created lbm_rcv_topic_attr_t object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a0b62bc911b175ff51236ecf101d0d93"></a><!-- doxytag: member="lbm.h::lbm_rcv_topic_attr_create_default" ref="a0b62bc911b175ff51236ecf101d0d93" args="(lbm_rcv_topic_attr_t **attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_topic_attr_create_default           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_topic_attr_t **&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is allocated and filled with the initial or factory default values built into LBM that are used by lbm_topic_t objects that concern receivers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a pointer to a UM receiver topic attribute structure. Will be filled in by this function to point to the newly created lbm_rcv_topic_attr_t object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0427c06f6d62e7401d9a7d1f09c79a2c"></a><!-- doxytag: member="lbm.h::lbm_rcv_topic_attr_create_from_xml" ref="0427c06f6d62e7401d9a7d1f09c79a2c" args="(lbm_rcv_topic_attr_t **attr, const char *context_name, const char *topicname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_topic_attr_create_from_xml           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_topic_attr_t **&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>context_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>topicname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is allocated and filled with the current default values that are used by lbm_topic_t objects that concern receivers and may have been modified by a previously loaded configuration file. If an XML configuration file has been loaded, the attribute object is further filled with the defaults for the given context name and receiver topic name. If the context name or receiver topic name are not permitted by the XML configuration, -1 is returned and no attribute object is created.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a pointer to a UM receiver topic attribute structure. Will be filled in by this function to point to the newly created lbm_rcv_topic_attr_t object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>context_name</em>&nbsp;</td><td>The context name used to lookup the receiver topic in the XML configuration. A NULL value is permitted, and will match unnamed contexts defined in the XML. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>topicname</em>&nbsp;</td><td>The topic name used to lookup the receiver topic in the XML configuration. A NULL value is *not* permitted and will result in an error. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f70d14c26efadade6ad1e22d254f4e1b"></a><!-- doxytag: member="lbm.h::lbm_rcv_topic_attr_delete" ref="f70d14c26efadade6ad1e22d254f4e1b" args="(lbm_rcv_topic_attr_t *attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_topic_attr_delete           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_topic_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is cleaned up and deleted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM source topic attribute object as returned by <a class="el" href="lbm_8h.html#7570d49deff46d63d636956e7a0dd2c4" title="Create and fill a UM receiver topic attribute object with the current default values...">lbm_rcv_topic_attr_create</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7a8f94b03c37c4481044d3c6b250bdb3"></a><!-- doxytag: member="lbm.h::lbm_rcv_topic_attr_dump" ref="7a8f94b03c37c4481044d3c6b250bdb3" args="(lbm_rcv_topic_attr_t *rattr, int *size, lbm_config_option_t *opts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_topic_attr_dump           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_topic_attr_t *&nbsp;</td>
          <td class="paramname"> <em>rattr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_config_option_t *&nbsp;</td>
          <td class="paramname"> <em>opts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The config object is filled with source topic configuration options <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>The receiver topic attribute object to retrieve the attributes from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the opts array. Will return the number of items that were set in opts </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opts</em>&nbsp;</td><td>The options array to fill </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a5a904ef90068238358b66562ec30f44"></a><!-- doxytag: member="lbm.h::lbm_rcv_topic_attr_dup" ref="a5a904ef90068238358b66562ec30f44" args="(lbm_rcv_topic_attr_t **attr, const lbm_rcv_topic_attr_t *original)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_topic_attr_dup           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_topic_attr_t **&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lbm_rcv_topic_attr_t *&nbsp;</td>
          <td class="paramname"> <em>original</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A new attribute object is created as a copy of an existing object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a pointer to a UM receiver topic attribute structure. Will be filled in by this function to point to the newly created lbm_rcv_topic_attr_t object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>original</em>&nbsp;</td><td>Pointer to a UM receiver topic attribute object as returned by <a class="el" href="lbm_8h.html#7570d49deff46d63d636956e7a0dd2c4" title="Create and fill a UM receiver topic attribute object with the current default values...">lbm_rcv_topic_attr_create</a> or <a class="el" href="lbm_8h.html#a0b62bc911b175ff51236ecf101d0d93" title="Create and fill a UM receiver topic attribute object with the initial default values...">lbm_rcv_topic_attr_create_default</a>, from which <em>attr</em> is initialized. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6486a4096cbe232967c5f4a3d1d859cb"></a><!-- doxytag: member="lbm.h::lbm_rcv_topic_attr_getopt" ref="6486a4096cbe232967c5f4a3d1d859cb" args="(lbm_rcv_topic_attr_t *attr, const char *optname, void *optval, size_t *optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_topic_attr_getopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_topic_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM receiver topic attribute object where the option is stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the option value structure. The structure of the option values are specific to the options themselves. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>When passed, this is the max length (in bytes) of the <em>optval</em> structure. When returned, this is the length of the filled in <em>optval</em> structure. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cf137258cb4a6633caeab1c4a3755be3"></a><!-- doxytag: member="lbm.h::lbm_rcv_topic_attr_option_size" ref="cf137258cb4a6633caeab1c4a3755be3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_topic_attr_option_size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function returns the number of entries that are of type "source topic"<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of entries that are of type "source topic" </dd></dl>

</div>
</div><p>
<a class="anchor" name="3edb4ccb0e392da57bc7a46fe21e7007"></a><!-- doxytag: member="lbm.h::lbm_rcv_topic_attr_set_from_xml" ref="3edb4ccb0e392da57bc7a46fe21e7007" args="(lbm_rcv_topic_attr_t *attr, const char *context_name, const char *topicname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_topic_attr_set_from_xml           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_topic_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>context_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>topicname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is filled with the defaults for the given context name and receiver topic name, if an XML configuration file has been loaded. If the context name or receiver topic name are not permitted by the XML configuration, -1 is returned and the attribute object is not written to.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a UM receiver topic attribute structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>context_name</em>&nbsp;</td><td>The context name used to lookup the receiver topic in the XML configuration. A NULL value is permitted, and will match unnamed contexts defined in the XML. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>topicname</em>&nbsp;</td><td>The topic name used to lookup the receiver topic in the XML configuration. A NULL value is *not* permitted and will result in an error. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1afc75f0fb3601d072b3463e7acf16a6"></a><!-- doxytag: member="lbm.h::lbm_rcv_topic_attr_setopt" ref="1afc75f0fb3601d072b3463e7acf16a6" args="(lbm_rcv_topic_attr_t *attr, const char *optname, const void *optval, size_t optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_topic_attr_setopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_topic_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used before the topic is looked up and the receiver created. NOTE: the attribute object must first be initialized with the corresponding _attr_create() function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM receiver topic attribute object where the option is to be set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the option value structure. The structure of the option values are specific to the options themselves. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>Length (in bytes) of the <em>optval</em> structure. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ba79f39d27fb6fd38d8bc6985a33c8ec"></a><!-- doxytag: member="lbm.h::lbm_rcv_topic_attr_str_getopt" ref="ba79f39d27fb6fd38d8bc6985a33c8ec" args="(lbm_rcv_topic_attr_t *attr, const char *optname, char *optval, size_t *optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_topic_attr_str_getopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_topic_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM receiver topic attribute object where the option is stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>String to be filled in with the option value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>When passed, this is the max length (in bytes) of the string. When returned, this is the length of the filled in option value. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fabe075e34f7f712f09f710df87d9164"></a><!-- doxytag: member="lbm.h::lbm_rcv_topic_attr_str_setopt" ref="fabe075e34f7f712f09f710df87d9164" args="(lbm_rcv_topic_attr_t *attr, const char *optname, const char *optval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_topic_attr_str_setopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_topic_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used before the topic is looked up and the receiver created. NOTE: the attribute object must first be initialized with the corresponding _attr_create() function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM receiver topic attribute object where the option is to be set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>String containing the option value. The format of the string is specific to the options themselves. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="401a14b61ff1e465cc0d3cd8acade13f"></a><!-- doxytag: member="lbm.h::lbm_rcv_topic_dump" ref="401a14b61ff1e465cc0d3cd8acade13f" args="(lbm_rcv_t *rcv, int *size, lbm_config_option_t *opts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_topic_dump           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>rcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_config_option_t *&nbsp;</td>
          <td class="paramname"> <em>opts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The config object is filled with source topic configuration options <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>The receiver object to retrieve the attributes from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the opts array. Will return the number of items that were set in opts </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opts</em>&nbsp;</td><td>The options array to fill </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3de8a6a659896f76475c453683db4e18"></a><!-- doxytag: member="lbm.h::lbm_rcv_topic_lookup" ref="3de8a6a659896f76475c453683db4e18" args="(lbm_topic_t **topicp, lbm_context_t *ctx, const char *symbol, const lbm_rcv_topic_attr_t *attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_topic_lookup           </td>
          <td>(</td>
          <td class="paramtype">lbm_topic_t **&nbsp;</td>
          <td class="paramname"> <em>topicp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lbm_rcv_topic_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from a context thread callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>topicp</em>&nbsp;</td><td>A pointer to a pointer to a UM topic object. Will be filled in by this function to point to an lbm_topic_t object.</td></tr>
  </table>
</dl>
NOTE: Topic objects are cached. If a previously created topic object is found, it will be returned instead of a new object. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Context object for topic </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>symbol</em>&nbsp;</td><td>The topic string. Topic strings should be limited in length to 246 characters (not including the final null). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a receiver topic attributes object for passing in options </td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Setting attributes is only possible when a topic object is first created. This parameter will be ignored on subsequent lookups. </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="861f4a170ec4caf4533669ee53fbf36f"></a><!-- doxytag: member="lbm.h::lbm_rcv_ume_deregister" ref="861f4a170ec4caf4533669ee53fbf36f" args="(lbm_rcv_t *rcv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_ume_deregister           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>rcv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function causes a UMP deregistration request to be sent to all stores the receiver is currently registered to, and disallows any future registrations.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>Pointer to an UM receiver object </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="eeb72be91872f87626d26156c3201dfe"></a><!-- doxytag: member="lbm.h::lbm_rcv_umq_deregister" ref="eeb72be91872f87626d26156c3201dfe" args="(lbm_rcv_t *rcv, const char *queue_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_umq_deregister           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>rcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>queue_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>Pointer to receiver object to de-register. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>queue_name</em>&nbsp;</td><td>Name of the queue or ULB source to deregister from. A NULL means de-register from all UMQ queues and ULB sources. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e145484500af1e2af206f02cd6b57f7e"></a><!-- doxytag: member="lbm.h::lbm_rcv_umq_index_release" ref="e145484500af1e2af206f02cd6b57f7e" args="(lbm_rcv_t *rcv, const char *queue_name, lbm_umq_index_info_t *index_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_umq_index_release           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>rcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>queue_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__umq__index__info__t__stct.html">lbm_umq_index_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>index_info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function causes the UMQ indices to be assigned to another receiver.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>Pointer to receiver object that wishes to release the index. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>queue_name</em>&nbsp;</td><td>Name of the queue to reassign the index. A NULL means reassign the index for all UMQ queues. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="31ea2d64682933ad69600bf22e13a34d"></a><!-- doxytag: member="lbm.h::lbm_rcv_umq_index_reserve" ref="31ea2d64682933ad69600bf22e13a34d" args="(lbm_rcv_t *rcv, const char *queue_name, lbm_umq_index_info_t *index_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_umq_index_reserve           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>rcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>queue_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__umq__index__info__t__stct.html">lbm_umq_index_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>index_info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function causes the UMQ queue(s) or ULB sources to assign the specified index to this receiver if the queue ever happens to see a message sent on the specified index. If the index is already assigned, an error is returned as a LBM_MSG_UMQ_INDEX_ASSIGNMENT_ERROR receiver event. Otherwise, if the reservation is successful, the receiver will get a LBM_MSG_UMQ_INDEX_ASSIGNED_EX event.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>Pointer to receiver object that wishes to release the index. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>queue_name</em>&nbsp;</td><td>Name of the queue(s) at which to reserve the index. A NULL means reassign the index for all UMQ queues. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index_info</em>&nbsp;</td><td>Index to reserve, or NULL to reserve a random unused numeric index. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="07e8018202c16a5e0bcfefbef995f9a4"></a><!-- doxytag: member="lbm.h::lbm_rcv_umq_index_start_assignment" ref="07e8018202c16a5e0bcfefbef995f9a4" args="(lbm_rcv_t *rcv, const char *queue_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_umq_index_start_assignment           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>rcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>queue_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>Pointer to receiver object to start assignment for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>queue_name</em>&nbsp;</td><td>Name of the queue to start assignment from. A NULL means start assignment from all UMQ queues. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f8ae533fd1738fffc12d5b986cbf5338"></a><!-- doxytag: member="lbm.h::lbm_rcv_umq_index_stop_assignment" ref="f8ae533fd1738fffc12d5b986cbf5338" args="(lbm_rcv_t *rcv, const char *queue_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_umq_index_stop_assignment           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>rcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>queue_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function causes new UMQ indices to not be assigned to the given receiver from the given UMQ queue(s). Messages with previously assigned UMQ indices may continue to be delivered to the given receiver from the given UMQ queue(s).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>Pointer to receiver object to stop assignment for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>queue_name</em>&nbsp;</td><td>Name of the queue to stop assignment from. A NULL means stop assignment from all UMQ queues. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f08bf16a7384ce04db3b13382871b814"></a><!-- doxytag: member="lbm.h::lbm_rcv_umq_queue_msg_list" ref="f08bf16a7384ce04db3b13382871b814" args="(lbm_rcv_t *rcv, const char *queue_name, lbm_umq_msg_selector_t *selector, lbm_async_operation_func_t *async_opfunc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_umq_queue_msg_list           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>rcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>queue_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_umq_msg_selector_t *&nbsp;</td>
          <td class="paramname"> <em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__async__operation__func__t.html">lbm_async_operation_func_t</a> *&nbsp;</td>
          <td class="paramname"> <em>async_opfunc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Results are valid once the asynchronous operation callback is called with the LBM_ASYNC_OP_STATUS_COMPLETE status. An array of <a class="el" href="structlbm__umq__queue__msg__status__t.html" title="Struct containing extended asynchronous operation status information about a single...">lbm_umq_queue_msg_status_t</a> objects is returned, each with its msgid field set to a valid UMQ message ID of a message that is currently in the queue within the application set to which the observer receiver belongs. All message IDs of all currently enqueued messages are returned. NOTE: The only valid field of each <a class="el" href="structlbm__umq__queue__msg__status__t.html" title="Struct containing extended asynchronous operation status information about a single...">lbm_umq_queue_msg_status_t</a> object will be the msgid field; all other fields will be NULL or 0 and should not be relied upon to be accurate.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>Pointer to observer receiver object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>queue_name</em>&nbsp;</td><td>Name of the queue to retrieve the list of messages from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>selector</em>&nbsp;</td><td>Not currently supported; please pass NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>async_opfunc</em>&nbsp;</td><td>The asynchronous operation callback the topic list will be delivered to. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f8222d6585b6077f2b5aba736dc3c8fa"></a><!-- doxytag: member="lbm.h::lbm_rcv_umq_queue_msg_retrieve" ref="f8222d6585b6077f2b5aba736dc3c8fa" args="(lbm_rcv_t *rcv, const char *queue_name, lbm_umq_msgid_t *msgids, int num_msgids, lbm_async_operation_func_t *async_opfunc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_umq_queue_msg_retrieve           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>rcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>queue_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__umq__msgid__t__stct.html">lbm_umq_msgid_t</a> *&nbsp;</td>
          <td class="paramname"> <em>msgids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num_msgids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__async__operation__func__t.html">lbm_async_operation_func_t</a> *&nbsp;</td>
          <td class="paramname"> <em>async_opfunc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Results are valid once the asynchronous operation callback is called with the LBM_ASYNC_OP_STATUS_COMPLETE status. An array of <a class="el" href="structlbm__umq__queue__msg__status__t.html" title="Struct containing extended asynchronous operation status information about a single...">lbm_umq_queue_msg_status_t</a> objects is returned; the size of the array returned will match the size of the msgids array originally passed in. Each returned <a class="el" href="structlbm__umq__queue__msg__status__t.html" title="Struct containing extended asynchronous operation status information about a single...">lbm_umq_queue_msg_status_t</a> object contains state information (LBM_UMQ_QUEUE_MSG_STATUS_UNASSIGNED, LBM_UMQ_QUEUE_MSG_STATUS_CONSUMED, etc.), and possibly message data, for each requested message. If message data was available, the msg field of the <a class="el" href="structlbm__umq__queue__msg__status__t.html" title="Struct containing extended asynchronous operation status information about a single...">lbm_umq_queue_msg_status_t</a> object will be non-NULL; otherwise it will be NULL. Message data is not always still available for a given message ID (in the case of a message that has been fully consumed across all configured application sets in the queue, for example).<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#90a9c177ec57faac06f65cb13571b841" title="Queue message status; queue has no knowledge of the message.">LBM_UMQ_QUEUE_MSG_STATUS_UNKNOWN</a> <p>
<a class="el" href="lbm_8h.html#c1ba1eca0a613a6d99c4307b006c0d64" title="Queue message status; message is currently enqueued but not yet assigned.">LBM_UMQ_QUEUE_MSG_STATUS_UNASSIGNED</a> <p>
<a class="el" href="lbm_8h.html#8936000abf1190c32a613dcccdff7924" title="Queue message status; message is currently assigned to a receiver but not yet consumed...">LBM_UMQ_QUEUE_MSG_STATUS_ASSIGNED</a> <p>
<a class="el" href="lbm_8h.html#f4b83e6b46d14665863e7f9891ec135c" title="Queue message status; message is waiting to be re-assigned to a different receiver...">LBM_UMQ_QUEUE_MSG_STATUS_REASSIGNING</a> <p>
<a class="el" href="lbm_8h.html#ad7023aaefa277f6149504ab79f3abac" title="Queue message status; message has been fully consumed and is no longer present in...">LBM_UMQ_QUEUE_MSG_STATUS_CONSUMED</a></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>Pointer to observer receiver object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>queue_name</em>&nbsp;</td><td>Name of the queue to retrieve the messages from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msgids</em>&nbsp;</td><td>Array of UMQ message IDs to retrieve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_msgids</em>&nbsp;</td><td>Length of message ID array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>async_opfunc</em>&nbsp;</td><td>The asynchronous operation callback the retrieved messages will be delivered to. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ac3f8d58d98db9b2471982a44e157ae9"></a><!-- doxytag: member="lbm.h::lbm_rcv_unsubscribe_channel" ref="ac3f8d58d98db9b2471982a44e157ae9" args="(lbm_rcv_t *rcv, lbm_uint32_t channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_unsubscribe_channel           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>rcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_uint32_t&nbsp;</td>
          <td class="paramname"> <em>channel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove a subscription to a channel previously subscribed to with <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#a8304114445d291e6f16472d733ab250" title="Subscribe to a channel, with an optional callback and clientd data pointer.">lbm_rcv_subscribe_channel</a>.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>A pointer to a UM receiver object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>The channel number for the channel subscription to be removed. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="53023d43207f2d4b0a37143e96383a96"></a><!-- doxytag: member="lbm.h::lbm_rcv_unsubscribe_channel_ex" ref="53023d43207f2d4b0a37143e96383a96" args="(lbm_rcv_t *rcv, lbm_uint32_t channel, lbm_event_queue_cancel_cb_info_t *cbinfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_rcv_unsubscribe_channel_ex           </td>
          <td>(</td>
          <td class="paramtype">lbm_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>rcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_uint32_t&nbsp;</td>
          <td class="paramname"> <em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__event__queue__cancel__cb__info__t__stct.html">lbm_event_queue_cancel_cb_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cbinfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>A pointer to a UM receiver object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>The channel number for the channel subscription to be removed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbinfo</em>&nbsp;</td><td>Cancellation callback information, containing the event queue, function pointer, and client data for the callback. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="50d8ea5a6ebb5f1f0c6c5d9155c09657"></a><!-- doxytag: member="lbm.h::lbm_register_fd" ref="50d8ea5a6ebb5f1f0c6c5d9155c09657" args="(lbm_context_t *ctx, lbm_handle_t handle, lbm_fd_cb_proc proc, void *clientd, lbm_event_queue_t *evq, lbm_ulong_t ev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_register_fd           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_handle_t&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lbm_8h.html#0aa2a7e14eca4d75925063cac2ecd879">lbm_fd_cb_proc</a>&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>clientd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_ulong_t&nbsp;</td>
          <td class="paramname"> <em>ev</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This registers a file descriptor/socket event that will call the function <em>proc</em> at a later time passing in specified data when the event occurs. NOTE: this functionality is not available for Windows-based contexts where completion ports are specified. See configuration option "context fd_management_type".<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#ea6845ad513f07a994d23d3c50201436" title="Cancel a previously registered file descriptor/socket event.">lbm_cancel_fd</a> </dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not recommended to call this function from a context thread callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the UM context object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>file descriptor/socket of interest for event. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>Pointer to the function to call when the event occurs </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Pointer to client data that is passed when the event occurs. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>Optional Event Queue to place events on when they occur. If NULL causes <em>proc</em> to be called from context thread. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ev</em>&nbsp;</td><td>One or more of LBM_FD_EVENT_* (ORed to together). Mask of events of interest. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0abaa1c2ba62bba7a5eaf1f7f2abbac0"></a><!-- doxytag: member="lbm.h::lbm_request_delete" ref="0abaa1c2ba62bba7a5eaf1f7f2abbac0" args="(lbm_request_t *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_request_delete           </td>
          <td>(</td>
          <td class="paramtype">lbm_request_t *&nbsp;</td>
          <td class="paramname"> <em>req</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete a UM request object. When this function is used, subsequent responses for this given request object will be ignored. Note that this function can return while the callback may still be executing if request events are being delivered via an event queue. If the application needs to know when all possible processing on the request is complete, it must use <a class="el" href="lbm_8h.html#f69d50b0f35e28bf6f36a9c5d9df2258" title="Extended delete a UM request object.">lbm_request_delete_ex()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>req</em>&nbsp;</td><td>A pointer to an lbm_request_t object returned by <em>lbm_send_request</em>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f69d50b0f35e28bf6f36a9c5d9df2258"></a><!-- doxytag: member="lbm.h::lbm_request_delete_ex" ref="f69d50b0f35e28bf6f36a9c5d9df2258" args="(lbm_request_t *req, lbm_event_queue_cancel_cb_info_t *cbinfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_request_delete_ex           </td>
          <td>(</td>
          <td class="paramtype">lbm_request_t *&nbsp;</td>
          <td class="paramname"> <em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__event__queue__cancel__cb__info__t__stct.html">lbm_event_queue_cancel_cb_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cbinfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete a UM request object, with an application callback indicating when the request is fully canceled. When this function is used, any more responses for this given request object will be ignored. This extended version of the request cancel function requires the configuration option queue_cancellation_callbacks_enabled be set to 1.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>req</em>&nbsp;</td><td>A pointer to an lbm_request_t object returned by <em>lbm_send_request</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbinfo</em>&nbsp;</td><td>Cancellation callback information, containing the event queue, function pointer, and client data for the callback. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="95bbc6a8adcdc3217ee3ee4d24f3a70e"></a><!-- doxytag: member="lbm.h::lbm_response_delete" ref="95bbc6a8adcdc3217ee3ee4d24f3a70e" args="(lbm_response_t *resp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_response_delete           </td>
          <td>(</td>
          <td class="paramtype">lbm_response_t *&nbsp;</td>
          <td class="paramname"> <em>resp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When an application receives a <em>request</em>, the message object <em>lbm_msg_t</em> contains a response object <em>response</em> which is used by <a class="el" href="lbm_8h.html#0bbc01b600ccc2ae874474e35955eb85" title="Send a response for a given resp response.">lbm_send_response()</a>. Normally, when the receive callback returns, both the message and the response object are deleted by UM. However the receive callback can optionally save the response object and set <em>msg-&gt;response=NULL</em> to prevent UM from deleting it when the receive callback returns. It then becomes the application's responsibility to delete the response when appropriate.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd>lbm_msg_t, <a class="el" href="lbm_8h.html#a5fc1eb324a55b8c800c31460b0f0116" title="Delete a UM message object.">lbm_msg_delete</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>resp</em>&nbsp;</td><td>A pointer to an lbm_response_t object given in a lbm_msg_t object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6ddbee95ee1eb4e6b98b177f84157f8a"></a><!-- doxytag: member="lbm.h::lbm_schedule_timer" ref="6ddbee95ee1eb4e6b98b177f84157f8a" args="(lbm_context_t *ctx, lbm_timer_cb_proc proc, void *clientd, lbm_event_queue_t *evq, lbm_ulong_t delay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_schedule_timer           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lbm_8h.html#147d905636bb3b870ba5c0096c3f66b9">lbm_timer_cb_proc</a>&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>clientd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_ulong_t&nbsp;</td>
          <td class="paramname"> <em>delay</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This schedules a timer that will call the function <em>proc</em> at a later time passing in specified data. This is a one-shot timer. To implement a recurring timer, the callback function should call <a class="el" href="lbm_8h.html#6ddbee95ee1eb4e6b98b177f84157f8a" title="Schedule a timer that calls proc when it expires.">lbm_schedule_timer()</a> again.<p>
A zero duration timer is legal and causes the associated callback to be called as soon as possible on the context thread or to be enqueued as an event on the associated event queue. In this case, the event queue dispatching thread calls the associated callback after all currently pending events have been dispatched.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#ac8fc2f828cdcd6a44282c950ee01fb0" title="Cancel a previously scheduled timer identified by id.">lbm_cancel_timer</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the UM context object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>Pointer to the function to call when the timer expires. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Pointer to client data that is passed when the timer expires. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>Optional Event Queue to place timer events on when they occur. If NULL causes <em>proc</em> to be called from context thread. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delay</em>&nbsp;</td><td>Delay until <em>proc</em> should be called (in milliseconds). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An identifier for the timer that may be used to cancel it or -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="24835c6842e7973ceff9fd60fb3239c9"></a><!-- doxytag: member="lbm.h::lbm_schedule_timer_recurring" ref="24835c6842e7973ceff9fd60fb3239c9" args="(lbm_context_t *ctx, lbm_timer_cb_proc proc, void *clientd, lbm_event_queue_t *evq, lbm_ulong_t delay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_schedule_timer_recurring           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lbm_8h.html#147d905636bb3b870ba5c0096c3f66b9">lbm_timer_cb_proc</a>&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>clientd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_ulong_t&nbsp;</td>
          <td class="paramname"> <em>delay</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This schedules a recurring timer that calls the function <em>proc</em> at the given time interval passing in the specified data. The timer will reschedule itself each time it expires and must be explicitly canceled to stop the timer. Caution should be exercised with the delay since timer events will build up if the application can not process the events fast enough.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#ac8fc2f828cdcd6a44282c950ee01fb0" title="Cancel a previously scheduled timer identified by id.">lbm_cancel_timer</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the UM context object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>Pointer to the function to call when the timer expires. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Pointer to client data that is passed when the timer expires. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>Optional Event Queue to place timer events on when they occur. If NULL causes <em>proc</em> to be called from context thread. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delay</em>&nbsp;</td><td>Delay until <em>proc</em> should be called (in milliseconds). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An identifier for the timer that may be used to cancel it or -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d4d06f66b8404684e191ca178e0cc09b"></a><!-- doxytag: member="lbm.h::lbm_send_request" ref="d4d06f66b8404684e191ca178e0cc09b" args="(lbm_request_t **reqp, lbm_src_t *src, const char *data, size_t len, lbm_request_cb_proc proc, void *clientd, lbm_event_queue_t *evq, int send_flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_send_request           </td>
          <td>(</td>
          <td class="paramtype">lbm_request_t **&nbsp;</td>
          <td class="paramname"> <em>reqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lbm_8h.html#f3ef4385bc929e8a7ff94acbeb1eef75">lbm_request_cb_proc</a>&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>clientd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>send_flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function creates a request object <em>reqp</em> which is used by UM to route responses to the desired application callback <em>proc</em> and must be retained until all responses are received. When the requestor does not expect any additional responses, it deletes the request object using <a class="el" href="lbm_8h.html#0abaa1c2ba62bba7a5eaf1f7f2abbac0" title="Delete a UM request object.">lbm_request_delete()</a>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#91f4b9cb04fe1323ec56833211cc5cb7" title="Send a message to the topic associated with a UM source.">lbm_src_send</a> </dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not recommended to call this function from a context thread callback. If called from a context thread callback, use the LBM_SRC_NONBLOCK flag and handle any LBM_EWOULDBLOCK errors internally. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reqp</em>&nbsp;</td><td>A pointer to a pointer for the lbm_request_t object created to be stored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The UM source to send the request out. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Buffer to be included as data in the request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Length (in bytes) of the data included with the request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>Pointer to function to call when responses come in for this request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data returned in the callback proc <em>proc</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>Optional Event Queue to place message events on when they occur. If NULL causes <em>proc</em> to be called from context thread. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>send_flags</em>&nbsp;</td><td>Flags used to instruct UM how to handle this message. See <em><a class="el" href="lbm_8h.html#91f4b9cb04fe1323ec56833211cc5cb7" title="Send a message to the topic associated with a UM source.">lbm_src_send()</a></em> for more information. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="abcfb44e7f5188a47d8d56540e783fa7"></a><!-- doxytag: member="lbm.h::lbm_send_request_ex" ref="abcfb44e7f5188a47d8d56540e783fa7" args="(lbm_request_t **reqp, lbm_src_t *src, const char *data, size_t len, lbm_request_cb_proc proc, void *clientd, lbm_event_queue_t *evq, int send_flags, lbm_src_send_ex_info_t *exinfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_send_request_ex           </td>
          <td>(</td>
          <td class="paramtype">lbm_request_t **&nbsp;</td>
          <td class="paramname"> <em>reqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lbm_8h.html#f3ef4385bc929e8a7ff94acbeb1eef75">lbm_request_cb_proc</a>&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>clientd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>send_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__src__send__ex__info__t__stct.html">lbm_src_send_ex_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>exinfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function creates a request object <em>reqp</em> which is used by UM to route responses to the desired application callback <em>proc</em> and must be retained until all responses are received. When the requestor does not expect any additional responses, it deletes the request object using <a class="el" href="lbm_8h.html#0abaa1c2ba62bba7a5eaf1f7f2abbac0" title="Delete a UM request object.">lbm_request_delete()</a>.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#91f4b9cb04fe1323ec56833211cc5cb7" title="Send a message to the topic associated with a UM source.">lbm_src_send</a> </dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not recommended to call this function from a context thread callback. If called from a context thread callback, use the LBM_SRC_NONBLOCK flag and handle any LBM_EWOULDBLOCK errors internally. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reqp</em>&nbsp;</td><td>A pointer to a pointer for the lbm_request_t object created to be stored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The UM source to send the request out. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Buffer to be included as data in the request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Length (in bytes) of the data included with the request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>Pointer to function to call when responses come in for this request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data returned in the callback proc <em>proc</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>Optional Event Queue to place message events on when they occur. If NULL causes <em>proc</em> to be called from context thread. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>send_flags</em>&nbsp;</td><td>Flags used to instruct UM how to handle this message. See <em><a class="el" href="lbm_8h.html#91f4b9cb04fe1323ec56833211cc5cb7" title="Send a message to the topic associated with a UM source.">lbm_src_send()</a></em> for more information. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>exinfo</em>&nbsp;</td><td>Pointer to lbm_src_send_ex_info_t options </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0bbc01b600ccc2ae874474e35955eb85"></a><!-- doxytag: member="lbm.h::lbm_send_response" ref="0bbc01b600ccc2ae874474e35955eb85" args="(lbm_response_t *resp, const char *data, size_t len, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_send_response           </td>
          <td>(</td>
          <td class="paramtype">lbm_response_t *&nbsp;</td>
          <td class="paramname"> <em>resp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>resp</em>&nbsp;</td><td>A pointer to an lbm_response_t object given in a lbm_msg_t object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Buffer to send as the response data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Length (in bytes) of the data to send as the response data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags indicating various conditions. ORed set of values. <ul>
<li><code>LBM_SRC_NONBLOCK</code> - If messages could not be sent immediately return and error and signal LBM_EWOULDBLOCK. </li>
<li><code>LBM_SRC_BLOCK</code> - Block the caller indefinitely until the message is sent. (This behavior is the default if neither LBM_SRC_NONBLOCK nor LBM_SRC_BLOCK are supplied.) </li>
</ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure or the number of bytes sent if Successful. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7595677bf01cb9397d1fd174bd095e9f"></a><!-- doxytag: member="lbm.h::lbm_serialize_response" ref="7595677bf01cb9397d1fd174bd095e9f" args="(lbm_response_t *resp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL <a class="el" href="structlbm__serialized__response__t__stct.html">lbm_serialized_response_t</a>* lbm_serialize_response           </td>
          <td>(</td>
          <td class="paramtype">lbm_response_t *&nbsp;</td>
          <td class="paramname"> <em>resp</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
An UM response object (lbm_response_t) may be serialized to allow applications other than the one originally receiving a request to respond to that request.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>resp</em>&nbsp;</td><td>A pointer to an lbm_response_t object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to an lbm_serialized_response_t object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0ce3f03714d1c51c8dcf30bdda7b37c4"></a><!-- doxytag: member="lbm.h::lbm_serialized_response_delete" ref="0ce3f03714d1c51c8dcf30bdda7b37c4" args="(lbm_serialized_response_t *serialized_response)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_serialized_response_delete           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlbm__serialized__response__t__stct.html">lbm_serialized_response_t</a> *&nbsp;</td>
          <td class="paramname"> <em>serialized_response</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
After a serialized UM response object has been copied or used, it is the application's responsibility to delete the serialized response object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>serialized_response</em>&nbsp;</td><td>A pointer to an lbm_serialized_response_t object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c00b82eb9ab67d4069cc99d94e4b256d"></a><!-- doxytag: member="lbm.h::lbm_set_lbtrm_loss_rate" ref="c00b82eb9ab67d4069cc99d94e4b256d" args="(int rate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL void lbm_set_lbtrm_loss_rate           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rate</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the LBT-RM loss rate. This is equivalent to setting the environment variable LBTRM_LOSS_RATE, but allows the loss rate to be changed under program control. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rate</em>&nbsp;</td><td>Loss rate (from 0 to 100). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e8cce89fbfdc2bd60065dd9ec2d45027"></a><!-- doxytag: member="lbm.h::lbm_set_lbtrm_src_loss_rate" ref="e8cce89fbfdc2bd60065dd9ec2d45027" args="(int rate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL void lbm_set_lbtrm_src_loss_rate           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rate</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the LBT-RM source loss rate. This is equivalent to setting the environment variable LBTRM_SRC_LOSS_RATE, but allows the loss rate to be changed under program control. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rate</em>&nbsp;</td><td>Loss rate (from 0 to 100). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6f3c10e8d065ac051b098326c836c2f4"></a><!-- doxytag: member="lbm.h::lbm_set_lbtru_loss_rate" ref="6f3c10e8d065ac051b098326c836c2f4" args="(int rate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL void lbm_set_lbtru_loss_rate           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rate</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the LBT-RU loss rate. This is equivalent to setting the environment variable LBTRU_LOSS_RATE, but allows the loss rate to be changed under program control. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rate</em>&nbsp;</td><td>Loss rate (from 0 to 100). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bf742a93fe06c320e35ab636352bed66"></a><!-- doxytag: member="lbm.h::lbm_set_lbtru_src_loss_rate" ref="bf742a93fe06c320e35ab636352bed66" args="(int rate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL void lbm_set_lbtru_src_loss_rate           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rate</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the LBT-RU source loss rate. This is equivalent to setting the environment variable LBTRU_SRC_LOSS_RATE, but allows the loss rate to be changed under program control. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rate</em>&nbsp;</td><td>Loss rate (from 0 to 100). </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ab029e3f210b40f3fded64fec2a27a02"></a><!-- doxytag: member="lbm.h::lbm_set_umm_info" ref="ab029e3f210b40f3fded64fec2a27a02" args="(lbm_umm_info_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_set_umm_info           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlbm__umm__info__t__stct.html">lbm_umm_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
In order to be effective, this function *must* be called before any other LBM API function.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#bcb0f0efe7b2a8162b328ba401b06ee3" title="Structure for specifying UMM daemon connection options.">lbm_umm_info_t</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>lbm_umm_info_t struct specifying options for connecting to a UMM daemon. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="73298f53aa9c5572cd0b1e68a4ec435a"></a><!-- doxytag: member="lbm.h::lbm_src_channel_create" ref="73298f53aa9c5572cd0b1e68a4ec435a" args="(lbm_src_channel_info_t **chnp, lbm_src_t *src, lbm_uint32_t channel_num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_channel_create           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_channel_info_t **&nbsp;</td>
          <td class="paramname"> <em>chnp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_uint32_t&nbsp;</td>
          <td class="paramname"> <em>channel_num</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chnp</em>&nbsp;</td><td>A pointer to a pointer to a UM channel info object. Will be filled in by this function to point to the newly created lbm_src_channel_info_t object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to the UM source the channel info object will be used with. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channel_num</em>&nbsp;</td><td>A channel number in the range 0-4294967295 </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#091b5806bf18d10ebd0d9117e0c70229" title="Extended send of a message to the topic associated with a UM source.">lbm_src_send_ex</a> <a class="el" href="lbm_8h.html#4d883eaaa22baf81abf21d495f471c8b" title="Extended send of a set of messages to the topic associated with a UM source.">lbm_src_sendv_ex</a> </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="d49d9550c5927c8633f11461b9f60104"></a><!-- doxytag: member="lbm.h::lbm_src_channel_delete" ref="d49d9550c5927c8633f11461b9f60104" args="(lbm_src_channel_info_t *chn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_channel_delete           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_channel_info_t *&nbsp;</td>
          <td class="paramname"> <em>chn</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chn</em>&nbsp;</td><td>A pointer to a channel info object allocated with lbm_src_channel_create. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="b8dd76271bf9df7a5f88476d431f523e"></a><!-- doxytag: member="lbm.h::lbm_src_create" ref="b8dd76271bf9df7a5f88476d431f523e" args="(lbm_src_t **srcp, lbm_context_t *ctx, lbm_topic_t *topic, lbm_src_cb_proc proc, void *clientd, lbm_event_queue_t *evq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_create           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t **&nbsp;</td>
          <td class="paramname"> <em>srcp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_topic_t *&nbsp;</td>
          <td class="paramname"> <em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lbm_8h.html#7503c005ce424fa049494e37b708d396">lbm_src_cb_proc</a>&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>clientd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from a context thread callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>srcp</em>&nbsp;</td><td>A pointer to a pointer to a UM source object. Will be filled in by this function to point to the newly created lbm_src_t object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the UM context object associated with the sender. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>topic</em>&nbsp;</td><td>Pointer to the UM topic object associated with the destination of messages sent by the source. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>Pointer to a function to call when events occur related to the source. If NULL, then events are not delivered to the source. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Pointer to client data that is passed when <em>proc</em> is called. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>Optional Event Queue to place events on when they occur. If NULL causes <em>proc</em> to be called from context thread. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="29d45db8f76835b4ae78f4568c25712f"></a><!-- doxytag: member="lbm.h::lbm_src_delete" ref="29d45db8f76835b4ae78f4568c25712f" args="(lbm_src_t *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_delete           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete a UM source object. Note that this function can return while the source callback may still be executing if source events are being delivered via an event queue. If the application needs to know when all possible processing on the source is complete, it must use <a class="el" href="lbm_8h.html#a714727708c894e3cfcf9c41c265c986" title="Extended delete a UM source object.">lbm_src_delete_ex()</a>.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from a context thread callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to a UM source object to delete. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a714727708c894e3cfcf9c41c265c986"></a><!-- doxytag: member="lbm.h::lbm_src_delete_ex" ref="a714727708c894e3cfcf9c41c265c986" args="(lbm_src_t *src, lbm_event_queue_cancel_cb_info_t *cbinfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_delete_ex           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__event__queue__cancel__cb__info__t__stct.html">lbm_event_queue_cancel_cb_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cbinfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete a UM source object with an application callback indicating when the source is fully canceled. This extended version of the source delete function requires the configuration option queue_cancellation_callbacks_enabled be set to 1.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from a context thread callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to a UM source object to delete. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbinfo</em>&nbsp;</td><td>Cancellation callback information, containing the event queue, function pointer, and client data for the callback. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fec0ee6822fe721f21c67536660506ea"></a><!-- doxytag: member="lbm.h::lbm_src_flush" ref="fec0ee6822fe721f21c67536660506ea" args="(lbm_src_t *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_flush           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Calling this function from a context thread callback for stability and confirmation events could cause a deadlock </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to the UM source to send from </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure or 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="82b9908731d8ac4a77c00afe55f15784"></a><!-- doxytag: member="lbm.h::lbm_src_get_inflight" ref="82b9908731d8ac4a77c00afe55f15784" args="(lbm_src_t *src, int type, int *inflight, lbm_flight_size_set_inflight_cb_proc proc, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_get_inflight           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>inflight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lbm_8h.html#c26b2f61ff3e92ff1e1b44f82bbf193b">lbm_flight_size_set_inflight_cb_proc</a>&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>clientd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#c26b2f61ff3e92ff1e1b44f82bbf193b" title="Application callback for lbm_*_flight_size_set_inflight().">lbm_flight_size_set_inflight_cb_proc</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to the source. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Type of flight size. <ul>
<li><code>LBM_FLIGHT_SIZE_TYPE_UME</code> - Specifies a UM flight size </li>
<li><code>LBM_FLIGHT_SIZE_TYPE_ULB</code> - Specifies a ULB flight size </li>
<li><code>LBM_FLIGHT_SIZE_TYPE_UMQ</code> - Specifies a UMQ flight size </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inflight</em>&nbsp;</td><td>Pointer to an int whose value will be filled in to reflect the current inflight. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>Optional callback that allows an application to set the current inflight. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Optional client data passed into the proc. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success, -1 for failure if the proc returns a negative value. </dd></dl>

</div>
</div><p>
<a class="anchor" name="93d620242351c5fd60f270030302562d"></a><!-- doxytag: member="lbm.h::lbm_src_get_inflight_ex" ref="93d620242351c5fd60f270030302562d" args="(lbm_src_t *src, int type, lbm_flight_size_inflight_t *inflight, lbm_flight_size_set_inflight_ex_cb_proc proc, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_get_inflight_ex           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__flight__size__inflight__t__stct.html">lbm_flight_size_inflight_t</a> *&nbsp;</td>
          <td class="paramname"> <em>inflight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lbm_8h.html#75319e63d9fa4e0f006918b91672f6b5">lbm_flight_size_set_inflight_ex_cb_proc</a>&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>clientd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#c26b2f61ff3e92ff1e1b44f82bbf193b" title="Application callback for lbm_*_flight_size_set_inflight().">lbm_flight_size_set_inflight_cb_proc</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to the source. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Type of flight size. <ul>
<li><code>LBM_FLIGHT_SIZE_TYPE_UME</code> - Specifies a UM flight size </li>
<li><code>LBM_FLIGHT_SIZE_TYPE_ULB</code> - Specifies a ULB flight size </li>
<li><code>LBM_FLIGHT_SIZE_TYPE_UMQ</code> - Specifies a UMQ flight size </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inflight</em>&nbsp;</td><td>Pointer to a structure to be filled in with the current inflight values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>Optional callback that allows an application to set the current inflight. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Optional client data passed into the proc. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success, -1 for failure if the proc returns a negative value. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6cd6a5f1384b97fca390c711d1261ed5"></a><!-- doxytag: member="lbm.h::lbm_src_getopt" ref="6cd6a5f1384b97fca390c711d1261ed5" args="(lbm_src_t *src, const char *optname, void *optval, size_t *optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_getopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to a UM source object where the option is stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the option value structure. The structure of the option values are specific to the options themselves. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>When passed, this is the max length (in bytes) of the <em>optval</em> structure. When returned, this is the length of the filled in <em>optval</em> structure. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ea2efde8ec7b0bc2e5bf81b9fdecfb1c"></a><!-- doxytag: member="lbm.h::lbm_src_reset_transport_stats" ref="ea2efde8ec7b0bc2e5bf81b9fdecfb1c" args="(lbm_src_t *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_reset_transport_stats           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to the UM source to reset statistics for. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure and 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="976eeac5bd741e2c320a1f341a22af1a"></a><!-- doxytag: member="lbm.h::lbm_src_retrieve_transport_stats" ref="976eeac5bd741e2c320a1f341a22af1a" args="(lbm_src_t *src, lbm_src_transport_stats_t *stats)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_retrieve_transport_stats           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__src__transport__stats__t__stct.html">lbm_src_transport_stats_t</a> *&nbsp;</td>
          <td class="paramname"> <em>stats</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to the UM source to retrieve statistics for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stats</em>&nbsp;</td><td>Pointer to a stats structure to fill in. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure and 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="91f4b9cb04fe1323ec56833211cc5cb7"></a><!-- doxytag: member="lbm.h::lbm_src_send" ref="91f4b9cb04fe1323ec56833211cc5cb7" args="(lbm_src_t *src, const char *msg, size_t len, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_send           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not recommended to call this function from a context thread callback. If called from a context thread callback, use the LBM_SRC_NONBLOCK flag and handle any LBM_EWOULDBLOCK errors internally. <p>
Calling this function from a context thread callback for stability and confirmation events could cause a deadlock. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to the UM source to send from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Pointer to the data to send in this message </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Length (in bytes) of the data to send in this message </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags indicating various conditions. ORed set of values. <ul>
<li><code>LBM_MSG_START_BATCH</code> - Message starts a batch of messages </li>
<li><code>LBM_MSG_END_BATCH</code> - Message ends a batch of messages. Batch should be sent to the implicit batching buffer. </li>
<li><code>LBM_MSG_COMPLETE_BATCH</code> - Message constitutes a complete batch and should be sent to the implicit batching buffer. </li>
<li><code>LBM_MSG_FLUSH</code> - Message is to be sent ASAP (not implicitly or explicitly batched). This also flushes waiting messages that were explicitly or implicitly batched. </li>
<li><code>LBM_SRC_NONBLOCK</code> - If message could not be sent immediately return and error and signal LBM_EWOULDBLOCK. </li>
<li><code>LBM_SRC_BLOCK</code> - Block the caller indefinitely until the message is sent. (This behavior is the default if neither LBM_SRC_NONBLOCK nor LBM_SRC_BLOCK are supplied.) </li>
</ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure or 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="091b5806bf18d10ebd0d9117e0c70229"></a><!-- doxytag: member="lbm.h::lbm_src_send_ex" ref="091b5806bf18d10ebd0d9117e0c70229" args="(lbm_src_t *src, const char *msg, size_t len, int flags, lbm_src_send_ex_info_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_send_ex           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__src__send__ex__info__t__stct.html">lbm_src_send_ex_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>If called from a context thread callback, use the LBM_SRC_NONBLOCK flag and handle any LBM_EWOULDBLOCK errors internally. <p>
Calling this function from a context thread callback for stability and confirmation events could cause a deadlock </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to the UM source to send from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg</em>&nbsp;</td><td>Pointer to the data to send in this message </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Length (in bytes) of the data to send in this message </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags indicating various conditions. ORed set of values. <ul>
<li><code>LBM_MSG_START_BATCH</code> - Message starts a batch of messages </li>
<li><code>LBM_MSG_END_BATCH</code> - Message ends a batch of messages. Batch should be sent to the implicit batching buffer. </li>
<li><code>LBM_MSG_COMPLETE_BATCH</code> - Message constitutes a complete batch and should be sent to the implicit batching buffer. </li>
<li><code>LBM_MSG_FLUSH</code> - Message is to be sent ASAP (not implicitly or explicitly batched). This also flushes waiting messages that were explicitly or implicitly batched. </li>
<li><code>LBM_SRC_NONBLOCK</code> - If message could not be sent immediately return and error and signal LBM_EWOULDBLOCK. </li>
<li><code>LBM_SRC_BLOCK</code> - Block the caller indefinitely until the message is sent. (This behavior is the default if neither LBM_SRC_NONBLOCK nor LBM_SRC_BLOCK are supplied.) </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>Pointer to lbm_src_send_ex_info_t options </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure or 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f28189e64ef0ee10d3444e418443aaa9"></a><!-- doxytag: member="lbm.h::lbm_src_sendv" ref="f28189e64ef0ee10d3444e418443aaa9" args="(lbm_src_t *src, const lbm_iovec_t *iov, int num, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_sendv           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlbm__iovec__t__stct.html">lbm_iovec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The messages are specified as an array of iovecs. Be aware that each iovec element is considered as a full application message unless LBM_MSG_IOV_GATHER is used in the flags field. In that case, the elements of the array are gathered together into a single message.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not recommended to call this function from a context thread callback. If called from a context thread callback, use the LBM_SRC_NONBLOCK flag and handle any LBM_EWOULDBLOCK errors internally. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to the UM source to send from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iov</em>&nbsp;</td><td>Pointer to an array of iovecs that hold message information. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>Number of elements of the iov array to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags indicating various conditions. ORed set of values. <ul>
<li><code>LBM_MSG_START_BATCH</code> - Messages start a batch of messages </li>
<li><code>LBM_MSG_END_BATCH</code> - Messages end a batch of messages. Batch should be sent to the implicit batching buffer. </li>
<li><code>LBM_MSG_COMPLETE_BATCH</code> - Messages constitute a complete batch and should be sent to the implicit batching buffer. </li>
<li><code>LBM_MSG_FLUSH</code> - Messages are to be sent ASAP (not implicitly batched or explicitly batched). </li>
<li><code>LBM_SRC_NONBLOCK</code> - If messages could not be sent immediately return and error and signal LBM_EWOULDBLOCK. </li>
<li><code>LBM_SRC_BLOCK</code> - Block the caller indefinitely until the messages are all sent. (This behavior is the default if neither LBM_SRC_NONBLOCK nor LBM_SRC_BLOCK are supplied.) </li>
<li><code>LBM_MSG_IOV_GATHER</code> - iovec elements should be gather into a single message. </li>
</ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure or 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4d883eaaa22baf81abf21d495f471c8b"></a><!-- doxytag: member="lbm.h::lbm_src_sendv_ex" ref="4d883eaaa22baf81abf21d495f471c8b" args="(lbm_src_t *src, const lbm_iovec_t *iov, int num, int flags, lbm_src_send_ex_info_t *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_sendv_ex           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlbm__iovec__t__stct.html">lbm_iovec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__src__send__ex__info__t__stct.html">lbm_src_send_ex_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The messages are specified as an array of iovecs. The elements of the array are gathered together into a single message.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>If called from a context thread callback, use the LBM_SRC_NONBLOCK flag and handle any LBM_EWOULDBLOCK errors internally. <p>
Calling this function from a context thread callback for stability and confirmation events could cause a deadlock </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to the UM source to send from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iov</em>&nbsp;</td><td>Pointer to an array of iovecs that hold message information. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>Number of elements of the iov array to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags indicating various conditions. ORed set of values. <ul>
<li><code>LBM_MSG_START_BATCH</code> - Message starts a batch of messages </li>
<li><code>LBM_MSG_END_BATCH</code> - Message ends a batch of messages. Batch should be sent to the implicit batching buffer. </li>
<li><code>LBM_MSG_COMPLETE_BATCH</code> - Message constitutes a complete batch and should be sent to the implicit batching buffer. </li>
<li><code>LBM_MSG_FLUSH</code> - Message is to be sent ASAP (not implicitly or explicitly batched). This also flushes waiting messages that were explicitly or implicitly batched. </li>
<li><code>LBM_SRC_NONBLOCK</code> - If message could not be sent immediately return and error and signal LBM_EWOULDBLOCK. </li>
<li><code>LBM_SRC_BLOCK</code> - Block the caller indefinitely until the message is sent. (This behavior is the default if neither LBM_SRC_NONBLOCK nor LBM_SRC_BLOCK are supplied.) </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>Pointer to lbm_src_send_ex_info_t options </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure or 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="561190e0b26353f112b3bcb499c057f7"></a><!-- doxytag: member="lbm.h::lbm_src_setopt" ref="561190e0b26353f112b3bcb499c057f7" args="(lbm_src_t *src, const char *optname, const void *optval, size_t optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_setopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Only those options that can be set during operation may be specified. See "Options That May Be Set During Operation" (doc/Config/maybesetduringoperation.html) in The UM Configuration Guide. For API functions that can access any option, see lbm_src_topic_attr_*(). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to a UM source object where the option is to be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the option value structure. The structure of the option values are specific to the options themselves. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>Length (in bytes) of the <em>optval</em> structure. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bd4b0baffdf68ba0f0e2cb006fa9b0b4"></a><!-- doxytag: member="lbm.h::lbm_src_str_getopt" ref="bd4b0baffdf68ba0f0e2cb006fa9b0b4" args="(lbm_src_t *src, const char *optname, char *optval, size_t *optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_str_getopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to a UM source object where the option is stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>String to be filled in with the option value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>When passed, this is the max length (in bytes) of the string. When returned, this is the length of the filled in option value. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4f78f4100b2a9c80ea90b60bdebe5176"></a><!-- doxytag: member="lbm.h::lbm_src_str_setopt" ref="4f78f4100b2a9c80ea90b60bdebe5176" args="(lbm_src_t *src, const char *optname, const char *optval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_str_setopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Only those options that can be set during operation may be specified. See "Options That May Be Set During Operation" (doc/Config/maybesetduringoperation.html) in The UM Configuration Guide. For API functions that can access any option, see lbm_src_topic_attr_*(). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to a UM source object where the option is to be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>String containing the option value. The format of the string is specific to the options themselves. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1ba60407fa2bde0997aab6d5a5d2da1a"></a><!-- doxytag: member="lbm.h::lbm_src_topic_alloc" ref="1ba60407fa2bde0997aab6d5a5d2da1a" args="(lbm_topic_t **topicp, lbm_context_t *ctx, const char *symbol, const lbm_src_topic_attr_t *attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_topic_alloc           </td>
          <td>(</td>
          <td class="paramtype">lbm_topic_t **&nbsp;</td>
          <td class="paramname"> <em>topicp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lbm_src_topic_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from a context thread callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>topicp</em>&nbsp;</td><td>A pointer to a pointer to a UM topic object. Will be filled in by this function to point to the newly created lbm_topic_t object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Context object for Topic </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>symbol</em>&nbsp;</td><td>The Topic string. Topic strings should be limited in length to 246 characters (not including the final null). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a Src Topic attribute object for passing in options </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d6ed0c9ec2565764a31f2db09a0e43c3"></a><!-- doxytag: member="lbm.h::lbm_src_topic_attr_create" ref="d6ed0c9ec2565764a31f2db09a0e43c3" args="(lbm_src_topic_attr_t **attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_topic_attr_create           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_topic_attr_t **&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is filled with the current default values that are used by lbm_topic_t objects that concern sources and may have been modified by a previously loaded configuration file.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a pointer to a UM source topic attribute structure. Will be filled in by this function to point to the newly created lbm_src_topic_attr_t object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c299cf26605e18261b812a43012b1c24"></a><!-- doxytag: member="lbm.h::lbm_src_topic_attr_create_default" ref="c299cf26605e18261b812a43012b1c24" args="(lbm_src_topic_attr_t **attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_topic_attr_create_default           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_topic_attr_t **&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is allocated and filled with the initial or factory default values built into LBM that are used by lbm_topic_t objects that concern sources.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a pointer to a UM source topic attribute structure. Will be filled in by this function to point to the newly created lbm_src_topic_attr_t object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="dc12814cac6280b5bd48bfde41d7c88a"></a><!-- doxytag: member="lbm.h::lbm_src_topic_attr_create_from_xml" ref="dc12814cac6280b5bd48bfde41d7c88a" args="(lbm_src_topic_attr_t **attr, const char *context_name, const char *topicname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_topic_attr_create_from_xml           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_topic_attr_t **&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>context_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>topicname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is allocated and filled with the current default values that are used by lbm_topic_t objects that concern sources and may have been modified by a previously loaded configuration file. If an XML configuration file has been loaded, the attribute object is further filled with the defaults for the given context name and source topic name. If the context name or source topic name are not permitted by the XML configuration, -1 is returned and no attribute object is created.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a pointer to a UM source topic attribute structure. Will be filled in by this function to point to the newly created lbm_src_topic_attr_t object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>context_name</em>&nbsp;</td><td>The context name used to lookup the source topic in the XML configuration. A NULL value is permitted, and will match unnamed contexts defined in the XML. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>topicname</em>&nbsp;</td><td>The topic name used to lookup the source topic in the XML configuration. A NULL value is *not* permitted and will result in an error. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cb24cc75476206c155b00c4994aece85"></a><!-- doxytag: member="lbm.h::lbm_src_topic_attr_delete" ref="cb24cc75476206c155b00c4994aece85" args="(lbm_src_topic_attr_t *attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_topic_attr_delete           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_topic_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is cleaned up and deleted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM source topic attribute object as returned by <a class="el" href="lbm_8h.html#d6ed0c9ec2565764a31f2db09a0e43c3" title="Create and fill a UM source topic attribute object with the current default values...">lbm_src_topic_attr_create</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1d7722b39132940193205d6287c0a7f7"></a><!-- doxytag: member="lbm.h::lbm_src_topic_attr_dump" ref="1d7722b39132940193205d6287c0a7f7" args="(lbm_src_topic_attr_t *sattr, int *size, lbm_config_option_t *opts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_topic_attr_dump           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_topic_attr_t *&nbsp;</td>
          <td class="paramname"> <em>sattr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_config_option_t *&nbsp;</td>
          <td class="paramname"> <em>opts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The config object is filled with source topic configuration options <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source topic attribute object to retrieve the attributes from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the opts array. Will return the number of items that were set in opts </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opts</em>&nbsp;</td><td>The options array to fill </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c91185a9190cfe07d9ac247ed3be8379"></a><!-- doxytag: member="lbm.h::lbm_src_topic_attr_dup" ref="c91185a9190cfe07d9ac247ed3be8379" args="(lbm_src_topic_attr_t **attr, const lbm_src_topic_attr_t *original)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_topic_attr_dup           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_topic_attr_t **&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lbm_src_topic_attr_t *&nbsp;</td>
          <td class="paramname"> <em>original</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A new attribute object is created as a copy of an existing object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a pointer to a UM source topic attribute structure. Will be filled in by this function to point to the newly created lbm_src_topic_attr_t object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>original</em>&nbsp;</td><td>Pointer to a UM source topic attribute object as returned by <a class="el" href="lbm_8h.html#d6ed0c9ec2565764a31f2db09a0e43c3" title="Create and fill a UM source topic attribute object with the current default values...">lbm_src_topic_attr_create</a> or <a class="el" href="lbm_8h.html#c299cf26605e18261b812a43012b1c24" title="Create and fill a UM source topic attribute object with the initial default values...">lbm_src_topic_attr_create_default</a>, from which <em>attr</em> is initialized. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="434a1c5f20dc79c81a2df6d8fa47859f"></a><!-- doxytag: member="lbm.h::lbm_src_topic_attr_getopt" ref="434a1c5f20dc79c81a2df6d8fa47859f" args="(lbm_src_topic_attr_t *attr, const char *optname, void *optval, size_t *optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_topic_attr_getopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_topic_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM source topic attribute object where the option is stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the option value structure. The structure of the option values are specific to the options themselves. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>When passed, this is the max length (in bytes) of the <em>optval</em> structure. When returned, this is the length of the filled in <em>optval</em> structure. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9166df450621e271b833e0727a0fca0e"></a><!-- doxytag: member="lbm.h::lbm_src_topic_attr_option_size" ref="9166df450621e271b833e0727a0fca0e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_topic_attr_option_size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function returns the number of entries that are of type "topic"<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of entries that are of type "topic" </dd></dl>

</div>
</div><p>
<a class="anchor" name="c69fa2e963794dfea2dd2553d43053d4"></a><!-- doxytag: member="lbm.h::lbm_src_topic_attr_set_from_xml" ref="c69fa2e963794dfea2dd2553d43053d4" args="(lbm_src_topic_attr_t *attr, const char *context_name, const char *topicname)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_topic_attr_set_from_xml           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_topic_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>context_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>topicname</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is filled with the defaults for the given context name and source topic name, if an XML configuration file has been loaded. If the context name or source topic name are not permitted by the XML configuration, -1 is returned and the attribute object is not written to.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a UM source topic attribute structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>context_name</em>&nbsp;</td><td>The context name used to lookup the source topic in the XML configuration. A NULL value is permitted, and will match unnamed contexts defined in the XML. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>topicname</em>&nbsp;</td><td>The topic name used to lookup the source topic in the XML configuration. A NULL value is *not* permitted and will result in an error. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="96ea052dce2e6376684cbf2003407cbf"></a><!-- doxytag: member="lbm.h::lbm_src_topic_attr_setopt" ref="96ea052dce2e6376684cbf2003407cbf" args="(lbm_src_topic_attr_t *attr, const char *optname, const void *optval, size_t optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_topic_attr_setopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_topic_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used before the topic is allocated and the source created. NOTE: the attribute object must first be initialized with the corresponding _attr_create() function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM source topic attribute object where the option is to be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the option value structure. The structure of the option values are specific to the options themselves. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>Length (in bytes) of the <em>optval</em> structure. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="38757fa8dda179e00b62d3e8029391c4"></a><!-- doxytag: member="lbm.h::lbm_src_topic_attr_str_getopt" ref="38757fa8dda179e00b62d3e8029391c4" args="(lbm_src_topic_attr_t *attr, const char *optname, char *optval, size_t *optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_topic_attr_str_getopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_topic_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM source topic attribute object where the option is stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>String to be filled in with the option value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>When passed, this is the max length (in bytes) of the string. When returned, this is the length of the filled in option value. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="422f330bf7ef3efdd7a9f17caabccb24"></a><!-- doxytag: member="lbm.h::lbm_src_topic_attr_str_setopt" ref="422f330bf7ef3efdd7a9f17caabccb24" args="(lbm_src_topic_attr_t *attr, const char *optname, const char *optval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_topic_attr_str_setopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_topic_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used before the topic is allocated and the source created. NOTE: the attribute object must first be initialized with the corresponding _attr_create() function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM source topic attribute object where the option is to be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>String containing the option value. The format of the string is specific to the options themselves. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="33d3ee1d815f4a51b68653d8a063f87f"></a><!-- doxytag: member="lbm.h::lbm_src_topic_dump" ref="33d3ee1d815f4a51b68653d8a063f87f" args="(lbm_src_t *src, int *size, lbm_config_option_t *opts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_topic_dump           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_config_option_t *&nbsp;</td>
          <td class="paramname"> <em>opts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The config object is filled with source topic configuration options <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>The source object to retrieve the attributes from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the opts array. Will return the number of items that were set in opts </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opts</em>&nbsp;</td><td>The options array to fill </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3a89366ab4e36dfa362e20397778d04a"></a><!-- doxytag: member="lbm.h::lbm_src_ume_deregister" ref="3a89366ab4e36dfa362e20397778d04a" args="(lbm_src_t *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_src_ume_deregister           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function causes a UMP deregistration to be sent to all stores the source is currently registered to, and disallows any future registrations from taking place.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to a UM source object </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7b90c3d7df0e7833af4136e584439b90"></a><!-- doxytag: member="lbm.h::lbm_topic_from_src" ref="7b90c3d7df0e7833af4136e584439b90" args="(lbm_src_t *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL lbm_topic_t* lbm_topic_from_src           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to a UM source object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the UM topic object associated with the UM source object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fa35ad2c7d5d473ffeda6727022f9b94"></a><!-- doxytag: member="lbm.h::lbm_transport_source_format" ref="fa35ad2c7d5d473ffeda6727022f9b94" args="(const lbm_transport_source_info_t *info, size_t infosize, char *source, size_t *size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_transport_source_format           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlbm__transport__source__info__t__stct.html">lbm_transport_source_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>infosize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>Pointer to a transport source info structure containing the transport source components. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>infosize</em>&nbsp;</td><td>Size (in bytes) of <em>info</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>Pointer to a buffer to receive the formatted transport source string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of <em>source</em> in bytes. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for success, -1 for failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="30bf33dce2021f6ea8915b45f511af56"></a><!-- doxytag: member="lbm.h::lbm_transport_source_parse" ref="30bf33dce2021f6ea8915b45f511af56" args="(const char *source, lbm_transport_source_info_t *info, size_t infosize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_transport_source_parse           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__transport__source__info__t__stct.html">lbm_transport_source_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>infosize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>Source string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>Pointer to a transport source info structure into which the components are parsed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>infosize</em>&nbsp;</td><td>Size (in bytes) of <em>info</em>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for success, -1 for failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5c2b4c56240b15dadd9a251989c3180f"></a><!-- doxytag: member="lbm.h::lbm_ume_ack_delete" ref="5c2b4c56240b15dadd9a251989c3180f" args="(lbm_ume_rcv_ack_t *ack)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_ume_ack_delete           </td>
          <td>(</td>
          <td class="paramtype">lbm_ume_rcv_ack_t *&nbsp;</td>
          <td class="paramname"> <em>ack</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#e1b7ca376c99fcbbe6175ad3441b7aeb" title="Retrieves the ack structure from a UMP message.">lbm_msg_extract_ume_ack</a>. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ack</em>&nbsp;</td><td>Pointer to the ack structure to be deleted. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success, -1 for failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2b5aa9394b4911eb8e39768a57d5b49e"></a><!-- doxytag: member="lbm.h::lbm_ume_ack_send_explicit_ack" ref="2b5aa9394b4911eb8e39768a57d5b49e" args="(lbm_ume_rcv_ack_t *ack, lbm_uint_t sqn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_ume_ack_send_explicit_ack           </td>
          <td>(</td>
          <td class="paramtype">lbm_ume_rcv_ack_t *&nbsp;</td>
          <td class="paramname"> <em>ack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_uint_t&nbsp;</td>
          <td class="paramname"> <em>sqn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#e1b7ca376c99fcbbe6175ad3441b7aeb" title="Retrieves the ack structure from a UMP message.">lbm_msg_extract_ume_ack</a>. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ack</em>&nbsp;</td><td>Pointer to the previously extracted ack structure of a message on the same stream that is currently being explicitly acked. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sqn</em>&nbsp;</td><td>The sequence number up to which to send the explicit ack. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0f398a9c65bcb133539b40dacfb5d619"></a><!-- doxytag: member="lbm.h::lbm_ume_src_msg_stable" ref="0f398a9c65bcb133539b40dacfb5d619" args="(lbm_src_t *src, lbm_uint32_t sqn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_ume_src_msg_stable           </td>
          <td>(</td>
          <td class="paramtype">lbm_src_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_uint32_t&nbsp;</td>
          <td class="paramname"> <em>sqn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to the source. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sqn</em>&nbsp;</td><td>Sqn of the fragment to mark stable. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success, -1 for failure if sqn is not found or sqn is already stable </dd></dl>

</div>
</div><p>
<a class="anchor" name="6cd0c297e489e006ef5da83398184daa"></a><!-- doxytag: member="lbm.h::lbm_umq_ctx_msg_stable" ref="6cd0c297e489e006ef5da83398184daa" args="(lbm_context_t *ctx, const char *qname, lbm_umq_msgid_t *msg_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_umq_ctx_msg_stable           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>qname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__umq__msgid__t__stct.html">lbm_umq_msgid_t</a> *&nbsp;</td>
          <td class="paramname"> <em>msg_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the context. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>qname</em>&nbsp;</td><td>Name of the queue. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg_id</em>&nbsp;</td><td>Msg_id of the message to mark stable. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success, -1 for failure if msg_id is not found or msg_id is already stable </dd></dl>

</div>
</div><p>
<a class="anchor" name="83556cf6d952f5c68c1765ca2b70f126"></a><!-- doxytag: member="lbm.h::lbm_umq_msg_selector_create" ref="83556cf6d952f5c68c1765ca2b70f126" args="(lbm_umq_msg_selector_t **selector, char *str, lbm_uint16_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_umq_msg_selector_create           </td>
          <td>(</td>
          <td class="paramtype">lbm_umq_msg_selector_t **&nbsp;</td>
          <td class="paramname"> <em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_uint16_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>selector</em>&nbsp;</td><td>Pointer to a pointer to an lbm_umq_msg_selector_t structure to be filled in </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>Pointer to the charactor string of the message selector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Length of the above charactor string. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the length of message selector string for Success and negative values for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9fd1730634c12b16a435ddaa5dd2923c"></a><!-- doxytag: member="lbm.h::lbm_umq_msg_selector_delete" ref="9fd1730634c12b16a435ddaa5dd2923c" args="(lbm_umq_msg_selector_t *selector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_umq_msg_selector_delete           </td>
          <td>(</td>
          <td class="paramtype">lbm_umq_msg_selector_t *&nbsp;</td>
          <td class="paramname"> <em>selector</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>selector</em>&nbsp;</td><td>Pointer to lbm_umq_msg_selector_t object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="497d77b133cea1547c3346fcba99872a"></a><!-- doxytag: member="lbm.h::lbm_unicast_immediate_message" ref="497d77b133cea1547c3346fcba99872a" args="(lbm_context_t *ctx, const char *target, const char *topic, const char *data, size_t len, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_unicast_immediate_message           </td>
          <td>(</td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to UM context to send from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>Target address of the receiver of the form "TCP:ip:port" </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>topic</em>&nbsp;</td><td>Topic name to send message to or NULL for non-topic. Topic names should be limited to 246 characters (not including the final null). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Pointer to the data to send in this message </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Length (in bytes) of the data to send in this message. Unicast immediate messages must be 65281 bytes or less in length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags indicating various conditions. ORed set of values. <ul>
<li><code>LBM_SRC_NONBLOCK</code> - If message could not be sent immediately return and error and signal LBM_EWOULDBLOCK. </li>
<li><code>LBM_SRC_BLOCK</code> - Block the caller indefinitely until the message is sent. (This behavior is the default if neither LBM_SRC_NONBLOCK nor LBM_SRC_BLOCK are supplied.) </li>
</ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>-1 for Failure or 0 for Success. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e011c7a66e1db1f012d7f9633dbd321d"></a><!-- doxytag: member="lbm.h::lbm_unicast_immediate_request" ref="e011c7a66e1db1f012d7f9633dbd321d" args="(lbm_request_t **reqp, lbm_context_t *ctx, const char *target, const char *topic, const char *data, size_t len, lbm_request_cb_proc proc, void *clientd, lbm_event_queue_t *evq, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_unicast_immediate_request           </td>
          <td>(</td>
          <td class="paramtype">lbm_request_t **&nbsp;</td>
          <td class="paramname"> <em>reqp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lbm_8h.html#f3ef4385bc929e8a7ff94acbeb1eef75">lbm_request_cb_proc</a>&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>clientd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reqp</em>&nbsp;</td><td>A pointer to a pointer for the lbm_request_t object created to be stored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to UM context to send from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>Target address of the receiver of the form "TCP:ip:port" </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>topic</em>&nbsp;</td><td>Topic name to send message to or NULL for non-topic. Topic names should be limited to 246 characters (not including the final null). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Buffer to be included as data in the request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Length (in bytes) of the data to send in this message. Unicast immediate messages must be 65281 bytes or less in length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>Pointer to function to call when responses come in for this request. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Client data returned in the callback proc <em>proc</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>optional Event Queue to place message events on when they occur. If NULL causes <em>proc</em> to be called from context thread. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags used to instruct UM how to handle this message. See <em>lbm_unicast_immediate_message</em> for more information. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ed1a3a43104b67af66a8f3513f8f2a75"></a><!-- doxytag: member="lbm.h::lbm_version" ref="ed1a3a43104b67af66a8f3513f8f2a75" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL const char* lbm_version           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>String containing version information for UM. </dd></dl>

</div>
</div><p>
<a class="anchor" name="504d418c5f1ad66627eb55ba0f937110"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_attr_create" ref="504d418c5f1ad66627eb55ba0f937110" args="(lbm_wildcard_rcv_attr_t **attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_attr_create           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_attr_t **&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is allocated and filled with the current default values that are used by lbm_wildcard_rcv_t objects and may have been modified by a previously loaded configuration file.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a pointer to a UM wildcard receiver attribute structure. Will be filled in by this function to point to the newly created lbm_wildcard_rcv_attr_t object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5ebb6c37e8e27a5338bc786f10c05007"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_attr_create_default" ref="5ebb6c37e8e27a5338bc786f10c05007" args="(lbm_wildcard_rcv_attr_t **attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_attr_create_default           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_attr_t **&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is allocated and filled with the initial or factory default values built into LBM that are used by lbm_wildcard_rcv_t.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a pointer to a UM wildcard receiver attribute structure. Will be filled in by this function to point to the newly created lbm_wildcard_rcv_attr_t object. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="12eccde60884c35ac72b772be2aea747"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_attr_create_from_xml" ref="12eccde60884c35ac72b772be2aea747" args="(lbm_wildcard_rcv_attr_t **attr, const char *context_name, const char *pattern, int pattern_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_attr_create_from_xml           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_attr_t **&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>context_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pattern_type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is allocated and filled with the current default values that are used by lbm_topic_t objects that concern receivers and may have been modified by a previously loaded configuration file. If an XML configuration file has been loaded, the attribute object is further filled with the defaults for the given context name and wildcard receiver pattern. If the context name or wildcard receiver pattern are not permitted by the XML configuration, -1 is returned and no attribute object is created.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a pointer to a UM wildcard receiver attribute structure. Will be filled in by this function to point to the newly created lbm_wildcard_rcv_attr_t object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>context_name</em>&nbsp;</td><td>The context name used to lookup the wildcard receiver pattern in the XML configuration. A NULL value is permitted, and will match unnamed contexts defined in the XML. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pattern</em>&nbsp;</td><td>The pattern used to lookup the wildcard receiver in the XML configuration. A NULL value is *not* permitted and will result in an error. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pattern_type</em>&nbsp;</td><td>They type of pattern. Both pattern_type and pattern must match in XML configuration. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e9ec474237895a81cf15a4e14619cd25"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_attr_delete" ref="e9ec474237895a81cf15a4e14619cd25" args="(lbm_wildcard_rcv_attr_t *attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_attr_delete           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is cleaned up and deleted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM wildcard receiver attribute object as returned by <a class="el" href="lbm_8h.html#504d418c5f1ad66627eb55ba0f937110" title="Create and fill a UM wildcard receiver attribute object with the current default...">lbm_wildcard_rcv_attr_create</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="98dc9a9c6e5bfcf72222754f5179298d"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_attr_dump" ref="98dc9a9c6e5bfcf72222754f5179298d" args="(lbm_wildcard_rcv_attr_t *wattr, int *size, lbm_config_option_t *opts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_attr_dump           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_attr_t *&nbsp;</td>
          <td class="paramname"> <em>wattr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_config_option_t *&nbsp;</td>
          <td class="paramname"> <em>opts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The config object is filled with wildcard receiver configuration options <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wattr</em>&nbsp;</td><td>The wildcard receiver attribute object to retrieve the attributes from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the opts array. Will return the number of items that were set in opts </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opts</em>&nbsp;</td><td>The options array to fill </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="87d4a547903b1743bbc29ea52b3f02ac"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_attr_dup" ref="87d4a547903b1743bbc29ea52b3f02ac" args="(lbm_wildcard_rcv_attr_t **attr, const lbm_wildcard_rcv_attr_t *original)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_attr_dup           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_attr_t **&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lbm_wildcard_rcv_attr_t *&nbsp;</td>
          <td class="paramname"> <em>original</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A new attribute object is created as a copy of an existing object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a pointer to a UM wildcard receiver attribute structure. Will be filled in by this function to point to the newly created lbm_wildcard_rcv_attr_t object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>original</em>&nbsp;</td><td>Pointer to a UM wildcard receiver attribute object as returned by <a class="el" href="lbm_8h.html#504d418c5f1ad66627eb55ba0f937110" title="Create and fill a UM wildcard receiver attribute object with the current default...">lbm_wildcard_rcv_attr_create</a> or <a class="el" href="lbm_8h.html#5ebb6c37e8e27a5338bc786f10c05007" title="Create and fill a UM wildcard receiver attribute object with the initial default...">lbm_wildcard_rcv_attr_create_default</a>, from which <em>attr</em> is initialized. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="052576cc5bc1e5a96b2ba3d55a8639d8"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_attr_getopt" ref="052576cc5bc1e5a96b2ba3d55a8639d8" args="(lbm_wildcard_rcv_attr_t *attr, const char *optname, void *optval, size_t *optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_attr_getopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM wildcard receiver attribute object where the option is stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the option value structure. The structure of the option values are specific to the options themselves. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>When passed, this is the max length (in bytes) of the <em>optval</em> structure. When returned, this is the length of the filled in <em>optval</em> structure. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="539c15ba728b1152c696da194afe16ae"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_attr_option_size" ref="539c15ba728b1152c696da194afe16ae" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_attr_option_size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function returns the number of entries that are of type "wildcard receiver"<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of entries that are of type "wildcard receiver" </dd></dl>

</div>
</div><p>
<a class="anchor" name="aa43df07f2e39d91832882d7569d4e85"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_attr_set_from_xml" ref="aa43df07f2e39d91832882d7569d4e85" args="(lbm_wildcard_rcv_attr_t *attr, const char *context_name, const char *pattern, int pattern_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_attr_set_from_xml           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>context_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pattern_type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The attribute object is filled with the defaults for the given context name, wildcard pattern, and pattern_type, if an XML configuration file has been loaded. If the context name or pattern and pattern_type combination are are not permitted by the XML configuration, -1 is returned and the attribute object is not written to.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>A pointer to a UM wildcard receiver attribute structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>context_name</em>&nbsp;</td><td>The context name used to lookup the wildcard receiver pattern in the XML configuration. A NULL value is permitted, and will match unnamed contexts defined in the XML. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pattern</em>&nbsp;</td><td>The pattern used to lookup the wildcard receiver in the XML configuration. A NULL value is *not* permitted and will result in an error. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pattern_type</em>&nbsp;</td><td>They type of pattern. Both pattern_type and pattern must match in XML configuration. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cec52fdb461e1f903b319e086d1d3e10"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_attr_setopt" ref="cec52fdb461e1f903b319e086d1d3e10" args="(lbm_wildcard_rcv_attr_t *attr, const char *optname, const void *optval, size_t optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_attr_setopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used before the wildcard receiver is created. NOTE: the attribute object must first be initialized with the corresponding _attr_create() function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM wildcard receiver attribute object where the option is to be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the option value structure. The structure of the option values are specific to the options themselves. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>Length (in bytes) of the <em>optval</em> structure. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0052519211be0078a9849a86aa574653"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_attr_str_getopt" ref="0052519211be0078a9849a86aa574653" args="(lbm_wildcard_rcv_attr_t *attr, const char *optname, char *optval, size_t *optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_attr_str_getopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM wildcard receiver attribute object where the option is stored </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>String to be filled in with the option value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>When passed, this is the max length (in bytes) of the string. When returned, this is the length of the filled in option value. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cee962d050b7c17a8e92445612d7b404"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_attr_str_setopt" ref="cee962d050b7c17a8e92445612d7b404" args="(lbm_wildcard_rcv_attr_t *attr, const char *optname, const char *optval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_attr_str_setopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used before the wildcard receiver is created. NOTE: the attribute object must first be initialized with the corresponding _attr_create() function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Pointer to a UM wildcard receiver attribute object where the option is to be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>String containing the option value. The format of the string is specific to the options themselves. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5b5d52f6b87499213757b73b09bc8160"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_create" ref="5b5d52f6b87499213757b73b09bc8160" args="(lbm_wildcard_rcv_t **wrcvp, lbm_context_t *ctx, const char *pattern, const lbm_rcv_topic_attr_t *tattr, const lbm_wildcard_rcv_attr_t *wattr, lbm_rcv_cb_proc proc, void *clientd, lbm_event_queue_t *evq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_create           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_t **&nbsp;</td>
          <td class="paramname"> <em>wrcvp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_context_t *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lbm_rcv_topic_attr_t *&nbsp;</td>
          <td class="paramname"> <em>tattr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const lbm_wildcard_rcv_attr_t *&nbsp;</td>
          <td class="paramname"> <em>wattr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lbm_8h.html#e2d650dd4830971ca0b6197298eddcdd">lbm_rcv_cb_proc</a>&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>clientd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_event_queue_t *&nbsp;</td>
          <td class="paramname"> <em>evq</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The callback <em>proc</em> will be called to deliver data sent to the topics that the receiver has requested.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from a context thread callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wrcvp</em>&nbsp;</td><td>A pointer to a pointer to a UM wildcard receiver object. Will be filled in by this function to point to the newly created lbm_wildcard_rcv_t object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>Pointer to the LBM context object associated with the wildcard receiver. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pattern</em>&nbsp;</td><td>Pattern to match the topic strings on for this wildcard. This is by default a regular expression. But more options may be supported. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tattr</em>&nbsp;</td><td>Pointer to a UM receive topic attribute structure used for specifying attributes for topics created for this wildcard receiver. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wattr</em>&nbsp;</td><td>Pointer to a UM wildcard receiver attribute structure specifying the options for this wildcard receiver. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>Pointer to a function to call when messages arrive. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Pointer to client data that is passed when data arrives and <em>proc</em> is called. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>evq</em>&nbsp;</td><td>Optional Event Queue to place message events on when they arrive. If NULL causes <em>proc</em> to be called from context thread. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="64407f3874012efaebcba322ea6d229d"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_delete" ref="64407f3874012efaebcba322ea6d229d" args="(lbm_wildcard_rcv_t *wrcv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_delete           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>wrcv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete a UM wildcard receiver object. Note that this function can return while the receiver callback may still be executing if receiver events are being delivered via an event queue. If the application needs to know when all possible processing on the receiver is complete, it must use <a class="el" href="lbm_8h.html#154f64dd4a7027866cff1dd24e6014b9" title="Extended delete a UM wildcard receiver object.">lbm_wildcard_rcv_delete_ex()</a>.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from a context thread callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wrcv</em>&nbsp;</td><td>Pointer to a UM wildcard receiver object to delete. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="154f64dd4a7027866cff1dd24e6014b9"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_delete_ex" ref="154f64dd4a7027866cff1dd24e6014b9" args="(lbm_wildcard_rcv_t *wrcv, lbm_event_queue_cancel_cb_info_t *cbinfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_delete_ex           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>wrcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__event__queue__cancel__cb__info__t__stct.html">lbm_event_queue_cancel_cb_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cbinfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete a UM wildcard receiver object, with an application callback indicating when the receiver is fully canceled. This extended version of the receiver delete function requires the configuration option queue_cancellation_callbacks_enabled be set to 1.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from a context thread callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wrcv</em>&nbsp;</td><td>Pointer to a UM wildcard receiver object to delete. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbinfo</em>&nbsp;</td><td>Cancellation callback information, containing the event queue, function pointer, and client data for the callback. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6c001aad4eaf7f3d34452cb074a284c7"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_dump" ref="6c001aad4eaf7f3d34452cb074a284c7" args="(lbm_wildcard_rcv_t *wrcv, int *size, lbm_config_option_t *opts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_dump           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>wrcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_config_option_t *&nbsp;</td>
          <td class="paramname"> <em>opts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The config object is filled with wildcard receiver configuration options <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wrcv</em>&nbsp;</td><td>The wildcard receiver object to retrieve the attributes from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the opts array. Will return the number of items that were set in opts </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opts</em>&nbsp;</td><td>The options array to fill </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3ffc7329dec32e4717bdbf0464f0ae25"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_getopt" ref="3ffc7329dec32e4717bdbf0464f0ae25" args="(lbm_wildcard_rcv_t *wrcv, const char *optname, void *optval, size_t *optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_getopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>wrcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wrcv</em>&nbsp;</td><td>Pointer to a UM wildcard receiver object where the option is stored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the option value structure. The structure of the option values are specific to the options themselves. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>When passed, this is the max length (in bytes) of the <em>optval</em> structure. When returned, this is the length of the filled in <em>optval</em> structure. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c68364b121e54fc8a6a36913be675635"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_setopt" ref="c68364b121e54fc8a6a36913be675635" args="(lbm_wildcard_rcv_t *wrcv, const char *optname, const void *optval, size_t optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_setopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>wrcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Only those options that can be set during operation may be specified. See "Options That May Be Set During Operation" (doc/Config/maybesetduringoperation.html) in The UM Configuration Guide. For API functions that can access any option, see lbm_wildcard_rcv_attr_*(). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wrcv</em>&nbsp;</td><td>Pointer to a UM wildcard receiver object where the option is to be set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>Pointer to the option value structure. The structure of the option values are specific to the options themselves. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>Length (in bytes) of the <em>optval</em> structure. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="db0853daf5d471dcf32ffed6cf7932f9"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_str_getopt" ref="db0853daf5d471dcf32ffed6cf7932f9" args="(lbm_wildcard_rcv_t *wrcv, const char *optname, char *optval, size_t *optlen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_str_getopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>wrcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>optval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>optlen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wrcv</em>&nbsp;</td><td>Pointer to a UM wildcard receiver object where the option is stored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>String to hold the option value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optlen</em>&nbsp;</td><td>When passed, this is the max length (in bytes) of the string. When returned, this is the length of the filled in option value. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="85a97cc687ae23b2fbeb2a8b4701c6f2"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_str_setopt" ref="85a97cc687ae23b2fbeb2a8b4701c6f2" args="(lbm_wildcard_rcv_t *wrcv, const char *optname, const char *optval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_str_setopt           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>wrcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>optval</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Only those options that can be set during operation may be specified. See "Options That May Be Set During Operation" (doc/Config/maybesetduringoperation.html) in The UM Configuration Guide. For API functions that can access any option, see lbm_wildcard_rcv_attr_*(). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wrcv</em>&nbsp;</td><td>Pointer to a UM wildcard receiver object where the option is to be set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optname</em>&nbsp;</td><td>String containing the option name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optval</em>&nbsp;</td><td>String containing the option value. The format of the string is specific to the options themselves. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a9d6c40859030a0c99d06f1f4da202b3"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_subscribe_channel" ref="a9d6c40859030a0c99d06f1f4da202b3" args="(lbm_wildcard_rcv_t *wrcv, lbm_uint32_t channel, lbm_rcv_cb_proc proc, void *clientd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_subscribe_channel           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>wrcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_uint32_t&nbsp;</td>
          <td class="paramname"> <em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lbm_8h.html#e2d650dd4830971ca0b6197298eddcdd">lbm_rcv_cb_proc</a>&nbsp;</td>
          <td class="paramname"> <em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>clientd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The callback <em>proc</em> will be called to deliver messages sent with the specified <em>channel</em> number. If NULL is specified for the <em>proc</em>, messages with the specified <em>channel</em> number will be delivered to the receiver's normal callback. If NULL is specified for the <em>proc</em>, any argument passed in for <em>clientd</em> will be ignored.<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>It is not safe to call this function from a context thread callback. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wrcv</em>&nbsp;</td><td>A pointer to a UM wildcard receiver object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>A channel number to subscribe to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>Pointer to a function to call when messages arrive. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clientd</em>&nbsp;</td><td>Pointer to clientd data that is passed when data arrives and <em>proc</em> is called. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="bdf5c9ae6ad1d5bb861eb8a9db4df4bc"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_umq_deregister" ref="bdf5c9ae6ad1d5bb861eb8a9db4df4bc" args="(lbm_wildcard_rcv_t *wrcv, const char *queue_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_umq_deregister           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>wrcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>queue_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wrcv</em>&nbsp;</td><td>Pointer to wildcard receiver object to de-register. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>queue_name</em>&nbsp;</td><td>Name of the queue to deregister from. A NULL means de-register from all UMQ queues. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c898e0fc1f77452918c36f1c176a7f15"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_umq_index_release" ref="c898e0fc1f77452918c36f1c176a7f15" args="(lbm_wildcard_rcv_t *wrcv, const char *queue_name, lbm_umq_index_info_t *index_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_umq_index_release           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>wrcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>queue_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__umq__index__info__t__stct.html">lbm_umq_index_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>index_info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function causes the UMQ indices to be assigned to another receiver.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wrcv</em>&nbsp;</td><td>Pointer to wildcard receiver object that wishes to release the index. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>queue_name</em>&nbsp;</td><td>Name of the queue to reassign the index. A NULL means reassign the index for all UMQ queues. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ca0f28a53507aab4be69150fa1928b52"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_umq_index_start_assignment" ref="ca0f28a53507aab4be69150fa1928b52" args="(lbm_wildcard_rcv_t *wrcv, const char *queue_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_umq_index_start_assignment           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>wrcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>queue_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wrcv</em>&nbsp;</td><td>Pointer to wildcard receiver object to start assignment for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>queue_name</em>&nbsp;</td><td>Name of the queue to start assignment from. A NULL means start assignment from all UMQ queues. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="15058af1a87407aefd1cbe7ae5ac53d0"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_umq_index_stop_assignment" ref="15058af1a87407aefd1cbe7ae5ac53d0" args="(lbm_wildcard_rcv_t *wrcv, const char *queue_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_umq_index_stop_assignment           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>wrcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>queue_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function causes new UMQ indices to not be assigned to the given wildcard receiver from the given UMQ queue(s). Messages with previously assigned UMQ indices may continue to be delivered to the given wildcard receiver from the given UMQ queue(s).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wrcv</em>&nbsp;</td><td>Pointer to wildcard receiver object to stop assignment for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>queue_name</em>&nbsp;</td><td>Name of the queue to stop assignment from. A NULL means stop assignment from all UMQ queues. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e05194988e175999e68b15874e342483"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_unsubscribe_channel" ref="e05194988e175999e68b15874e342483" args="(lbm_wildcard_rcv_t *wrcv, lbm_uint32_t channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_unsubscribe_channel           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>wrcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_uint32_t&nbsp;</td>
          <td class="paramname"> <em>channel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove a subscription to a channel previously subscribed to with <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="lbm_8h.html#a9d6c40859030a0c99d06f1f4da202b3" title="Subscribe to a channel, with an optional callback and clientd data pointer.">lbm_wildcard_rcv_subscribe_channel</a>.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wrcv</em>&nbsp;</td><td>A pointer to a UM wildcard receiver object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>The channel number for the channel subscription to be removed. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="feea1f5c5958a3df406ccf5c30014d72"></a><!-- doxytag: member="lbm.h::lbm_wildcard_rcv_unsubscribe_channel_ex" ref="feea1f5c5958a3df406ccf5c30014d72" args="(lbm_wildcard_rcv_t *wrcv, lbm_uint32_t channel, lbm_event_queue_cancel_cb_info_t *cbinfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wildcard_rcv_unsubscribe_channel_ex           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>wrcv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lbm_uint32_t&nbsp;</td>
          <td class="paramname"> <em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlbm__event__queue__cancel__cb__info__t__stct.html">lbm_event_queue_cancel_cb_info_t</a> *&nbsp;</td>
          <td class="paramname"> <em>cbinfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rcv</em>&nbsp;</td><td>A pointer to a UM wildcard receiver object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channel</em>&nbsp;</td><td>The channel number for the channel subscription to be removed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbinfo</em>&nbsp;</td><td>Cancellation callback information, containing the event queue, function pointer, and client data for the callback. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="ca04dc5f9048bc27f1db54b93cd73932"></a><!-- doxytag: member="lbm.h::lbm_win32_static_thread_attach" ref="ca04dc5f9048bc27f1db54b93cd73932" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_win32_static_thread_attach           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets up UM Thread Local Storage used for handling error information on a per thread basis. This function only needs to be called when using the static version of the UM library on Windows.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="62c79b9485498ad5bb2f240e1705d8ce"></a><!-- doxytag: member="lbm.h::lbm_win32_static_thread_detach" ref="62c79b9485498ad5bb2f240e1705d8ce" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_win32_static_thread_detach           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function frees up UM Thread Local Storage used for handling error information on a per thread basis. This function only needs to be called when using the static version of the UM library on Windows.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="dc9f1b15ab516bed8556e7a20666770c"></a><!-- doxytag: member="lbm.h::lbm_wrcv_ume_deregister" ref="dc9f1b15ab516bed8556e7a20666770c" args="(lbm_wildcard_rcv_t *wrcv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LBMExpDLL int lbm_wrcv_ume_deregister           </td>
          <td>(</td>
          <td class="paramtype">lbm_wildcard_rcv_t *&nbsp;</td>
          <td class="paramname"> <em>wrcv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function causes a UMP deregistration request to be sent to all stores the wildcard receiver is currently registered to, and disallows any future registrations.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wrcv</em>&nbsp;</td><td>Pointer to a UM wildcard receiver object </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 for Success and -1 for Failure </dd></dl>

</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Mar 6 13:11:10 2014 for LBM API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
<script type="text/javascript">highlight();</script>
</html>
