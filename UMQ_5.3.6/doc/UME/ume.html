<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org" />
<title>The Ultra Messaging Guide for Persistence and Queuing</title>
<meta name="GENERATOR" content="Modular DocBook HTML Stylesheet Version 1.79" />
<link rel="STYLESHEET" type="text/css" href="docbook.css" />
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
	<script type="text/javascript" src="../Search/highlight.js"></script>
</head>
<body class="ARTICLE" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#840084"
alink="#0000FF">
<div class="ARTICLE">
<div class="TITLEPAGE">
<h1 class="TITLE"><a id="AEN2" name="AEN2">The <b class="APPLICATION"><span
class="TRADEMARK">Ultra Messaging</span>&reg;</b> Guide for Persistence and
Queuing</a></h1>

<p class="COPYRIGHT">Copyright &copy; 2007 - 2014 Informatica</p>

<p class="PUBDATE">March 2014<br />
</p>

<div class="LEGALNOTICE"><a id="INFACOPYRIGHT" name="INFACOPYRIGHT"></a>
<p>Informatica Ultra Messaging</p>

<p>Version 5.3</p>

<p>March 2014</p>

<p>Copyright (c) 1998-2014 Informatica Corporation. All rights reserved.</p>

<p>This software and documentation contain proprietary information of Informatica
Corporation and are provided under a license agreement containing restrictions on use and
disclosure and are also protected by copyright law. Reverse engineering of the software
is prohibited. No part of this document may be reproduced or transmitted in any form, by
any means (electronic, photocopying, recording or otherwise) without prior consent of
Informatica Corporation. This Software may be protected by U.S. and/or international
Patents and other Patents Pending.</p>

<p>Use, duplication, or disclosure of the Software by the U.S. Government is subject to
the restrictions set forth in the applicable software license agreement and as provided
in DFARS 227.7202-1(a) and 227.7702-3(a) (1995), DFARS 252.227-7013(c)(1)(ii) (OCT 1988),
FAR 12.212(a) (1995), FAR 52.227-19, or FAR 52.227-14 (ALT III), as applicable.</p>

<p>The information in this product or documentation is subject to change without notice.
If you find any problems in this product or documentation, please report them to us in
writing.</p>

<p>Informatica, Informatica Platform, Informatica Data Services, PowerCenter,
PowerCenterRT, PowerCenter Connect, PowerCenter Data Analyzer, PowerExchange, PowerMart,
Metadata Manager, Informatica Data Quality, Informatica Data Explorer, Informatica B2B
Data Transformation, Informatica B2B Data Exchange Informatica On Demand, Informatica
Identity Resolution, Informatica Application Information Lifecycle Management,
Informatica Complex Event Processing, Ultra Messaging and Informatica Master Data
Management are trademarks or registered trademarks of Informatica Corporation in the
United States and in jurisdictions throughout the world. All other company and product
names may be trade names or trademarks of their respective owners.</p>

<p>Portions of this software and/or documentation are subject to copyright held by third
parties, including without limitation: Copyright DataDirect Technologies. All rights
reserved. Copyright (c) Sun Microsystems. All rights reserved. Copyright (c) RSA Security
Inc. All Rights Reserved. Copyright (c) Ordinal Technology Corp. All rights
reserved.Copyright (c) Aandacht c.v. All rights reserved. Copyright Genivia, Inc. All
rights reserved. Copyright Isomorphic Software. All rights reserved. Copyright (c) Meta
Integration Technology, Inc. All rights reserved. Copyright (c) Intalio. All rights
reserved. Copyright (c) Oracle. All rights reserved. Copyright (c) Adobe Systems
Incorporated. All rights reserved. Copyright (c) DataArt, Inc. All rights reserved.
Copyright (c) ComponentSource. All rights reserved. Copyright (c) Microsoft Corporation.
All rights reserved. Copyright (c) Rogue Wave Software, Inc. All rights reserved.
Copyright (c) Teradata Corporation. All rights reserved. Copyright (c) Yahoo! Inc. All
rights reserved. Copyright (c) Glyph &amp; Cog, LLC. All rights reserved. Copyright (c)
Thinkmap, Inc. All rights reserved. Copyright (c) Clearpace Software Limited. All rights
reserved. Copyright (c) Information Builders, Inc. All rights reserved. Copyright (c) OSS
Nokalva, Inc. All rights reserved. Copyright Edifecs, Inc. All rights reserved. Copyright
Cleo Communications, Inc. All rights reserved. Copyright (c) International Organization
for Standardization 1986. All rights reserved. Copyright (c) ej-technologies GmbH. All
rights reserved. Copyright (c) Jaspersoft Corporation. All rights reserved. Copyright (c)
is International Business Machines Corporation. All rights reserved. Copyright (c) yWorks
GmbH. All rights reserved. Copyright (c) Lucent Technologies. All rights reserved.
Copyright (c) University of Toronto. All rights reserved. Copyright (c) Daniel Veillard.
All rights reserved. Copyright (c) Unicode, Inc. Copyright IBM Corp. All rights reserved.
Copyright (c) MicroQuill Software Publishing, Inc. All rights reserved. Copyright (c)
PassMark Software Pty Ltd. All rights reserved. Copyright (c) LogiXML, Inc. All rights
reserved. Copyright (c) 2003-2010 Lorenzi Davide, All rights reserved. Copyright (c) Red
Hat, Inc. All rights reserved. Copyright (c) The Board of Trustees of the Leland Stanford
Junior University. All rights reserved. Copyright (c) EMC Corporation. All rights
reserved. Copyright (c) Flexera Software. All rights reserved. Copyright (c) Jinfonet
Software. All rights reserved. Copyright (c) Apple Inc. All rights reserved. Copyright
(c) Telerik Inc. All rights reserved.</p>

<p>This product includes software developed by the Apache Software Foundation
(http://www.apache.org/), and/or other software which is licensed under various versions
of the Apache License (the "License"). You may obtain a copy of these Licenses at
http://www.apache.org/licenses/. Unless required by applicable law or agreed to in
writing, software distributed under these Licenses is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the Licenses
for the specific language governing permissions and limitations under the Licenses.</p>

<p>This product includes software which was developed by Mozilla
(http://www.mozilla.org/), software copyright The JBoss Group, LLC, all rights reserved;
software copyright (c) 1999-2006 by Bruno Lowagie and Paulo Soares and other software
which is licensed under various versions of the GNU Lesser General Public License
Agreement, which may be found at http:// www.gnu.org/licenses/lgpl.html. The materials
are provided free of charge by Informatica, "as-is", without warranty of any kind, either
express or implied, including but not limited to the implied warranties of
merchantability and fitness for a particular purpose.</p>

<p>The product includes ACE(TM) and TAO(TM) software copyrighted by Douglas C. Schmidt
and his research group at Washington University, University of California, Irvine, and
Vanderbilt University, Copyright (c) 1993-2006, all rights reserved.</p>

<p>This product includes software developed by the OpenSSL Project for use in the OpenSSL
Toolkit (copyright The OpenSSL Project. All Rights Reserved) and redistribution of this
software is subject to terms available at http://www.openssl.org and
http://www.openssl.org/source/license.html.</p>

<p>This product includes Curl software which is Copyright 1996-2007, Daniel Stenberg,
&lt;daniel@haxx.se&gt;. All Rights Reserved. Permissions and limitations regarding this
software are subject to terms available at http://curl.haxx.se/docs/copyright.html.
Permission to use, copy, modify, and distribute this software for any purpose with or
without fee is hereby granted, provided that the above copyright notice and this
permission notice appear in all copies.</p>

<p>The product includes software copyright 2001-2005 (c) MetaStuff, Ltd. All Rights
Reserved. Permissions and limitations regarding this software are subject to terms
available at http://www.dom4j.org/ license.html.</p>

<p>The product includes software copyright (c) 2004-2007, The Dojo Foundation. All Rights
Reserved. Permissions and limitations regarding this software are subject to terms
available at http://dojotoolkit.org/license.</p>

<p>This product includes ICU software which is copyright International Business Machines
Corporation and others. All rights reserved. Permissions and limitations regarding this
software are subject to terms available at
http://source.icu-project.org/repos/icu/icu/trunk/license.html.</p>

<p>This product includes software copyright (c) 1996-2006 Per Bothner. All rights
reserved. Your right to use such materials is set forth in the license which may be found
at http:// www.gnu.org/software/ kawa/Software-License.html.</p>

<p>This product includes OSSP UUID software which is Copyright (c) 2002 Ralf S.
Engelschall, Copyright (c) 2002 The OSSP Project Copyright (c) 2002 Cable &amp; Wireless
Deutschland. Permissions and limitations regarding this software are subject to terms
available at http://www.opensource.org/licenses/mit-license.php.</p>

<p>This product includes software developed by Boost (http://www.boost.org/) or under the
Boost software license. Permissions and limitations regarding this software are subject
to terms available at http:/ /www.boost.org/LICENSE_1_0.txt.</p>

<p>This product includes software copyright (c) 1997-2007 University of Cambridge.
Permissions and limitations regarding this software are subject to terms available at
http:// www.pcre.org/license.txt.</p>

<p>This product includes software copyright (c) 2007 The Eclipse Foundation. All Rights
Reserved. Permissions and limitations regarding this software are subject to terms
available at http:// www.eclipse.org/org/documents/epl-v10.php.</p>

<p>This product includes software licensed under the terms at
http://www.tcl.tk/software/tcltk/license.html,
http://www.bosrup.com/web/overlib/?License, http://www.stlport.org/doc/ license.html,
http:// asm.ow2.org/license.html, http://www.cryptix.org/LICENSE.TXT,
http://hsqldb.org/web/hsqlLicense.html, http://httpunit.sourceforge.net/doc/
license.html, http://jung.sourceforge.net/license.txt ,
http://www.gzip.org/zlib/zlib_license.html,
http://www.openldap.org/software/release/license.html, http://www.libssh2.org,
http://slf4j.org/license.html, http://www.sente.ch/software/OpenSourceLicense.html,
http://fusesource.com/downloads/license-agreements/fuse-message-broker-v-5-3-
license-agreement; http://antlr.org/license.html; http://aopalliance.sourceforge.net/;
http://www.bouncycastle.org/licence.html; http://www.jgraph.com/jgraphdownload.html;
http://www.jcraft.com/jsch/LICENSE.txt; http://jotm.objectweb.org/bsd_license.html; .
http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231;
http://www.slf4j.org/license.html; http://nanoxml.sourceforge.net/orig/copyright.html;
http://www.json.org/license.html; http://forge.ow2.org/projects/javaservice/,
http://www.postgresql.org/about/licence.html, http://www.sqlite.org/copyright.html,
http://www.tcl.tk/software/tcltk/license.html, http://www.jaxen.org/faq.html,
http://www.jdom.org/docs/faq.html, http://www.slf4j.org/license.html;
http://www.iodbc.org/dataspace/iodbc/wiki/iODBC/License;
http://www.keplerproject.org/md5/license.html;
http://www.toedter.com/en/jcalendar/license.html;
http://www.edankert.com/bounce/index.html; http://www.net-snmp.org/about/license.html;
http://www.openmdx.org/#FAQ; http://www.php.net/license/3_01.txt;
http://srp.stanford.edu/license.txt; http://www.schneier.com/blowfish.html;
http://www.jmock.org/license.html; http://xsom.java.net; and
http://benalman.com/about/license/;
https://github.com/CreateJS/EaselJS/blob/master/src/easeljs/display/Bitmap.js;
http://www.h2database.com/html/license.html#summary; and
http://jsoncpp.sourceforge.net/LICENSE.</p>

<p>This product includes software licensed under the Academic Free License
http://www.opensource.org/licenses/afl-3.0.php), the Common Development and Distribution
License (http://www.opensource.org/licenses/cddl1.php) the Common Public License
(http://www.opensource.org/licenses/cpl1.0.php), the Sun Binary Code License Agreement
Supplemental License Terms, the BSD License (http://
www.opensource.org/licenses/bsd-license.php) the MIT License
(http://www.opensource.org/licenses/mit-license.php) and the Artistic License
(http://www.opensource.org/licenses/artistic-license-1.0).</p>

<p>This product includes software copyright (c) 2003-2006 Joe WaInes, 2006-2007 XStream
Committers. All rights reserved. Permissions and limitations regarding this software are
subject to terms available at http://xstream.codehaus.org/license.html. This product
includes software developed by the Indiana University Extreme! Lab. For further
information please visit http://www.extreme.indiana.edu/.</p>

<p>This Software is protected by U.S. Patent Numbers 5,794,246; 6,014,670; 6,016,501;
6,029,178; 6,032,158; 6,035,307; 6,044,374; 6,092,086; 6,208,990; 6,339,775; 6,640,226;
6,789,096; 6,820,077; 6,823,373; 6,850,947; 6,895,471; 7,117,215; 7,162,643; 7,243,110,
7,254,590; 7,281,001; 7,421,458; 7,496,588; 7,523,121; 7,584,422; 7676516; 7,720,842;
7,721,270; and 7,774,791, international Patents and other Patents Pending.</p>

<p>DISCLAIMER: Informatica Corporation provides this documentation "as is" without
warranty of any kind, either express or implied, including, but not limited to, the
implied warranties of noninfringement, merchantability, or use for a particular purpose.
Informatica Corporation does not warrant that this software or documentation is error
free. The information provided in this software or documentation may include technical
inaccuracies or typographical errors. The information in this software and documentation
is subject to change at any time without notice.</p>

<p>NOTICES</p>

<p>This Informatica product (the "Software") includes certain drivers (the "DataDirect
Drivers") from DataDirect Technologies, an operating company of Progress Software
Corporation ("DataDirect") which are subject to the following terms and conditions:</p>

<p>1. THE DATADIRECT DRIVERS ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.</p>

<p>2. IN NO EVENT WILL DATADIRECT OR ITS THIRD PARTY SUPPLIERS BE LIABLE TO THE END-USER
CUSTOMER FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL OR OTHER DAMAGES
ARISING OUT OF THE USE OF THE ODBC DRIVERS, WHETHER OR NOT INFORMED OF THE POSSIBILITIES
OF DAMAGES IN ADVANCE. THESE LIMITATIONS APPLY TO ALL CAUSES OF ACTION, INCLUDING,
WITHOUT LIMITATION, BREACH OF CONTRACT, BREACH OF WARRANTY, NEGLIGENCE, STRICT LIABILITY,
MISREPRESENTATION AND OTHER TORTS.</p>
</div>

<div class="DOCFORAMTNAVI">[ <a href="./index.html">Split HTML</a> / <a
href="ume.html">Single HTML</a> / <a href="ume.pdf">Single PDF</a> ]</div>

<hr />
</div>

<div class="TOC">
<dl>
<dt><b>Table of Contents</b></dt>

<dt>1. <a href="#INTRODUCTION">Introduction</a></dt>

<dt>2. <a href="#UMECONCEPTS">Concepts</a></dt>

<dt>3. <a href="#ARCHITECTURES">Architectures</a></dt>

<dt>4. <a href="#UME-OPS-OPERATIONAL-VIEW">Operational View</a></dt>

<dt>5. <a href="#TUTORIAL">Enabling Persistence</a></dt>

<dt>6. <a href="#DEMONSTRATING-UME-PERSISTENCE">Demonstrating Persistence</a></dt>

<dt>7. <a href="#DESIGNING-PERSISTENT-APPLICATIONS">Designing Persistence
Applications</a></dt>

<dt>8. <a href="#ENABLING-QUEUING">Enabling Queuing</a></dt>

<dt>9. <a href="#DESIGNING-QUEUING-APPLICATIONS">Designing Queuing Applications</a></dt>

<dt>10. <a href="#UME-FAULT-TOLERANCE">Fault Tolerance</a></dt>

<dt>11. <a href="#UMESTORED-MANPAGE">Man Pages</a></dt>

<dt>12. <a href="#UMESTORED-CONFIG">Configuration Reference for Umestored</a></dt>

<dt>13. <a href="#UME-STORE-WEB-MONITOR"><b class="APPLICATION"><span
class="TRADEMARK">Ultra Messaging</span></b> Web Monitor</a></dt>
</dl>
</div>

<div class="SECTION">
<h2 class="SECTION"><a id="INTRODUCTION" name="INTRODUCTION">1. Introduction</a></h2>

<p>In addition to high performance streaming, <b class="APPLICATION"><span
class="TRADEMARK">Ultra Messaging</span>&reg;</b> also provides persistence and low
latency queuing by implementing a configurable daemon that runs persistent stores ,
queues or both .</p>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="INTRO-PERSISTENCE" name="INTRO-PERSISTENCE">1.1.
Persistence</a></h3>

<p>A system implementing <b class="APPLICATION">UMP</b> persistence comprises any number
of sources, receivers, and persistent stores. <b class="APPLICATION"><span
class="TRADEMARK">Ultra Messaging</span></b>'s unique design provides <b
class="APPLICATION"><span class="TRADEMARK">Parallel Persistence</span>&reg;</b>, which
refers to the ability of a persistent store or stores to run independently of sources and
receivers and in parallel with messaging. The persistence store does not interfere with
message delivery to receiving applications. <b class="APPLICATION"><span
class="TRADEMARK">Parallel Persistence</span></b> adds several key features missing in
other messaging solutions.</p>

<ul>
<li>
<p>A fault recovery ability</p>
</li>

<li>
<p>The capacity to continue operation during specific types of failures</p>
</li>
</ul>

<p>Fault recovery refers to the system's ability to recover from a failure of any system
component (source, receiver or store). Under certain circumstances, <b
class="APPLICATION"><span class="TRADEMARK">Ultra Messaging</span></b> can even recover
from multiple failures and multiple cascading failures.</p>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="INTRO-QUEUING" name="INTRO-QUEUING">1.2. Queuing</a></h3>

<p>In addition to the capabilities of <b class="APPLICATION">UMP</b> and UMS, <b
class="APPLICATION">UMQ</b> supports brokered and brokerless queuing semantics.</p>

<p>Key features of <b class="APPLICATION">UMQ</b> include the following:</p>

<ul>
<li>
<p>Once and only once (OAOO) delivery for applications such as clearing and settlement
that require each trade be processed only once.</p>
</li>

<li>
<p>Application Sets for publishing into multiple logical queues with a single send,
making it easy to onboard new applications that require copies of the same data.</p>
</li>

<li>
<p>Ultra Load Balancing (ULB) for brokerless non-persistent queuing semantics, with
special considerations for message assignment, receiver pacing, and multi-source
fairness.</p>
</li>

<li>
<p>Java Messaging Service (JMS) support. See the Ultra Messaging JMS Guide for more
details.</p>
</li>
</ul>

<p>Queuing semantics are supported only within the same Topic Resolution Domain (TRD),
without Gateways or Dynamic Routers in the data path.</p>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="INTRO-UMPUMQ" name="INTRO-UMPUMQ">1.3. Semantic
Responsibilities</a></h3>

<p>Brokered and brokerless queuing semantics are orthogonal and independent from the
reliable non-persistent and durable persistent streaming semantics provided by UMS and
UMP. Differences outlined in the following list:</p>

<ul>
<li>
<p>Reliable non-persistent streaming (UMS) provides in-order message delivery and
gap/loss notification, while applications are running, without load-balanced message
delivery.</p>
</li>

<li>
<p>Durable persistent streaming (UMP) provides in-order message delivery and gap/loss
notification, while applications are running and across restarts, without load-balanced
message delivery.</p>
</li>

<li>
<p>Brokered queuing (UMQ) provides load-balanced message delivery, while applications are
running and across restarts, without message ordering and without gap/loss
notification.</p>
</li>

<li>
<p>Brokerless queuing (UMQ) provides load-balanced message delivery, while applications
are running, without message ordering and without gap/loss notification.</p>
</li>
</ul>

<p>Regardless of the messaging semantic chosen, applications assume the following
responsibilities to the extent applicable for their use case:</p>

<ul>
<li>
<p>Application resubmission (re-sending) of in-flight messages after source application
restart</p>
</li>

<li>
<p>Handling potentially duplicate messages from messaging layer or application
resubmission</p>
</li>

<li>
<p>Marking application resubmitted messages as such if needed to support duplicate
handling</p>
</li>

<li>
<p>Detecting stale data, for example, by using synchronized timestamps</p>
</li>

<li>
<p>Source and receiver application failover and state reconstruction</p>
</li>
</ul>

<p>Queuing is recommended for cases where load-balanced message delivery is required and
out-of-order message delivery and message loss without notification are acceptable, i.e.,
message delivery order and message loss are either unimportant or are handled by
applications (inclusive of application-level sequencing and gap detection, or
equivalent). For example, queuing is well-suited for load-balanced request/response with
bidirectional topics and application-level retries.</p>

<p>When designing queuing applications, it is important to consider whether message
processing is stateless (any receiver can process any message) or requires local state
(only certain receivers can process certain messages). If local state is required, the
recovery strategy for receiver hardware failure must consider how to rebuild that local
state. Receivers with local state may be better served by durable persistent streaming
rather than queuing.</p>
</div>
</div>

<div class="SECTION">
<hr />
<h2 class="SECTION"><a id="UMECONCEPTS" name="UMECONCEPTS">2. Concepts</a></h2>

<p>This section illuminates important <b class="APPLICATION">UMP</b> and <b
class="APPLICATION">UMQ</b> concepts and features.</p>

<ul>
<li>
<p><a href="#UME-PERSISTENCE"><i>Persistence</i></a></p>
</li>

<li>
<p><a href="#UME-QUEUING-FEATURES"><i>Queuing Features</i></a></p>
</li>
</ul>

<p>Contained in <b class="APPLICATION">UMP</b> and <b class="APPLICATION">UMQ</b> are all
of the features and capabilities of <b class="APPLICATION"><span class="TRADEMARK">Ultra
Messaging</span></b>'s high performance, message streaming. This document explains
persistence and queuing capabilities only. For specific information about <b
class="APPLICATION"><span class="TRADEMARK">Ultra Messaging</span></b>'s high performance
streaming, see <a href="../Design/index.html" target="doccontent"><b class="APPLICATION"><span
class="TRADEMARK">Ultra Messaging</span></b> <b class="APPLICATION">Concepts</b></a>.</p>

<p>Also available to <b class="APPLICATION">UMP</b> and <b class="APPLICATION">UMQ</b> is
the <b class="APPLICATION"><span class="TRADEMARK">Ultra Messaging</span></b> <b
class="APPLICATION">Manager</b>. <b class="APPLICATION">UMM</b> provides a GUI that
simplifies the creation of <b class="APPLICATION">UM</b> XML configuration files and also
allows you to assign application configurations to specific users, also created in the
UMM GUI. The UMM Daemon runs this feature, offering a <b class="APPLICATION">UMM</b> GUI
API to support custom GUIs and uses a MySQL database to store configurations. See the <a
href="../UMM/index.html" target="doccontent">Ultra Messaging Manager Guide</a>.</p>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="UME-PERSISTENCE" name="UME-PERSISTENCE">2.1.
Persistence</a></h3>

<p>In discussing <b class="APPLICATION">UMP</b> , we refer to specific recovery from the
failures of sources, receivers, and persistent stores. Failed sources can restart and
resume sending data from the point at which they stopped. Receivers can recover from
failure and begin receiving data from the point immediately prior to failure. This
process is sometimes called durable subscription. Persistent stores can also be restarted
and continue providing persistence to the sources and receivers that they serve. <b
class="APPLICATION">UMP</b> is not designed to address ongoing, corrupting agents.
Rather, if one of its components fails, the design of <b class="APPLICATION">UMP</b> 's
persistence enables it to continue supporting its ongoing operations at some level.</p>

<p>The default mode of <b class="APPLICATION">UMP</b> Persistence is Source-paced
Persistence (SPP). In this mode, the consumption of messages by receivers does not impact
the rate a <b class="APPLICATION">UM</b> source can send messages. Sources send messages
simultaneously to receivers and the persistent store. (See <a
href="#UME-OPS-NORMAL-OPERATION"><i>Normal Operation</i></a>.) Receiver-paced Persistence
(RPP) is the second mode. In RPP, sources also send messages to receivers and the
persistent store in parallel, but the store retains RPP messages until all RPP receivers
acknowledge consumption. In addition, sources can be slowed to ensure that the store is
not overrun with messages resulting in messages being dropped and not delivered to all
RPP receivers. (See <a href="#UMP-RPPOPS-NORMAL-OPERATION"><i>RPP Normal
Operations</i></a>.)</p>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UMECONCEPTS-PERSISTENCESTORE"
name="UMECONCEPTS-PERSISTENCESTORE">2.1.1. Persistent Store</a></h4>

<p><b class="APPLICATION">UMP</b> uses a daemon to persist source and receiver state
outside the actual sources and receivers themselves. This is the <b
class="APPLICATION">UMP</b> Persistent Store. The store can persist state in memory as
well as on disk. State is persisted on a per-topic, per-source basis by the store. <b
class="APPLICATION">UMP</b> stores need not be a single entity. For fault tolerance
purposes, it is possible to configure multiple stores in various ways. See <a
href="#TUTORIAL-UMESTORE"><i>Adding the</i> UMP Store to a Source</a>, <a
href="#UME-STORES"><i>UMP Stores</i></a>, <a
href="#STORE-CONFIGURATION-CONSIDERATIONS"><i>Store Configuration Considerations</i></a>,
<a href="#UMESTORED-MANPAGE"><i>Man Pages</i></a> and <a
href="#UMESTORED-CONFIG"><i>Configuration Reference for Umestored</i></a>.</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UMECONCEPTS-REGID" name="UMECONCEPTS-REGID">2.1.2.
Registration Identifier</a></h4>

<p><b class="APPLICATION">UMP</b> identifies sources and receivers with Registration
Identifiers, also called Registration IDs or RegIDs. A RegID is a 32-bit number that
uniquely identifies a source or a receiver to a store. This means that RegIDs are also
specific to a store and can be reused between individual stores, if needed. No two active
sources or receivers can share a RegID or use the same RegID at the same time. This point
is critical: since <b class="APPLICATION">UMP</b> enables your application to use and
handle RegIDs very freely, you must use RegIDs carefully to avoid destructive results.
See <a href="#TUTORIAL-ADDINGFAULTRECOVERY"><i>Adding Fault Recovery with Registration
IDs</i></a> and <a href="#REGISTRATION-IDENTIFIERS"><i>Registration Identifiers</i></a>.
RegIDs can also be managed easily with the use of Session IDs. See <a
href="#SESSION-IDS"><i>Managing RegIDs with Session IDs</i></a>.</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UMECONCEPTS-DELIVERYCONFIRMATION"
name="UMECONCEPTS-DELIVERYCONFIRMATION">2.1.3. Delivery Confirmation</a></h4>

<p><b class="APPLICATION">UMP</b> provides feedback to sources upon notification that a
receiver has consumed a given piece of data, in other words, that it has received and
processed a message. This feedback is called Delivery Confirmation. See also <a
href="#CONFIRMED-DELIVERY"><i>Confirmed Delivery</i></a> and <a
href="#SOURCE-MESSAGE-RETENTION-AND-RELEASE"><i>Source Message Retention and
Release</i></a>.</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UMECONCEPTS-RETENTIONPOLICY"
name="UMECONCEPTS-RETENTIONPOLICY">2.1.4. Release Policy</a></h4>

<p>Sources and persistent stores retain data according to a release policy, which is a
set of rules that specifies when a message can be reclaimed. Each rule would allow any
message that complies with the rule to be reclaimed. However, a message must comply with
all rules before it can be reclaimed. Conversely, any message not complying with all
rules will not be reclaimed. A source or store retains messages until its retention
policy dictates the message may be removed. Sources and stores use slightly different
retention policies based on their individual roles. For more information on retention
policies, see <a href="#SOURCE-MESSAGE-RETENTION-AND-RELEASE"><i>Source Message Retention
and Release</i></a>.</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UMECONCEPTS-MESSAGESTABILITY"
name="UMECONCEPTS-MESSAGESTABILITY">2.1.5. Message Stability</a></h4>

<p>Sources send messages to both receivers and to stores. Messages become stable once the
message has been persisted at the store or a set of stores. The number of messages that
can be sent by a source has no relation to the number of its messages that have been
stabilized unless <a href="#UME-FLIGHT-SIZE"><i>UMP Flight Size</i></a> is enabled. In
addition, <b class="APPLICATION">UMP</b> informs the application when messages are
stabilized, enabling the application to take any desired action. See <a
href="#SOURCE-MESSAGE-RETENTION-AND-RELEASE"><i>Source Message Retention and
Release</i></a>.</p>

<p>Publishing messages to a store is a coordinated hand-off between the publishing
application and the store. The store assumes responsibility for delivering a message only
when the publisher is informed that the message is <span class="emphasis"><i
class="EMPHASIS">stable</i></span>. Stability refers to the store having a copy of the
message in memory and/or on disk, depending on configuration. Until the publisher is
informed that a message is stable, it may be lost upon restart. Messages may be delivered
without the publisher being informed that they were stable. Upon restart, the publisher
is expected to send again any messages previously sent that were not known to be stable.
Since the store cannot differentiate between new messages and messages sent again upon
publisher restart, the application is responsible for marking messages as sent again in
some manner (e.g., by setting a flag in message content or properties), if required for
downstream duplicate checking.</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UMECONCEPTS-ROUND-ROBIN" name="UMECONCEPTS-ROUND-ROBIN">2.1.6.
Round-Robin Store Failover</a></h4>

<p>Stores can also experience failures from which they may or may not recover. A source
can be configured to move to a second store if the first store fails and can not recover
in time. Round-robin store behavior describes the behavior of a source moving through a
list of stores, using a single store at any one time, with several specified backups
available to it in case the single store fails.</p>

<p>See also <a href="#SOURCES-USING-RR-STORE-CONFIGURATION"><i>Sources Using Round-Robin
Store Configuration</i></a> and <a href="#ROUND-ROBIN-STORE-USAGE"><i>Round-Robin Store
Usage</i></a></p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UMECONCEPTS-QUORUM-CONSENSUS"
name="UMECONCEPTS-QUORUM-CONSENSUS">2.1.7. Quorum/Consensus Store Failover</a></h4>

<p>In addition to a source being configured for round-robin store behavior, several
stores can be configured for simultaneous operation. In this situation, a single store or
even a handful of stores can fail without impacting the source and receivers. As long as
a quorum of the configured stores is accessible, messaging operation generally continues
uninterrupted. (<b class="APPLICATION">UMP</b> defines a Quorum as a majority.)</p>

<p>See also <a href="#SOURCES-USING-QC-STORE-CONFIGURATION"><i>Sources Using
Quorum/Consensus Store Configuration</i></a>, <a
href="#QUORUM-CONSENSUS-STORE-USAGE"><i>Quorum/Consensus Store Usage</i></a>, <a
href="#QC-CONFIG-SINGLE-LOCATION-GROUPS"><i>Quorum/Consensus - Single Location
Groups</i></a> and <a href="#QC-CONFIG-MIXED-LOCATION-GROUPS"><i>Quorum/Consensus - Mixed
Location Groups</i></a>.</p>
</div>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="UME-QUEUING-FEATURES" name="UME-QUEUING-FEATURES">2.2. Queuing
Features</a></h3>

<p>A queue may be persistent or may be volatile in nature. Receiver message processing
follows a once-and-only-once (OAOO) semantic where each message is only processed by a
single receiver of the application set. The following concepts are integral to <b
class="APPLICATION">UMQ</b>.</p>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="SOURCE-STREAMING" name="SOURCE-STREAMING">2.2.1. Source
Streaming</a></h4>

<p>Sources may send and have in flight several messages to the queue at the same time.
This provides some significant throughput benefits.</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UMQ-MESSAGESTABILITY" name="UMQ-MESSAGESTABILITY">2.2.2.
Message Stability</a></h4>

<p>Publishing messages to a queue is a coordinated hand-off between the publishing
application and the queue. The queue assumes responsibility for delivering a message only
when the publisher is informed that the message is <span class="emphasis"><i
class="EMPHASIS">stable</i></span>. Stability refers to the queue having a copy of the
message in memory and/or on disk, depending on configuration. Until the publisher is
informed that a message is stable, it may be lost upon restart. Messages may be delivered
without the publisher being informed that they were stable. Upon restart, the publisher
is expected to send again any messages previously sent that were not known to be stable.
Since the queue cannot differentiate between new messages and messages sent again upon
publisher restart, the application is responsible for marking messages as sent again in
some manner (e.g., by setting a flag in message content or properties), if required for
downstream duplicate checking.</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UMQ-OAOO" name="UMQ-OAOO">2.2.3. Once-and-Only-Once
Delivery</a></h4>

<p>Once-and-Only-Once (OAOO) delivery means that each message is assigned to only one
receiver at a time. If a message is not acknowledged by the assigned receiver, it can be
reassigned and redelivered to either the same or a different receiver (depending on
configuration and circumstances), in which case the resent message is flagged as
redelivered. Applications are always responsible for detection and proper handling of
potentially duplicate messages.</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="APPLICATION-SETS" name="APPLICATION-SETS">2.2.4. Application
Sets</a></h4>

<p>An Application Set is a group of receivers and can be used to load balance queue
topics within a receiving application or accommodate multiple processing purposes for a
single topic. The OAOO semantic applies to an Application Set. Therefore, you can
configure multiple Application Sets for a queue and only one receiver in each set will
process a given message. See <a href="#APP-SET-ELEMENT"><i>Application Set
Element</i></a>.</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="RECEIVER-PORTION-SIZE" name="RECEIVER-PORTION-SIZE">2.2.5.
Receiver Portion Size</a></h4>

<p>You can increase the throughput to receivers by increasing their portion size. This
increases the number of messages in flight to a receiver. This setting is specified in a
Receiver Type ID. See <a href="#RECEIVER-TYPE-OPTIONS"><i>Options for a Receiver Type's
ume-attributes Element</i></a>. A receiver configured with one Receiver Type ID and
subscribed to Topic A in one application can have 5 messages in flight, where a Topic A
receiver configured with a different Receiver Type ID in another application can have
only one message in flight.</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="CONFIG-STORE-FORWARD" name="CONFIG-STORE-FORWARD">2.2.6.
Configurable Store and Forward</a></h4>

<p>You can configure a Queue to assign and send data to receivers after the data has been
persisted to disk (<b class="APPLICATION">Store-Then-Forward</b>) or in parallel to being
persisted to disk (<b class="APPLICATION">Store-While-Forwarding</b>). <b
class="APPLICATION">Store-While-Forwarding</b> produces lower end-to-end latency from
sources to receivers at the expense of potential message loss under certain multiple
failure conditions. See also ...</p>

<ul>
<li>
<p><a href="#UMESTORED-QUEUE-ELEMENT"><i>Queue Element</i></a></p>
</li>

<li>
<p><a href="#QUEUING-ARCH"><i>Queuing Architecture</i></a></p>
</li>
</ul>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="DISSEMINATION" name="DISSEMINATION">2.2.7. Multiple
Dissemination Models</a></h4>

<p><b class="APPLICATION">UMQ</b> provides the following load balancing configurations
for data dissemination not possible with other queuing products.</p>

<ul>
<li>
<p><a href="#SQD"><i>Serial Queue Dissemination (SQD)</i></a>: Queue sends data to each
receiver via serial unicasts. Only the receivers assigned to a message receive that
message.</p>
</li>

<li>
<p><a href="#PQD"><i>Parallel Queue Dissemination (PQD)</i></a>: Queue sends data and
control information to all receivers via <b class="APPLICATION">UM</b> transport
sessions. Control information contains assignment information.</p>
</li>

<li>
<p><a href="#SD"><i>Source Dissemination (SD)</i></a>: Source sends data to all receivers
via <b class="APPLICATION">UM</b> transport sessions. Queues send control information to
all receivers via separate transport sessions. Control information contains assignment
information.</p>
</li>
</ul>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="QUEUE-FAULT-TOLERANCE" name="QUEUE-FAULT-TOLERANCE">2.2.8.
Queue Fault Tolerance</a></h4>

<p>Queues may be composed of several actual queue instances that operate with source and
receivers in such a way that failure of one queue instance or even several queue
instances need not stop or even slow down sources and receivers from performing queuing
operations. See <a href="#QUEUE-REDUNDANCY"><i>Queue Redundancy</i></a>.</p>

<p>Known Issue: Configurations with multiple queue instances (slaves) can lead to
inconsistent state, which can trigger message loss, crashes or restart issues
necessitating removal of files resulting in message loss. Therefore, Informatica
recommends deploying configurations with only a single queue instance (without slaves).
To facilitate failover, set the <tt class="LITERAL">sinc-log-filename</tt>, <tt
class="LITERAL">sinc-data-filename</tt>, and <tt
class="LITERAL">sinc-queue-swap-filename</tt> to write to a shared file-system, and use
external process management (automatic or manual) to start up a secondary queue instance
referencing the same files if and only if the active instance fails (i.e. only allow one
queue instance to access the files at any time). With this configuration, sinc files will
grow over time, so clean restarts (i.e. shut down, delete all files and restart) will be
required periodically. Using a shared file-system may impact performance; Informatica
strongly recommends holistic system performance characterization prior to any production
deployment.</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="INDEXED-QUEUING" name="INDEXED-QUEUING">2.2.9. Indexed
Queuing</a></h4>

<p>Messages may be sent with an <span class="emphasis"><i
class="EMPHASIS">index</i></span> using an extended send call, <code
class="FUNCTION">lbm_src_sendv_ex</code>, that includes a pointer to <a
href="../API/structlbm__umq__index__info__t__stct.html" target="doccontent"><tt
class="LITERAL">lbm_umq_index_info_t</tt></a> in <tt
class="LITERAL">lbm_src_send_ex_info_t</tt>. An index is an application-defined 64-bit
unsigned number or free-form string.</p>

<p>By default, all receivers are eligible to be assigned indices by the Queue. Once the
Queue assigns the first message sent with a particular index to an individual receiver in
each Application Set, the Queue assigns subsequent messages (sent from any source) with
that same index to those same individual receivers, provided the receivers remain alive
and responsive.</p>

<p>You can exert greater control over how a Queue assigns indices to receivers by
configuring individual indices and ranges of indices in the Queue's <tt
class="LITERAL">umestored</tt> XML configuration file. You can then set rules that allow
or deny receivers the permission to process messages with certain indices. See <a
href="#UMESTORED-INDICES-ELEMENT"><i>Indices Element</i></a>.</p>

<p>Note that with indexed queuing, messages with a particular index can be assigned only
to the single consumer responsible for that index (i.e., assignment is "sticky"). If an
index consumer stops consuming messages (a failure scenario) long enough for its
configured portion size to become full while another message with the same index is
pending, message delivery to all other consumers within the same Application Set is
halted. Therefore, Informatica recommends using indexed queuing only in configurations
with message reassignment enabled and set to a relatively brief interval, as this
determines the amount of time that message consumption within an Application Set may be
halted in the event of receiver failure.</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="DEAD-LETTER-QUEUE" name="DEAD-LETTER-QUEUE">2.2.10. Dead
Letter Queue</a></h4>

<p>Queues can be configured to isolate unconsumed messages in a Dead Letter Queue, which
prevents these messages from causing application or queuing system problems. These
unconsumed messages remain in the Dead Letter Queue for the life of the Queue. Other
applications can access these messages for analysis by starting a wildcard receiver for
the Dead Letter topic queue.</p>

<p>Configuring a Dead Letter Queue involves the following actions in the Queue's <tt
class="LITERAL">umestored</tt> XML configuration file.</p>

<ol type="1">
<li>
<p>Configure a <tt class="LITERAL">dead-letter-topic-prefix</tt> and <tt
class="LITERAL">dead-letter-topic-separator</tt> for the Queue. <b
class="APPLICATION">UMQ</b> uses this information to compose a Dead Letter topic name.
The example below illustrates this step, but may or may not be suitable to include in
your <tt class="LITERAL">umestored</tt> XML configuration file. See also <a
href="#GEN-QUEUE-OPTIONS"><i>General Options for a Queue's ume-attributes
Element</i></a>.</p>

<pre class="PROGRAMLISTING">
&lt;queues&#62;
&lt;queue name="Sample_Queue_with_Dead_Letter_Topic" port="20333" group-index="0"&#62;
    &lt;ume-attributes&#62;
        &lt;!-- dead-letter-topic-prefix must be specified for any dead letter queues to be created --&#62;
        &lt;option type="queue" name="dead-letter-topic-prefix" value="dead_letter"/&#62;
        &lt;!-- dead-letter-topic-separator defaults to '/', so the following line isn't necessary --&#62;
        &lt;option type="queue" name="dead-letter-topic-separator" value="/"/&#62;
    &lt;/ume-attributes&#62;
&lt;/queue&#62;
       
</pre>
</li>

<li>
<p>In each of the Queue's Application Sets from which you wish to capture unconsumed
messages, set the <tt class="LITERAL">discard-behavior</tt> to <tt
class="LITERAL">dead-letter</tt>. The example below illustrates this step, but may or may
not be suitable to include in your <tt class="LITERAL">umestored</tt> XML configuration
file. See also <a href="#APP-SET-OPTIONS"><i>Options for an Application Set's
ume-attributes Element</i></a>.</p>

<pre class="PROGRAMLISTING">
&lt;application-sets&#62;
    &lt;application-set name="Set 1"&#62;
        &lt;ume-attributes&#62;
            &lt;option type="queue" name="log-audit-trail" value="1"/&#62;
            &lt;!-- discard-behavior set to dead-letter tells the queue that when messages 
            EOL off this appset, they should be placed on a dead letter queue --&#62;
            &lt;option type="queue" name="discard-behavior" value="dead-letter"/&#62;
        &lt;/ume-attributes&#62;
    &lt;/application-set&#62;
&lt;/application-sets&#62;
       
</pre>
</li>

<li>
<p>Configure a <tt class="LITERAL">dead-letter-topic</tt> for the Queue and assign it to
a different <tt class="LITERAL">application set</tt> than the one in step 2 that has its
<tt class="LITERAL">discard-behavior</tt> set to <tt class="LITERAL">drop</tt>. The
example below illustrates this step, but may or may not be suitable to include in your
<tt class="LITERAL">umestored</tt> XML configuration file. See also <a
href="#QTOPIC-OPTIONS"><i>Options for a Queue Topic's ume-attributes Element</i></a>.</p>

<pre class="PROGRAMLISTING">
&lt;topics&#62;
    &lt;!-- since the dead-letter-topic-prefix is dead_letter, it is necessary to specify a topic 
    pattern that matches dead_letter --&#62;
    &lt;topic pattern="dead_letter" type="PCRE"&#62;
        &lt;ume-attributes&#62;
            &lt;!-- this topic is a dead-letter-topic --&#62;
            &lt;!-- you cannot create a source and submit messages directly to a dead 
            letter topic --&#62;
            &lt;option type="queue" name="dead-letter-topic" value="1"/&#62;
        &lt;/ume-attributes&#62;
        &lt;application-sets&#62;
            &lt;!-- you must assign this dead-letter-topic to an application set that has its 
            "discard-behavior" set to "drop" --&#62;
            &lt;application-set name="Set 2"/&#62;
        &lt;/application-sets&#62;
    &lt;/topic&#62;
&lt;/topics&#62;
       
</pre>
</li>
</ol>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="MESSAGE-LIFETIMES" name="MESSAGE-LIFETIMES">2.2.11. Message
Lifetimes</a></h4>

<p>You can configure a lifetime period for messages during which the message may be
assigned to a receiver. Upon expiration of the message lifetime, the queue cannot assign
the message to a receiver. The queue either discards the message from the queue
permanently or sends it to the <a href="#DEAD-LETTER-QUEUE"><i>Dead Letter Queue</i></a>,
if configured. A message's total lifetime starts when the queue enqueues the message.
Messages lifetimes apply to both <b class="APPLICATION">UMQ</b> and ULB messages. See <a
href="#MESSAGE-LIFETIMES-REASSIGN"><i>Message Lifetimes and Reassignment</i></a>.</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="QUEUING-TERMINOLOGY" name="QUEUING-TERMINOLOGY">2.2.12.
Queuing Terminology</a></h4>

<p><b class="APPLICATION"><span class="TRADEMARK">Ultra Messaging</span></b> <b
class="APPLICATION">Queuing Edition</b> uses the following terms.</p>

<div class="INFORMALTABLE"><a id="AEN318" name="AEN318"></a>
<table border="1" class="CALSTABLE">
<col width="144" />
<col width="480" />
<thead>
<tr>
<th>Term</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>Queue</td>
<td>A named, virtual entity to which sources submit messages and from which receivers
retrieve messages.</td>
</tr>

<tr>
<td>Queue Instance</td>
<td>A running daemon that is part of a Queue. In <b class="APPLICATION">UMP</b> , this is
the <tt class="LITERAL">umestored</tt> process. The collection of all queue instances
with the same name constitutes a Queue.</td>
</tr>

<tr>
<td>Registration ID</td>
<td>The ID that a source or receiver application uses to register a context with a Queue.
The context uses the same Registration ID for each Queue Instance. The context may
generate a Registration ID or the user may specify Registration IDs to be used with
specific Queues. See <a
href="../Config/ultramessagingqueuingoptions.html#CONTEXTUMQQUEUEREGISTRATIONID"
target="doccontent"><tt class="LITERAL">umq_queue_registration_id</tt></a></td>
</tr>

<tr>
<td>Message ID</td>
<td>The unique ID of a queue message.</td>
</tr>

<tr>
<td>Assignment</td>
<td>The designation of particular queued messages to individual receivers for
processing.</td>
</tr>

<tr>
<td>Consumption</td>
<td>The processing of a queue message by an assigned receiver.</td>
</tr>

<tr>
<td>Consumption Report (CR)</td>
<td>Receivers send Consumption Report (CR) messages to notify Queues of message
consumption.</td>
</tr>

<tr>
<td>Re-Assignment</td>
<td>When a receiver does not consume a message within a specified period of time, the
Queue re-assigns the message to another receiver.</td>
</tr>

<tr>
<td>Assignment ID</td>
<td>Used by the Queue to identify receivers registered with certain topics. Found within
control information.</td>
</tr>

<tr>
<td>Receiver Control Record (RCR)</td>
<td>Message control information sent to receivers by Queues using Parallel Queue
Dissemination (PQD) or Source Dissemination (SD). An RCR contains the Message ID of the
message, a list of the Assignment IDs (receivers) that should process the message, and
ordering information.</td>
</tr>

<tr>
<td>RCR Index</td>
<td>An index that identifies a topic on a Queue.</td>
</tr>

<tr>
<td>End of Lifetime (EOL)</td>
<td>Maximum time limit before a message must be consumed. The timer starts when the Queue
assigns the message to a receiver and is unaffected by reassignments. The Queue discards
any message with an expired EOL.</td>
</tr>

<tr>
<td>Receiver Type ID</td>
<td>Indicates the Application Set a receiving application wishes to join. This ID is
fully managed by the administrator of the Queue and implies not only Application Set but
also some other ways that the receiver is treated, such as portion size and assignment
options.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>

<div class="SECTION">
<hr />
<h2 class="SECTION"><a id="ARCHITECTURES" name="ARCHITECTURES">3. Architectures</a></h2>

<p>The same <b class="APPLICATION"><span class="TRADEMARK">Ultra Messaging</span></b> API
may be used for stream-based messaging or persistent messaging and queuing . Similarly,
the <tt class="LITERAL">umestored</tt> daemon can be configured as a persistent store or
queue, providing consistent and efficient operation across persistent and queuing
messaging systems.</p>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="PERSISTENCE-ARCH" name="PERSISTENCE-ARCH">3.1. Persistence
Architecture</a></h3>

<p>As shown in the diagram, <b class="APPLICATION">UMP</b> provides messaging
functionality as well as persistent operation. See <a href="#UMEARCH"><i>UMP Persistence
Architecture</i></a> for an overview of <b class="APPLICATION">UMP</b> architecture.</p>

<div class="FIGURE"><a id="UMEARCH" name="UMEARCH"></a>
<p><b>Figure 1. UMP Persistence Architecture</b></p>

<p><img src="UME_Persist_Arch.png" align="CENTER" /></p>
</div>

<p>The highlights of this architecture are:</p>

<ul>
<li>
<p>Sources communicate with stores</p>
</li>

<li>
<p>Receivers communicate with stores</p>
</li>

<li>
<p>Sources communicate with receivers</p>
</li>
</ul>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> The persistent store does not lie in the middle of the data path between
source and receivers. Along with other enhancements, this feature, called <b
class="APPLICATION"><span class="TRADEMARK">Parallel Persistence</span></b>, gives <b
class="APPLICATION">UMP</b> a significant performance edge over any other persistent
messaging product.</p>
</blockquote>
</div>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> The persistent store is not supported on the <span class="TRADEMARK">HP
NonStop</span>&reg; platform.</p>
</blockquote>
</div>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="STORE-ARCH" name="STORE-ARCH">3.2. Persistent Store
Architecture</a></h3>

<p>The <tt class="LITERAL">umestored</tt> daemon runs the <b class="APPLICATION">UMP</b>
persistent store feature. You can configure multiple stores per daemon using the <tt
class="LITERAL">&lt;store&#62;</tt> element in the <tt class="LITERAL">umestored</tt> XML
configuration file. See <a href="#UMESTORED-CONFIG"><i>Configuration Reference for
Umestored</i></a>. Individual stores can use separate disk cache and disk state
directories and be configured to persist messages for multiple sources (topics), which
are referred to as, source repositories. <b class="APPLICATION">UMP</b> provides each <tt
class="LITERAL">umestored</tt> daemon with a Web Monitor for statistics monitoring. See
<a href="#UME-STORE-WEB-MONITOR"><i>Ultra Messaging Web Monitor</i></a>.</p>

<div class="FIGURE"><a id="UMPSTOREARCHITECTURE" name="UMPSTOREARCHITECTURE"></a>
<p><b>Figure 2. Store Architecture</b></p>

<p><img src="UMP_Store_Architecture.png" align="CENTER" /></p>
</div>

<p>This section discusses the following topics.</p>

<ul>
<li>
<p><a href="#SOURCE-REPOSITORIES"><i>Source Repositories</i></a></p>
</li>

<li>
<p><a href="#STORE-FAULT-TOLERANCE"><i>Persistent Store Fault Tolerance</i></a></p>
</li>
</ul>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="SOURCE-REPOSITORIES" name="SOURCE-REPOSITORIES">3.2.1. Source
Repositories</a></h4>

<p>Within a store, you configure repositories for individual topics and each can have
their own s et of <tt class="LITERAL">&lt;topic&#62;</tt> level options that affect the
repository's type, size, liveness behavior and much more. If you have multiple sources
sending on the same topic, <b class="APPLICATION">UMP</b> creates a separate repository
for each source. <b class="APPLICATION">UMP</b> uses the repository options configured
for the topic to apply to each source's repository. If you specify 48MB for the size of
the repository and have 10 sources sending on the topic, the persistent store requires
480MB of storage for that topic.</p>

<p>A repository can be configured as one of the following types.</p>

<ul>
<li>
<p><tt class="LITERAL">no cache</tt> - the repository does not retain any data, only
state information</p>
</li>

<li>
<p><tt class="LITERAL">memory</tt> - the repository maintain both state and data only in
memory</p>
</li>

<li>
<p><tt class="LITERAL">disk</tt> - the repository maintains state and data on disk, but
also uses a memory cache.</p>
</li>

<li>
<p><tt class="LITERAL">reduced-fd</tt> - the repository maintains state and data on disk,
also uses a memory cache but uses significantly fewer File Descriptors. Normally a store
uses two File Descriptors per topic in addition to normal UM file descriptors for
transports and other objects. The reduced-fd repository type uses 5 File Descriptors for
the entire store, regardless of the number of topics, in addition to normal UM file
descriptors for transports and other objects. Use of this repository type may impact
performance.</p>
</li>
</ul>

<p>You can configure any combination of repository types within a single store
configuration.</p>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> If you run a store with all <tt class="LITERAL">disk</tt> or <tt
class="LITERAL">reduced-fd</tt>type repositories, then restart the store with memory type
repositories and do not clear out the <tt class="LITERAL">disk-cache-directory</tt> and
<tt class="LITERAL">disk-state-directory</tt>, the memory repositories revert
automatically to disk repositories.</p>
</blockquote>
</div>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> With <b class="APPLICATION">UMP</b> Version 5.3, the <b
class="APPLICATION">UMP</b> store daemon has Standard C++ Library dependencies for Unix
packages. The <tt class="LITERAL">libstdc++</tt> must also be included in
LD_LIBRARY_PATH. See <a href="../../DocIntro.html#CODE" target="doccontent">Section 3. Code</a>
for more infromation.</p>
</blockquote>
</div>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="STORE-FAULT-TOLERANCE" name="STORE-FAULT-TOLERANCE">3.2.2.
Persistent Store Fault Tolerance</a></h4>

<p>Sources and receivers register with a store and use individual repositories within the
store. Sources can use redundant repositories configured in multiple stores in either a
Round Robin or Quorum/Consensus arrangement for fault tolerance. Stores and repositories
have no indication of these arrangements.</p>

<p>The following diagram depicts an example Quorum/Consensus configuration of stores and
repositories. These stores could also be run by a single <tt
class="LITERAL">umestored</tt> daemon or one daemon for each store.</p>

<div class="FIGURE"><a id="UMPEXAMPLESTORECONFIG" name="UMPEXAMPLESTORECONFIG"></a>
<p><b>Figure 3. Example Store Configuration</b></p>

<p><img src="UMP_ExampleStoreConfig.png" align="CENTER" /></p>
</div>

<p>See <a href="#STORE-CONFIGURATION-CONSIDERATIONS"><i>Store Configuration
Considerations</i></a> and also <a href="#UMESTORED-STORES-ELEMENT"><i>Stores
Element</i></a> for more about store configuration.</p>
</div>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="QUEUING-ARCH" name="QUEUING-ARCH">3.3. Queuing
Architecture</a></h3>

<p>The architecture of Queues follows a lot of the same tenets as the <b
class="APPLICATION">UMP</b> persistence architecture. Source and receiver applications
can create sources, listen on topics and do normal operations typical of <b
class="APPLICATION">UM</b> applications. Receivers require no special configuration to
receive messages from a queue.</p>

<p>The central components to any queuing deployment are:</p>

<ul>
<li>
<p>the source applications</p>
</li>

<li>
<p>the receiving applications</p>
</li>

<li>
<p>the <tt class="LITERAL">umestored</tt> daemon, which provides queue instances</p>
</li>
</ul>

<p>The <tt class="LITERAL">umestored</tt> daemon provides separate Queue instances. Just
as <tt class="LITERAL">umestored</tt> may contain individual <b
class="APPLICATION">UMP</b> stores, it may also contain individual queue instances as
well.</p>

<div class="FIGURE"><a id="QUEUEARCH" name="QUEUEARCH"></a>
<p><b>Figure 4. Queuing Architecture</b></p>

<p><img src="UME_Queue_Arch.png" align="CENTER" /></p>
</div>
</div>
</div>

<div class="SECTION">
<hr />
<h2 class="SECTION"><a id="UME-OPS-OPERATIONAL-VIEW" name="UME-OPS-OPERATIONAL-VIEW">4.
Operational View</a></h2>

<p>This section discusses the following topics.</p>

<ul>
<li>
<p><a href="#PERSISTENCE-OPS"><i>Persistence Operations</i></a></p>
</li>

<li>
<p><a href="#UMP-RPPOPS"><i>Receiver-paced Persistence Operations</i></a></p>
</li>

<li>
<p><a href="#QUEUING-OPS"><i>Queuing Operations</i></a></p>
</li>

<li>
<p><a href="#ULB-OPS"><i>Ultra Load Balancing Operations</i></a></p>
</li>

<li>
<p><a href="#UME-OPS-UME-EVENTS"><i>UMP and UMQ Events</i></a></p>
</li>
</ul>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> If your application is running with the <b class="APPLICATION">UM</b>
configuration option, <a
href="../Config/requestnetworkoptions.html#CONTEXTREQUESTTCPBINDREQUESTPORT"
target="doccontent"><tt class="LITERAL">request_tcp_bind_request_port</tt></a> set to zero,
request port binding has been turned off, which also disables <b
class="APPLICATION">UMP</b> .</p>
</blockquote>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="PERSISTENCE-OPS" name="PERSISTENCE-OPS">4.1. Persistence
Operations</a></h3>

<p>Sources, receivers, and stores in <b class="APPLICATION">UMP</b> interact in very
controlled ways. This section illustrates the flow of network traffic between the
components during three modes of operation and also provides a reference of <b
class="APPLICATION">UMP</b> Events.</p>

<ul>
<li>
<p><a href="#UME-OPS-REGISTRATION"><i>Registration</i></a></p>
</li>

<li>
<p><a href="#UME-OPS-NORMAL-OPERATION"><i>Normal Operation</i></a></p>
</li>

<li>
<p><a href="#UME-OPS-RECEIVER-RECOVERY"><i>Receiver Recovery</i></a></p>
</li>
</ul>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UME-OPS-REGISTRATION" name="UME-OPS-REGISTRATION">4.1.1.
Registration</a></h4>

<p><a href="#UMEMESSAGESREGISTRATION">Figure 5</a> illustrates network flow during the
Registration process.</p>

<div class="FIGURE"><a id="UMEMESSAGESREGISTRATION" name="UMEMESSAGESREGISTRATION"></a>
<p><b>Figure 5. UMP Registration</b></p>

<p><img src="UMEMessagesRegistration.png" align="CENTER" /></p>
</div>

<p>Sources and receivers unicast registrations to the store. The store unicasts responses
back to the sources and receivers. Registrations are on a per topic per source basis.
Stores use RegIDs to identify sources and receivers. After registration, receivers may
handle recovery, sources may send data, and receivers may send acknowledgements</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UME-OPS-NORMAL-OPERATION"
name="UME-OPS-NORMAL-OPERATION">4.1.2. Normal Operation</a></h4>

<p><a href="#UMEMESSAGESDATA-ACK">Figure 6</a> illustrates the normal operation of data
reception and acknowledgement and also shows how <b class="APPLICATION">UMP</b> attains
<b class="APPLICATION"><span class="TRADEMARK">Parallel Persistence</span></b>. The
source sends message data to receivers and stores in parallel.</p>

<div class="FIGURE"><a id="UMEMESSAGESDATA-ACK" name="UMEMESSAGESDATA-ACK"></a>
<p><b>Figure 6. UMP Normal Operation</b></p>

<p><img src="UMEMessagesData-ACK.png" align="CENTER" /></p>
</div>

<ol type="1">
<li>
<p>Sources transmit data to receivers and stores at the same time over <b
class="APPLICATION">UM</b> multicast or unicast transport protocols.</p>
</li>

<li>
<p>As the store receives and persists messages, the store unicasts acknowledgements,
(message stability control messages), to the source letting it know of successful
reception and storage.</p>
</li>

<li>
<p>As receivers process and consume messages they unicast acknowledgments to the store
letting the store know of successful consumption of data.</p>
</li>

<li>
<p>If the source desires delivery confirmation, the receiver unicasts acknowledgements
directly to the source letting the source know of message consumption as well.</p>
</li>
</ol>

<p>Normal operation and recovery can proceed at the same time. In addition, as a receiver
consumes retransmitted messages, the receiver sends normal acknowledgements for
consumption and confirmed delivery (if requested by the source).</p>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> A store can be configured with different storage limits for each
repository. If the repository reaches this limit, the repository releases the oldest
message in order to persist a new message. This behavior occurs for a memory repository
as well as a disk repository. If a repository releases a message that one or more
receivers have not consumed (sent a consumption notification), the repository logs a
single warning message in the store log file per receiver per registration.</p>
</blockquote>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="UME-FLIGHT-SIZE" name="UME-FLIGHT-SIZE">4.1.2.1. <b
class="APPLICATION">UMP</b> Flight Size</a></h5>

<p><b class="APPLICATION">UMP</b> supports a flight size mechanism that tracks messages
in flight from a particular source and responds when a send would exceed the configured
flight size ( <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMEFLIGHTSIZE"
target="doccontent"><tt class="LITERAL">ume_flight_size</tt></a> and/or <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMEFLIGHTSIZEBYTES"
target="doccontent"><tt class="LITERAL">ume_flight_size_bytes</tt></a>). You can configure <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMEFLIGHTSIZEBEHAVIOR"
target="doccontent"><tt class="LITERAL">ume_flight_size_behavior</tt></a> to either:</p>

<ul>
<li>
<p>block any sends that would exceed the flight size or,</p>
</li>

<li>
<p>allow the sends while notifying your application.</p>
</li>
</ul>

<p><b class="APPLICATION">UMP</b> considers a sent message in flight until the following
two conditions are met.</p>

<ol type="1">
<li>
<p>The source receives the configured number of stability acknowledgements from the
store(s).</p>
</li>

<li>
<p>The source has received the configured number of delivery confirmation notifications.
(See <a href="../Config/config.html#SOURCEUMERETENTIONUNIQUECONFIRMATIONS"
target="doccontent"><tt class="LITERAL">ume_retention_unique_confirmations</tt></a>.)</p>
</li>
</ol>

<p>If configuring both <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMEFLIGHTSIZE"
target="doccontent"><tt class="LITERAL">ume_flight_size</tt></a> and <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMEFLIGHTSIZEBEHAVIOR"
target="doccontent"><tt class="LITERAL">ume_flight_size_behavior</tt></a>, <b
class="APPLICATION">UMP</b> uses the smaller of the two flight sizes on a per send
basis.</p>

<div class="INFORMALTABLE"><a id="AEN613" name="AEN613"></a>
<table border="1" class="CALSTABLE">
<col width="120" />
<col width="192" />
<col width="288" />
<thead>
<tr>
<th>ume_flight_size</th>
<th>ume_flight_size_bytes</th>
<th>Result</th>
</tr>
</thead>

<tbody>
<tr>
<td>Exceeded</td>
<td>Exceeded</td>
<td>ume_flight_size_behavior executes</td>
</tr>

<tr>
<td>Exceeded</td>
<td>Not Exceeded</td>
<td>ume_flight_size_behavior executes</td>
</tr>

<tr>
<td>Not Exceeded</td>
<td>Exceeded</td>
<td>ume_flight_size_behavior executes</td>
</tr>

<tr>
<td>Not Exceeded</td>
<td>Not Exceeded</td>
<td>No flight size sending restriction</td>
</tr>
</tbody>
</table>
</div>

<p>When using stores in a Quorum/Consensus configuration, <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMERETENTIONINTRAGROUPSTABILITYBEHAVIOR"
 target="doccontent">intragroup</a> and <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMERETENTIONINTERGROUPSTABILITYBEHAVIOR"
 target="doccontent">intergroup</a> stability settings affect whether <b
class="APPLICATION">UMP</b> considers a messages in flight. Consider a case with three
stores in a single QC group, and two receivers. Given the default configuration, until a
source receives a stability notification from two of the three stores, <b
class="APPLICATION">UMP</b> considers a given message in-flight. In addition, if you set
<a href="../Config/config.html#SOURCEUMERETENTIONUNIQUECONFIRMATIONS" target="doccontent"><tt
class="LITERAL">ume_retention_unique_confirmations</tt></a> to 2, that same message would
be considered in flight until the source receives two stability notifications AND two
delivery confirmation notifications. See also <a
href="#SOURCES-USING-QC-STORE-CONFIGURATION"><i>Sources Using Quorum/Consensus Store
Configuration</i></a>.</p>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> The <b class="APPLICATION">UMP</b> flight size mechanism operates on a
per message basis, not a per fragment basis.</p>
</blockquote>
</div>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> The <b class="APPLICATION">UMP</b> flight size bytes mechanism operates
with only payload data. <b class="APPLICATION">UM</b> or network overhead is not included
in the byte count.</p>
</blockquote>
</div>

<div class="SECTION">
<hr />
<h6 class="SECTION"><a id="UME-FLIGHT-SIZE-BLOCK" name="UME-FLIGHT-SIZE-BLOCK">4.1.2.1.1.
Blocking Message Sends That Exceed the Flight Size</a></h6>

<p>By default, when a source sends a message that exceeds it's flight size, the call to
send blocks. For example, suppose the flight size is set to 1. The first send completes
but before the source receives a stability notification or delivery confirmation, it
initiates a second call to send. If the source uses a blocking send, the send call blocks
until the first message stabilizes. If the source uses a non-blocking send, the send
returns an LBM_EWOULD_BLOCK.</p>
</div>

<div class="SECTION">
<hr />
<h6 class="SECTION"><a id="UME-FLIGHT-SIZE-NOTIFY"
name="UME-FLIGHT-SIZE-NOTIFY">4.1.2.1.2. Notification of Message Sends That Exceed the
Flight Size</a></h6>

<p>Alternatively, <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMEFLIGHTSIZEBEHAVIOR"
target="doccontent"><tt class="LITERAL">ume_flight_size_behavior</tt></a> can be set to notify
your application when a message send surpasses the flight size. A send that exceeds the
configured flight size succeeds and also triggers a flight size notification, indicating
that the flight size has been surpassed. Once the number of in-flight messages falls
below the configured flight size, another flight size notification source event is
triggered, this time, informing the application that the number of in-flight messages is
below the source's flight size.</p>
</div>
</div>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UME-OPS-RECEIVER-RECOVERY"
name="UME-OPS-RECEIVER-RECOVERY">4.1.3. Receiver Recovery</a></h4>

<p><a href="#UMEMESSAGESRECOVERY">Figure 7</a> illustrates receiver recovery.</p>

<div class="FIGURE"><a id="UMEMESSAGESRECOVERY" name="UMEMESSAGESRECOVERY"></a>
<p><b>Figure 7. UMP Messages Recovery</b></p>

<p><img src="UMEMessagesRecovery.png" align="CENTER" /></p>
</div>

<p>Receivers unicast retransmission requests. If the store has the message, it unicasts
the retransmission to the receiver. If it does not have the message and is configured to
forward the request to the source (See <tt
class="LITERAL">retransmission-request-forwarding</tt> in <a
href="#UMESTORED-TOPIC-OPTIONS"><i>Options for a Topic's ume-attributes Element</i></a>),
it unicasts the retransmission request to the source. If the source has the message, it
unicasts the retransmission directly to the receiver.</p>

<p><b class="APPLICATION">UM</b> sends retransmissions from a thread separate from the
main context thread so as not to impede live message data processing. The <tt
class="LITERAL">&lt;store&#62;</tt> configuration option, <tt
class="LITERAL">retransmission-request-processing-rate</tt>, sets the store's capacity to
process retransmission requests. The retransmission thread processes requests off a
retransmission queue which is set at 4 times the size of <tt
class="LITERAL">retransmission-request-processing-rate</tt>. The following <b
class="APPLICATION">UM</b> Web Monitor statistics record retransmission activity. See <b
class="APPLICATION">UM</b> Web Monitor <a href="#STORE-PAGE"><i>Store Page</i></a>.</p>

<ul>
<li>
<p>Retransmission requests received rate</p>
</li>

<li>
<p>Retransmission requests served rate</p>
</li>

<li>
<p>Retransmission requests dropped rate</p>
</li>

<li>
<p>Total retransmission requests dropped since store startup</p>
</li>
</ul>
</div>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="UMP-RPPOPS" name="UMP-RPPOPS">4.2. Receiver-paced Persistence
Operations</a></h3>

<p>Receiver-paced Persistence (RPP) refers to different message retention behavior for
designated receivers. You enable RPP with <b class="APPLICATION">UM</b> configuration
options. No special API calls are needed. RPP differs from <b
class="APPLICATION">UMP</b>'s default source-paced persistence in the following ways.</p>

<ul>
<li>
<p>The repository must be configured to allow RPP and sources and receivers must be
configured to request RPP behavior during registration.</p>
</li>

<li>
<p>Sources can modify specific repository configuration options that pertain to RPP.</p>
</li>

<li>
<p>The repository retains RPP messages until all RPP receivers acknowledge consumption.
The repository maintains an accurate count of all RPP receivers.</p>
</li>

<li>
<p>Late Joining receivers cannot receive all previously sent topic messages, only those
unconsumed by all RPP receivers. Late Joining receivers can always start at the current
message retained by the repository, defined as the earliest message not consumed by all
RPP receivers.</p>
</li>

<li>
<p>Sources must also configure their flight size in bytes, and optionally, in message
count. By using a total bytes flight size, the store can keep track of exactly how must
space it has available and not send stability acknowledgements if new messages would
exceed the available space, which would endanger the receipt of all messages by all RPP
receivers. See <a href="#UME-FLIGHT-SIZE"><i>UMP Flight Size</i></a>.</p>
</li>
</ul>

<p>In addition, a disk write delay interval for the repository, available for
Source-paced Persistence as well, improves performance by preventing unnecessary disk
activity.</p>

<p>This section discusses the following topics.</p>

<ul>
<li>
<p><a href="#RPP-REGISTRATION"><i>RPP Registration</i></a></p>
</li>

<li>
<p><a href="#UMP-RPPOPS-NORMAL-OPERATION"><i>RPP Normal Operations</i></a></p>
</li>

<li>
<p><a href="#RPP-MESSAGE-RECOVERY"><i>RPP Message Recovery</i></a></p>
</li>

<li>
<p><a href="#RPP-DEREGISTRATION"><i>RPP Deregistration</i></a></p>
</li>

<li>
<p><a href="#IMPLEMENTING-RPP"><i>Implementing RPP</i></a></p>
</li>

<li>
<p><a href="#EXAMPLE-RPP-CONFIG"><i>Example RPP Configuration Files</i></a></p>
</li>

<li>
<p><a href="#RPP-CROSS-FEATURE"><i>RPP Cross Feature Functionality</i></a></p>
</li>
</ul>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="RPP-REGISTRATION" name="RPP-REGISTRATION">4.2.1. RPP
Registration</a></h4>

<p>If a source sets <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMERECEIVERPACEDPERSISTENCE"
target="doccontent">ume_receiver_paced_persistence</a>, its topic becomes a RPP topic. When the
source registers with the store, the source's repository also becomes a RPP repository.
Receivers registering with a store on the RPP topic become RPP receivers.</p>

<div class="FIGURE"><a id="RPPREGISTRATION" name="RPPREGISTRATION"></a>
<p><b>Figure 8. RPP Registration</b></p>

<p><img src="UMP_RPP_Registration.png" align="CENTER" /></p>
</div>

<p>A source registration request includes the following.</p>

<ul>
<li>
<p>Designation of a RPP topic (LBMC_UME_PREG_FLAG_REGISTER flag)</p>
</li>

<li>
<p>Reconfigured repository configuration option values. Possible options are the 3
repository size options, <tt class="LITERAL">repository-allow-ack-on-reception</tt>, <tt
class="LITERAL">repository-disk-write-delay</tt> and <tt
class="LITERAL">source-flight-size-bytes-maximum</tt>.</p>
</li>

<li>
<p>Re-registration must request same configuration options or the store rejects the
request.</p>
</li>
</ul>

<p>Receiver registration request includes its designation as a RPP receiver
(LBMC_UME_PREG_FLAG_REGISTER flag).</p>

<p>The repository's registration response to both a source and a receiver acknowledges
RPP mode.</p>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="RPPLATEREGISTERINGRECEIVER"
name="RPPLATEREGISTERINGRECEIVER">4.2.1.1. Late Registering Receiver</a></h5>

<p>Late joining receivers that register after the first RPP topic message has been sent
cannot receive any messages sent prior to their registration, except for messages not yet
consumed by all RPP receivers. This behavior also applies to the very first receiver of a
RPP group that registers after the source sends the first message. Any messages published
prior to RPP receiver registration are not available for recovery.</p>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="RPPEARLYEXITINGRECEIVER"
name="RPPEARLYEXITINGRECEIVER">4.2.1.2. Early Exiting Receiver</a></h5>

<p>Should a registered receiver's activity timer expire and be declared by the repository
to be inactive, the repository retains all messages published since the receiver's last
acknowledged message (or initial sequence number if no messages were acknowledged) until
its receiver state lifetime expires and the repository deletes the receiver state
information. Deleting receiver state removes all knowledge of the receiver from the
repository. As a result, the repository also deletes all messages being held solely for
this receiver.</p>

<p>Should an early exiting receiver reregister (or otherwise become active) before the
expiration of its state lifetime, that receiver can recover all messages retained for
that receiver.</p>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="RPPCOMPATIBILITYMATRIX" name="RPPCOMPATIBILITYMATRIX">4.2.1.3.
UMP Version RPP Compatibility Matrix</a></h5>

<p>The following table indicates the result of registration requests across <b
class="APPLICATION">UMP</b> versions.</p>

<div class="INFORMALTABLE"><a id="AEN769" name="AEN769"></a>
<table border="1" class="CALSTABLE">
<col width="168" />
<col width="168" />
<col width="168" />
<col width="168" />
<thead>
<tr>
<th>Version/Object</th>
<th>Pre-ver. 5.3 Store</th>
<th>Ver. 5.3 RPP Store</th>
<th>Ver. 5.3 Non-RPP Store</th>
</tr>
</thead>

<tbody>
<tr>
<td>Pre 5.3 Source</td>
<td>Granted</td>
<td>Rejected *</td>
<td>Granted *</td>
</tr>

<tr>
<td>5.3 RPP Source</td>
<td>Granted - Source Error</td>
<td>Granted *</td>
<td>Rejected *</td>
</tr>

<tr>
<td>5.3 Non-RPP Source</td>
<td>Granted</td>
<td>Rejected *</td>
<td>Granted *</td>
</tr>

<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>

<tr>
<td>Pre 5.3 Receiver</td>
<td>Granted</td>
<td>Rejected</td>
<td>Granted</td>
</tr>

<tr>
<td>5.3 RPP Receiver</td>
<td>Granted - Receiver Error</td>
<td>Granted</td>
<td>Rejected</td>
</tr>

<tr>
<td>5.3 Non-RPP Receiver</td>
<td>Granted</td>
<td>Rejected</td>
<td>Granted</td>
</tr>
</tbody>
</table>
</div>

<ul>
<li>
<p><b class="APPLICATION">Granted - Source Error</b> indicates that the store granted the
registration but the source detected that RPP behavior was not acknowledged by the
store.</p>
</li>

<li>
<p><b class="APPLICATION">Granted - Receiver Error</b> indicates that the store granted
the registration but the receiver detected that RPP behavior was not acknowledged by the
store.</p>
</li>

<li>
<p><b class="APPLICATION">*</b> Refers only to the re-registration of a source with an
existing source repository because the source determines the repository's behavior for
new registrations.</p>
</li>
</ul>
</div>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UMP-RPPOPS-NORMAL-OPERATION"
name="UMP-RPPOPS-NORMAL-OPERATION">4.2.2. RPP Normal Operations</a></h4>

<p>Since all RPP receivers must receive all messages, message overruns at the store or
receiver must be prevented by regulating the sending pace of the source. The store uses
the source's flight size (bytes) to regulate the source's speed, by withholding stability
acknowledgements if the repository does not have at least one flight size available.</p>

<ol type="1">
<li>
<p>Sources transmit data to receivers and store repositories at the same time over <b
class="APPLICATION">UM</b> multicast or unicast transport protocols.</p>
</li>

<li>
<p>When a disk repository receives a message, it holds the message in memory cache before
it writes the message to disk. The repository sends a stability notification to the
source after it writes the message to disk. Memory repositories send the stability notice
upon reception. See also Acknowledge on Reception and Receiver Acknowledgement and Flight
Size below.</p>

<div class="FIGURE"><a id="RPPSTABILITYACK" name="RPPSTABILITYACK"></a>
<p><b>Figure 9. RPP Stability Acknowledgement</b></p>

<p><img src="UMP_RPP_Stability.png" align="CENTER" /></p>
</div>
</li>

<li>
<p>If the source desires delivery confirmation, receivers unicast acknowledgements
directly to the source letting the source know of message consumption as well.</p>
</li>
</ol>

<p>The following also affect when a repository sends a stability acknowledgement to the
source.</p>

<ul>
<li>
<p><b class="APPLICATION">Acknowledge on Reception</b> - If you configure the repository
for <tt class="LITERAL">repository-allow-ack-on-reception</tt> and the source also sets
<a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMEREPOSITORYACKONRECEPTION"
target="doccontent"><tt class="LITERAL">ume_repository_ack_on_reception</tt></a>, the
repository sends a stability acknowledgement to the source immediately upon reception. If
the disk write has not already been initiated, <b class="APPLICATION">UMP</b> does not
write the message to disk.</p>

<div class="FIGURE"><a id="RPPACKRECEPTION" name="RPPACKRECEPTION"></a>
<p><b>Figure 10. RPP Acknowledge on Reception</b></p>

<p><img src="UMP_RPP_AckReception.png" align="CENTER" /></p>
</div>
</li>

<li>
<p><b class="APPLICATION">Receiver Acknowledgement</b> - If a repository receives
acknowledgements from all receivers before writing the message to disk, it immediately
sends a stability acknowledgement to the source. If the disk write has not already been
initiated, <b class="APPLICATION">UMP</b> does not write the message to disk.</p>

<div class="FIGURE"><a id="RPPRECVACK" name="RPPRECVACK"></a>
<p><b>Figure 11. RPP Receiver Acknowledgement</b></p>

<p><img src="UMP_RPP_RecvAck.png" align="CENTER" /></p>
</div>
</li>

<li>
<p><b class="APPLICATION">Write Delay</b> - The repository option,
repository-disk-write-delay, allows the repository to hold messages in memory cache
longer before persisting them to disk. This delay increases the probability that all RPP
receivers acknowledge message consumption, eliminating the need to persist the message to
disk.</p>
</li>

<li>
<p><b class="APPLICATION">Flight size</b> - A disk repository only sends stability
acknowledgement to the source if its memory cache has at least one flight size (in both
messages and bytes) available. A memory repository also sends stability acknowledgement
if it has at least one flight size (in both messages and bytes) available. A lack of
available space in the repository blocks the source until the repository reclaims the
necessary storage space and sends a stability acknowledgement.</p>
</li>
</ul>

<p>For memory store repositories, the behaviors Acknowledge on Reception, Receiver
Acknowledgement and Write Delay do not apply.</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="RPP-MESSAGE-RECOVERY" name="RPP-MESSAGE-RECOVERY">4.2.3. RPP
Message Recovery</a></h4>

<p>An RPP source repository retains messages until all RPP receivers acknowledge receipt
of the message. Therefore an RPP receiver can only recover messages that have not been
consumed by all RPP receivers. It is important to note that an RPP receiver joining after
other RPP receivers have already joined and after messages have already been sent can
only be guaranteed to recover messages sent subsequent to its joining.</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="RPP-DEREGISTRATION" name="RPP-DEREGISTRATION">4.2.4. RPP
Deregistration</a></h4>

<p>You can deregister either sources or receivers using deregistration APIs, (<code
class="FUNCTION">lbm_src_ume_deregistration()</code>, <code
class="FUNCTION">lbm_rcv_ume_deregistration()</code> and <code
class="FUNCTION">lbm_wrcv_ume_deregistration()</code>). <b class="APPLICATION">UM</b>
deletes the state of deregistered objects. If you deregister a RPP receiver, <b
class="APPLICATION">UMP</b> automatically updates the number of receiver acknowledgements
required to maintain RPP behavior. The store issues Deregistration Successful events for
every source or receiver that deregisters. See <a href="#UME-OPS-UME-EVENTS"><i>UMP and
UMQ Events</i></a>.</p>

<p>Applications should be cautious about using the deregistration APIs to deregister RPP
sources or receivers. These APIs can be disruptive to RPP.</p>

<ul>
<li>
<p><code class="FUNCTION">lbm_src_ume_deregistration()</code> also deletes any persisted
RPP messages in the source's repository. A source application should only use <code
class="FUNCTION">lbm_src_ume_deregistration()</code> if it uses delivery confirmation
from the receiver and it knows all messages have been delivered. The source is blocked
after deregistering and and must restart in order to register again with the RPP
store.</p>
</li>

<li>
<p>Deregistering an RPP receiver with <code
class="FUNCTION">lbm_rcv_ume_deregistration()</code> removes the receiver from the list
of RPP receivers maintained by the repository. It is no longer part of the persistence
operation, but is a valid <b class="APPLICATION">UM</b> receiver, able to receive
messages, but unable to acknowledge message consumption to the repository. Any messages
not yet confirmed for that receiver are unrecoverable. The receiver must restart in order
to register again with the RPP repository.</p>
</li>

<li>
<p>Deregistering an RPP wildcard receiver with <code
class="FUNCTION">lbm_wrcv_ume_deregistration()</code> deregisters all individual topic
receivers receiving messages on topics that match the wildcard pattern. Individual topic
receivers can still receive messages after deregistering, but cannot acknowledge message
consumption. The wildcard receiver must restart in order to register again with the RPP
store.</p>
</li>
</ul>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="IMPLEMENTING-RPP" name="IMPLEMENTING-RPP">4.2.5. Implementing
RPP</a></h4>

<p>Follow the procedure below to configure Receiver-paced Persistence.</p>

<ol type="1">
<li>
<p>Set <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMERECEIVERPACEDPERSISTENCE"
target="doccontent"><tt class="LITERAL">ume_receiver_paced_persistence</tt></a> for sources and
receivers in a <b class="APPLICATION">UM</b> configuration file. If only certain sources
or receivers in a context are RPP, use <code class="FUNCTION">lbm_*setopt()</code>l in
the source or receiver application or use <b class="APPLICATION"><span
class="TRADEMARK">Ultra Messaging</span></b> <b class="APPLICATION">Manager</b> to
specify RPP in an <b class="APPLICATION">UM</b> XML configuration file.</p>
</li>

<li>
<p>Set <tt class="LITERAL">repository-allow-receiver-paced-persistence</tt> = 1 for the
repository in the <tt class="LITERAL">umestored</tt> XML configuration file.</p>
</li>

<li>
<p>Coordinate <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMEFLIGHTSIZEBYTES"
target="doccontent"><tt class="LITERAL">ume_flight_size_bytes</tt></a> between the repository
and the source. Set the maximum flight size with the repository option, <tt
class="LITERAL">source-flight-size-bytes-maximum</tt>. Sources can reconfigure the
repository's <tt class="LITERAL">source-flight-size-bytes-maximum</tt> to a value less
than or equal to the maximum.</p>
</li>

<li>
<p><b class="APPLICATION">Optional.</b> Coordinate the <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMEREPOSITORYACKONRECEPTION"
target="doccontent"><tt class="LITERAL">ume_repository_ack_on_reception</tt></a> between the
repository and the source. If the repository has <tt
class="LITERAL">repository-allow-ack-on-reception</tt> enabled (1), the source can choose
to keep it enabled or turn it off ( <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMEREPOSITORYACKONRECEPTION"
target="doccontent"><tt class="LITERAL">ume_repository_ack_on_reception</tt></a> = 0). If the
repository has <tt class="LITERAL">repository-allow-ack-on-reception</tt> disabled (0),
the source cannot turn it on.</p>
</li>

<li>
<p><b class="APPLICATION">Optional.</b> If the repository is a disk repository
(repository-type = <tt class="LITERAL">disk</tt> or <tt class="LITERAL">reduced-fd</tt>),
set the maximum write delay with the repository option, <tt
class="LITERAL">repository-disk-write-delay</tt>. Sources can reconfigure the
repository's <tt class="LITERAL">repository-disk-write-delay</tt> to a value less than or
equal to the maximum configured for the repository with <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMEWRITEDELAY"
target="doccontent"><tt class="LITERAL">ume_write_delay</tt></a>.</p>
</li>

<li>
<p><b class="APPLICATION">Optional.</b> Coordinate repository size options between the
source and repository. If you wish to use the repository's values, you do not need to
configure source configuration values. The repository sets a maximum for these three
options. The source can reconfigure the repository's options with values less than or
equal to the maximum configured for the repository using the following <b
class="APPLICATION">UM</b> configuration options.</p>

<ul>
<li>
<p><a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMEREPOSITORYSIZETHRESHOLD"
target="doccontent"><tt class="LITERAL">ume_repository_size_threshold</tt></a></p>
</li>

<li>
<p><a href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMEREPOSITORYSIZELIMIT"
target="doccontent"><tt class="LITERAL">ume_repository_size_limit</tt></a></p>
</li>

<li>
<p><a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMEREPOSITORYDISKFILESIZELIMIT"
 target="doccontent"><tt class="LITERAL">ume_repository_disk_file_size_limit</tt></a></p>
</li>
</ul>
</li>
</ol>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="EXAMPLE-RPP-CONFIG" name="EXAMPLE-RPP-CONFIG">4.2.6. Example
RPP Configuration Files</a></h4>

<p>The sample configuration files shown below show how a store configuration file
establishes certain RPP option values and the source can reconfigure them via a <b
class="APPLICATION">UM</b> configuration file. Although only two files appear below, this
configuration represents two, single-store quorum/consensus groups and one <b
class="APPLICATION">UM</b> context. A second <tt class="LITERAL">umestored</tt>
configuration file would be required for the store <tt class="LITERAL">store1rpp</tt>
containing options and values identical to <tt class="LITERAL">store0rpp</tt>.</p>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="EXAMPLE-RPP-CONFIG-UM" name="EXAMPLE-RPP-CONFIG-UM">4.2.6.1.
UM Configuration File</a></h5>

<p>The following example <b class="APPLICATION">UM</b> configuration file contains RPP
options in the <tt class="LITERAL">##Persistence Options###</tt> section.</p>

<ul>
<li>
<p>The source uses the same repository size values as the store. In this case, you do not
need to specify these option values again in the source's <b class="APPLICATION">UM</b>
Configuration File. They appear in this file for the sake of completeness.</p>
</li>

<li>
<p>The source reconfigures ume_flight_size_bytes to 1,000,000 bytes, which is less than
the repository's 4 MB default. (The source can reconfigure this option to a value less
than or equal to the repository's configured value.)</p>
</li>

<li>
<p>The source reconfigures ume_write_delay from the default of 0 ms to 1000 ms or 1
second.</p>
</li>

<li>
<p>The option, ume_session_id 5353, is commented out because this file specifies RegIDs
2929 and 2930, respectively, for the stores in the <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMESTORENAME"
target="doccontent"><tt class="LITERAL">ume_store_name</tt></a> option. The option, <a
href="../Config/ultramessagingpersistenceoptions.html#CONTEXTUMESESSIONID"
target="doccontent"><tt class="LITERAL">ume_session_id</tt></a>, appears in this file as a
reminder that you can use either RegIDs or Session IDs, but not both.</p>
</li>
</ul>

<pre class="PROGRAMLISTING">
#Sample UM Configuration File, UMP Version 5.3
#Major Options
source transport lbtrm
# in order and reassembled
receiver ordered_delivery 1
#Multicast Resolver Network Options
context resolver_multicast_address 225.8.17.29
context resolver_multicast_interface 10.29.3.0/24
# Transport LBT-RM Netowrk Options
source transport_lbtrm_multicast_address 225.8.17.30
context transport_lbtrm_multicast_address_low 225.12.17.10
context transport_lbtrm_multicast_address_high 225.12.17.14
#Transport LBT-RM Operation Options
context transport_lbtrm_data_rate_limit 10000000
context transport_lbtrm_retransmit_rate_limit 5000000
# Transport LBT-RM Reliability Options
receiver transport_lbtrm_nak_initial_backoff_interval 40000
receiver transport_lbtrm_nak_initial_backoff_interval 500
receiver transport_lbtrm_nak_generation_interval 10000
##Turn off NAKs
receiver transport_lbtrm_send_naks 0
#Request Network Options
context request_tcp_port_low 55000
context request_tcp_port_high 55500

## Persistence Options ###
source ume_store_group 0:1
source ume_store_name store0rpp:2929:0
source ume_store_group 1:1
source ume_store_name store1rpp:2930:1
source ume_store_behavior qc
source ume_flight_size 500
source ume_flight_size_bytes 1000000
source ume_receiver-paced-persistence 1
source ume_repository_size_threshold 104857600
source ume_repository_size_limit 209715200
source ume_repository_disk_file_size_limit 1073741824
source ume_repository_ack_on_reception 1
source ume_write_delay 1000
receiver ume_receiver-paced-persistence 1
receiver ume_explicit_ack_only 1
source ume_proxy_source 1
#source ume_session_id 535353
context ume_source_liveness_timeout 4000
context ume_receiver_liveness_interval 1000
source ume_confirmed_delivery_notification 1
                   
</pre>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="EXAMPLE-RPP-CONFIG-UMESTORED"
name="EXAMPLE-RPP-CONFIG-UMESTORED">4.2.6.2. umestored Configuration File</a></h5>

<p>The following example store configuration file contains RPP options in the ABC* topic
section.</p>

<ul>
<li>
<p>The store has raised the <tt class="LITERAL">repository-size-limit</tt> from the
default of 48 MB to 200 MB, the <tt class="LITERAL">repository-size-threshold</tt> from
the default of 0 to 100 MB, and the <tt
class="LITERAL">repository-disk-file-size-limit</tt> from the default of 100MB to 1
GB.</p>
</li>

<li>
<p>The store does not specify a <tt
class="LITERAL">source-flight-size-bytes-maximum</tt>, using the default of 4 MB.</p>
</li>
</ul>

<pre class="PROGRAMLISTING">
&lt;?xml version="1.0"?&#62;
&lt;ume-store version="1.2"&#62;
  &lt;daemon&#62;
    &lt;log&#62;/configs/stores/umestored1/umestored.log&lt;/log&#62;
    &lt;lbm-license-file&#62;/bin/umq_exp_license.txt&lt;/lbm-license-file&#62; 
    &lt;lbm-license-file&#62;/bin/lbm_ume_umq_udx_rdma_license.txt&lt;/lbm-license-file&#62; 
    &lt;lbm-config&#62;/configs/lbm_4_store.cfg&lt;/lbm-config&#62;
    &lt;pidfile&#62;/configs/stores/umestored1/umestored.pid&lt;/pidfile&#62;
    &lt;web-monitor&#62;*:15404&lt;/web-monitor&#62;
  &lt;/daemon&#62;
  &lt;stores&#62;
    &lt;store name="rpp-ump-test-store-1" port="14667"&#62;
      &lt;ume-attributes&#62;
        &lt;option type="store" name="disk-cache-directory" value="/stores/store1/cache"/&#62;
        &lt;option type="store" name="disk-state-directory" value="/stores/store1/state"/&#62;  
        &lt;option type="store" name="allow-proxy-source" value="0" /&#62;
        &lt;option type="store" name="context-name" value="store1rpp"/&#62;
      &lt;/ume-attributes&#62;
      &lt;topics&#62;
        &lt;topic pattern="ABC*" type="PCRE"&#62;
          &lt;ume-attributes&#62;
             &lt;option type="store" name="repository-allow-receiver-paced-persistence" value="1"/&#62;
             &lt;option type="store" name="repository-type" value="disk"/&#62;
             &lt;option type="store" name="repository-size-threshold" value="104857600"/&#62;
             &lt;option type="store" name="repository-size-limit" value="209715200"/&#62;
             &lt;option type="store" name="repository-disk-file-size-limit" value="1073741824"/&#62;
             &lt;option type="store" name="repository-allow-ack-on-reception" value="1"/&#62;
             &lt;option type="store" name="repository-disk-write-delay" value="1000"/&#62; 
             &lt;option type="store" name="receiver-new-registration-rollback" value="0"/&#62;
             &lt;option type="store" name="source-activity-timeout" value="120000"/&#62;
             &lt;option type="store" name="receiver-activity-timeout" value="30000"/&#62;
             &lt;option type="store" name="retransmission-request-forwarding" value="0"/&#62;
          &lt;/ume-attributes&#62;
        &lt;/topic&#62;
      &lt;/topics&#62;
    &lt;/store&#62;
  &lt;/stores&#62;
&lt;/ume-store&#62;
                   
</pre>
</div>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="RPP-CROSS-FEATURE" name="RPP-CROSS-FEATURE">4.2.7. RPP Cross
Feature Functionality</a></h4>

<p></p>

<div class="INFORMALTABLE"><a id="AEN1001" name="AEN1001"></a>
<table border="1" class="CALSTABLE">
<col width="144" />
<col width="96" />
<col width="216" />
<thead>
<tr>
<th><b class="APPLICATION">UM</b> Feature</th>
<th>Supported</th>
<th>Notes</th>
</tr>
</thead>

<tbody>
<tr>
<td><b class="APPLICATION">UMP</b> Proxy Sources</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>

<tr>
<td><b class="APPLICATION">UM</b> Gateway</td>
<td>No</td>
<td>Source-paced Persistence and Receiver-paced Persistence are currently not supported
over a <b class="APPLICATION">UM</b> Gateway.</td>
</tr>

<tr>
<td><b class="APPLICATION">UM</b> Transports</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>

<tr>
<td>Multi-Transport Threads</td>
<td>No</td>
<td>&nbsp;</td>
</tr>

<tr>
<td>Off-Transport Recovery</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>

<tr>
<td>Late Join</td>
<td>Yes</td>
<td>With the new store option, Acknowledge on Reception, sources may not retain
sufficient sent messages to provide an effective Late Join capability.</td>
</tr>

<tr>
<td>HF</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>

<tr>
<td>HFX</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>

<tr>
<td>Wildcard Receivers</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>

<tr>
<td>Message Batching</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>

<tr>
<td>Ordered Delivery</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>

<tr>
<td>Request/Response</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>

<tr>
<td>Multicast Immediate Messaging (MIM)</td>
<td>No</td>
<td>MIM messages are not persisted and have no impact on RPP.</td>
</tr>

<tr>
<td>Source Side Filtering</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>

<tr>
<td>Self-Describing Messaging (SDM)</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>

<tr>
<td>Pre-Defined Messaging (PDM)</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>

<tr>
<td><b class="APPLICATION">UM</b> Spectrum</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>

<tr>
<td>Monitoring/Statistics</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>

<tr>
<td>Acceleration - DBL</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>

<tr>
<td>Acceleration - UD</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>

<tr>
<td>Implicit/Explicit Acknowledgements</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>

<tr>
<td>Registration ID/Session Management</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>

<tr>
<td>Fault Tolerance - Round Robin</td>
<td>No</td>
<td>If a RPP source attempts to register to a source repository configured for Round
Robin fault tolerance, lbm_src_create() returns an error.</td>
</tr>

<tr>
<td>Fault Tolerance - Quorum Consensus</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>

<tr>
<td><b class="APPLICATION">UM</b> SNMP Agent</td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>

<tr>
<td><b class="APPLICATION"><span class="TRADEMARK">Ultra Messaging</span></b> <b
class="APPLICATION">Manager</b></td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>

<tr>
<td><b class="APPLICATION"><span class="TRADEMARK">Ultra Messaging</span></b> <b
class="APPLICATION">Cache</b></td>
<td>Yes</td>
<td>&nbsp;</td>
</tr>

<tr>
<td><b class="APPLICATION"><span class="TRADEMARK">Ultra Messaging</span></b> <b
class="APPLICATION">Desktop Services</b></td>
<td>No</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="QUEUING-OPS" name="QUEUING-OPS">4.3. Queuing
Operations</a></h3>

<p>The communication between source and receiver applications and <b
class="APPLICATION">UMQ</b> instances follow many of the same patterns as the
communication within <b class="APPLICATION">UMP</b> persistence applications. However to
reduce the configuration of queue sources and receivers, some Queue-specific activities
such as registration or queue resolution operate automatically and become active when the
following two conditions occur.</p>

<ol type="1">
<li>
<p>The <b class="APPLICATION">UM</b> Configuration file contains the option, <a
href="../Config/ultramessagingqueuingoptions.html#SOURCEUMQQUEUENAME"
target="doccontent">umq_queue_name</a>.</p>
</li>

<li>
<p>A <tt class="LITERAL">umestored</tt> is running configured for queuing. A queue
specification contains not only queue information, but also the application sets
receiving queue messages along with the topics being sent to the queue.</p>
</li>
</ol>

<p>This section discusses the following topics.</p>

<ul>
<li>
<p><a href="#Q-REGISTRATION-ASSIGNMENT"><i>Registration and Assignment</i></a></p>
</li>

<li>
<p><a href="#MESSAGE-PATHS"><i>Message Paths</i></a></p>
</li>

<li>
<p><a href="#QUEUE-FEEDBACK"><i>Queue Feedback</i></a></p>
</li>

<li>
<p><a href="#QUEUE-FLIGHT-SIZE"><i>UMQ Flight Size</i></a></p>
</li>

<li>
<p><a href="#TOPICS-QUEUES"><i>Topics and Queues</i></a></p>
</li>

<li>
<p><a href="#QUEUE-RES"><i>Queue Resolution</i></a></p>
</li>
</ul>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="Q-REGISTRATION-ASSIGNMENT"
name="Q-REGISTRATION-ASSIGNMENT">4.3.1. Registration and Assignment</a></h4>

<p>Source and receiver applications in a queuing operation use the same registration and
registration response behaviors as sources and receivers in a persistence operation. (See
<a href="#UMEMESSAGESREGISTRATION"><i>UMP Registration</i></a>.) The contents of the
actual messages for registration and registration response for queues are slightly
different, but the message paths are essentially the same.</p>

<p>After a receiver registers with a Queue, the Queue issues an Assignment ID, which
identifies the receiver. The Queue assigns this ID to all messages queued for the
receiver's topic. The Assignment feature implements the OAOO delivery feature. The Queue
assigns messages to a receiver after any one of the following events.</p>

<ul>
<li>
<p>A message arrives at the Queue. (If no receiver interested in the topic has
registered, the Queue holds the message until a receiver interested in the message's
topic registers with the Queue.)</p>
</li>

<li>
<p>A receiver registers with the Queue. (Obviously, the Queue must possess messages for
the receiver's topic.)</p>
</li>

<li>
<p>The Queue receives a Consumption Report from a receiver.</p>
</li>
</ul>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="SOURCE-REG" name="SOURCE-REG">4.3.1.1. Source Application
Registration</a></h5>

<p>At a high level, the following registration activity occurs before a source
application submits messages to a queue topic.</p>

<ol type="1">
<li>
<p><a href="../Config/ultramessagingqueuingoptions.html#SOURCEUMQQUEUENAME"
target="doccontent">umq_queue_name</a> must be set for queue <span class="emphasis"><i
class="EMPHASIS">Q1</i></span>.</p>
</li>

<li>
<p><tt class="LITERAL">umestored</tt> must be started and configured for queue <span
class="emphasis"><i class="EMPHASIS">Q1</i></span> and topic <span class="emphasis"><i
class="EMPHASIS">SubjectA</i></span>.</p>
</li>

<li>
<p>The source application creates a source object for topic <span class="emphasis"><i
class="EMPHASIS">SubjectA</i></span>.</p>
</li>

<li>
<p>The source application's context automatically registers with <span
class="emphasis"><i class="EMPHASIS">Q1</i></span> if not already registered.</p>
</li>

<li>
<p>The Queue sends a <tt class="LITERAL">Queue Registration Complete</tt> context event
to the source application.</p>
</li>

<li>
<p>The source object automatically registers as <span class="emphasis"><i
class="EMPHASIS">SubjectA</i></span> with <span class="emphasis"><i
class="EMPHASIS">Q1</i></span>.</p>
</li>

<li>
<p>The Queue sends a <tt class="LITERAL">Queue Registration Complete</tt> source event to
the source application.</p>
</li>
</ol>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="RECEIVER-REG" name="RECEIVER-REG">4.3.1.2. Receiver
Application Registration</a></h5>

<p>At a high level, the following registration activity occurs before a receiver
application can receive queue topic messages.</p>

<ol type="1">
<li>
<p><tt class="LITERAL">umestored</tt> must be started and configured for queue <span
class="emphasis"><i class="EMPHASIS">Q1</i></span> and topic <span class="emphasis"><i
class="EMPHASIS">SubjectA</i></span>.</p>
</li>

<li>
<p>The receiver application creates a receiver object for topic <span class="emphasis"><i
class="EMPHASIS">SubjectA</i></span>.</p>
</li>

<li>
<p>The receiver discovers through topic resolution that <span class="emphasis"><i
class="EMPHASIS">Q1</i></span> has messages for topic <span class="emphasis"><i
class="EMPHASIS">SubjectA</i></span>. (Topic advertisements in a queuing operation
contain the queue name.)</p>
</li>

<li>
<p>The receiver application's context automatically registers with <span
class="emphasis"><i class="EMPHASIS">Q1</i></span> if not already registered.</p>
</li>

<li>
<p>The Queue sends a <tt class="LITERAL">Queue Context Registration Complete</tt> message
to the receiver application after the receiver application's context registers.</p>
</li>

<li>
<p>The receiver object automatically registers as <span class="emphasis"><i
class="EMPHASIS">SubjectA</i></span> with <span class="emphasis"><i
class="EMPHASIS">Q1</i></span> If not using <b class="APPLICATION">UMQ</b> Sessions IDs,
the receiver includes its <tt class="LITERAL">Assignment ID</tt> with the registration
request.</p>
</li>

<li>
<p>The Queue sends a <tt class="LITERAL">Queue Receiver Registration Complete</tt>
message to the receiver application. If using <b class="APPLICATION">UMQ</b> Sessions
IDs, the Queue includes the receiver's <tt class="LITERAL">Assignment ID</tt> with the
registration complete message.</p>
</li>
</ol>
</div>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="MESSAGE-PATHS" name="MESSAGE-PATHS">4.3.2. Message
Paths</a></h4>

<p>Depending on the data dissemination model in use, the messaging paths between sources,
receivers, and queue instances may vary quite a bit.</p>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="SQD" name="SQD">4.3.2.1. Serial Queue Dissemination
(SQD)</a></h5>

<p>The Serial Queue Dissemination (SQD) model (<a href="#SQD-DIAGRAM"><i>Serial Queue
Dissemination (SQD)</i></a>) uses direct serial unicast from the queue to the individual
receivers. Receivers only receive the messages they are assigned to process. The term
<span class="emphasis"><i class="EMPHASIS">serial</i></span> indicates that the queue
sends each message via unicast only to the message's assigned receivers (one in each
application set). This dissemination model creates less work for receivers than either
PQD or SD, which require receivers to decipher control information to determine the
messages they must consume.</p>

<div class="FIGURE"><a id="SQD-DIAGRAM" name="SQD-DIAGRAM"></a>
<p><b>Figure 12. Serial Queue Dissemination (SQD)</b></p>

<p><img src="UMQ-SQD-multi-appsets.png" align="CENTER" /></p>
</div>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="PQD" name="PQD">4.3.2.2. Parallel Queue Dissemination
(PQD)</a></h5>

<p>The Parallel Queue Dissemination (PQD) model (<a href="#PQD-DIAGRAM"><i>Parallel Queue
Dissemination (PQD)</i></a>) uses normal <b class="APPLICATION">UM</b> transport sessions
to disseminate messages. In fact, the queue uses individual <b class="APPLICATION">UM</b>
topics to send messages to all receivers. In addition, the Queue sends control
information (Receiver Control Record - RCR) over a specific topic, configured with the
<tt class="LITERAL">control-topic-name</tt> Queue option in the Queue's XML configuration
file. (See <a href="#UMESTORED-QUEUE-ELEMENT"><i>Queue Element</i></a>. Receivers listen
to all data and control information and deliver all their assigned messages to the
application, ignoring all other messages.</p>

<div class="FIGURE"><a id="PQD-DIAGRAM" name="PQD-DIAGRAM"></a>
<p><b>Figure 13. Parallel Queue Dissemination (PQD)</b></p>

<p><img src="UMQ-PQD.png" align="CENTER" /></p>
</div>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="SD" name="SD">4.3.2.3. Source Dissemination (SD)</a></h5>

<p>The <a href="#SD-DIAGRAM"><i>Source Dissemination (SD)</i></a> model also uses normal
<b class="APPLICATION">UM</b> transport sessions from source application to send message
data to the receivers. The queue sends control information (Receiver Control Record -
RCR) as in the PQD model that instructs receivers via assignments what to process and
what to ignore. However, the queue does not send data messages on topics.</p>

<div class="FIGURE"><a id="SD-DIAGRAM" name="SD-DIAGRAM"></a>
<p><b>Figure 14. Source Dissemination (SD)</b></p>

<p><img src="UMQ-SD.png" align="CENTER" /></p>
</div>
</div>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="QUEUE-FEEDBACK" name="QUEUE-FEEDBACK">4.3.3. Queue
Feedback</a></h4>

<p>Receiver applications as well as queue instances provide various forms of feedback.
Queue instances send Stability Acknowledgements directly back to <b
class="APPLICATION">UMQ</b> source applications to indicate successful submission of
messages to the queue. Receiver applications signal message consumption by sending
Consumption Reports back to the queue instances. See <a
href="#QUEUE-FEEDBACK-DIAGRAM"><i>Queue Feedback</i></a>.</p>

<div class="FIGURE"><a id="QUEUE-FEEDBACK-DIAGRAM" name="QUEUE-FEEDBACK-DIAGRAM"></a>
<p><b>Figure 15. Queue Feedback</b></p>

<p><img src="UMQ-Feedback.png" align="CENTER" /></p>
</div>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="QUEUE-FLIGHT-SIZE" name="QUEUE-FLIGHT-SIZE">4.3.4. <b
class="APPLICATION">UMQ</b> Flight Size</a></h4>

<p><b class="APPLICATION">UMQ</b> supports a flight size mechanism similar to <a
href="#UME-FLIGHT-SIZE"><i>UMP Flight Size</i></a> that tracks messages in flight from a
particular source and responds when a send would exceed the configured flight size (<a
href="../Config/ultramessagingqueuingoptions.html#SOURCEUMQFLIGHTSIZE"
target="doccontent">umq_flight_size</a>). You can configure <a
href="../Config/ultramessagingqueuingoptions.html#SOURCEUMQFLIGHTSIZEBEHAVIOR"
target="doccontent">umq_flight_size_behavior</a> to either:</p>

<ul>
<li>
<p>block any sends that would exceed the flight size or,</p>
</li>

<li>
<p>allow the sends while notifying your application.</p>
</li>
</ul>

<p><b class="APPLICATION">UMQ</b> considers a sent message in-flight until the source
receives the configured number of stability acknowledgements from the queue(s). (No
delivery confirmation exists in <b class="APPLICATION">UMQ</b>.) As with <b
class="APPLICATION">UMP</b> Quorum/Consensus, <a
href="../Config/ultramessagingqueuingoptions.html#SOURCEUMQRETENTIONINTRAGROUPSTABILITYBEHAVIOR"
 target="doccontent">intragroup</a> and <a
href="../Config/ultramessagingqueuingoptions.html#SOURCEUMQRETENTIONINTERGROUPSTABILITYBEHAVIOR"
 target="doccontent">intergroup</a> stability settings affect whether <b
class="APPLICATION">UMQ</b> considers a messages in flight.</p>

<p><b class="APPLICATION">UMQ</b> also supports a flight size mechanism for Multicast
Immediate Messages (MIM). You configure MIM flight size with the context scope
configuration options, <a
href="../Config/ultramessagingqueuingoptions.html#CONTEXTUMQFLIGHTSIZE"
target="doccontent">(context) umq_flight_size</a> and <a
href="../Config/ultramessagingqueuingoptions.html#CONTEXTUMQFLIGHTSIZEBEHAVIOR"
target="doccontent">(context) umq_flight_size_behavior</a>.</p>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> A source can be configured to publish via <b class="APPLICATION">UMP</b>
and <b class="APPLICATION">UMQ</b>. In either of these cases, flight sizes and behaviors
can be configured differently with the appropriate configuration options. If a source
publishes via both <b class="APPLICATION">UMP</b> and <b class="APPLICATION">UMQ</b> and
the flight size behaviors for each are set to block, a send that exceeds <b
class="APPLICATION">either</b> flight size will block.</p>
</blockquote>
</div>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="TOPICS-QUEUES" name="TOPICS-QUEUES">4.3.5. Topics and
Queues</a></h4>

<p>Sources send messages on topics and receivers listen on topics for messages.
Similarly, <b class="APPLICATION">UMQ</b> source applications submit messages to queues
with each message being sent on a specific topic. <b class="APPLICATION">UMQ</b> receiver
applications listen on topics for messages. This means that Application Sets and the
once-and-only-once (OAOO) behavior are on a per topic basis. A potentially helpful
analogy is a queue may be the name of a mailbox and a topic may be the subject of an
individual letter.</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="QUEUE-RES" name="QUEUE-RES">4.3.6. Queue Resolution</a></h4>

<p>Unlike <b class="APPLICATION">UMP</b> persistent messaging, queues use a queue
resolution mechanism built upon <b class="APPLICATION">UM</b> topic resolution for
service location. A <b class="APPLICATION">UMQ</b> source application does not have to
know the IP address and TCP port for each queue instance. Instead, all it requires is the
name of the queue. This provides some flexibility in deployment for moving queue
instances around and requires much less static information to be maintained for
configuration of sources and receivers.</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="QUEUEBROWSER" name="QUEUEBROWSER">4.3.7. Queue
Browser</a></h4>

<p><b class="APPLICATION">UMQ</b> supports the JMS Queue Browser specification with the
following <a href="../API/index.html" target="doccontent">C API</a> and <a
href="../JavaAPI/html/index.html" target="doccontent">Java API</a> calls.</p>

<div class="INFORMALTABLE"><a id="AEN1349" name="AEN1349"></a>
<table border="1" class="CALSTABLE">
<col width="192" />
<col width="264" />
<col width="264" />
<thead>
<tr>
<th>Action</th>
<th>C API</th>
<th>Java API</th>
</tr>
</thead>

<tbody>
<tr>
<td>Retrieve a list of topics and application sets from a running queue daemon.</td>
<td><code class="FUNCTION">lbm_ctx_umq_queue_topic_list()</code></td>
<td><code class="FUNCTION">LBMContext.queueTopicList()</code></td>
</tr>

<tr>
<td>Retrieve a list of currently-enqueued message IDs from a running queue daemon.</td>
<td><code class="FUNCTION">lbm_rcv_umq_queue_msg_list()</code></td>
<td><code class="FUNCTION">LBMReceiver.queueMessageList()</code></td>
</tr>

<tr>
<td>Retrieve specific messages by message ID from a running queue daemon.</td>
<td><code class="FUNCTION">lbm_rcv_umq_queue_msg_retrieve()</code></td>
<td><code class="FUNCTION">LBMReceiver.queueMessageRetrieve()</code></td>
</tr>
</tbody>
</table>
</div>

<p>The following <b class="APPLICATION">UM</b> configuration options apply to Queue
Browsing.</p>

<ul>
<li>
<p><a
href="../Config/ultramessagingjmsoptions.html#CONNECTIONFACTORYCREATEQUEUEBROWSERCONTEXT"
target="doccontent"><tt class="LITERAL">create_queue_browser_context</tt></a></p>
</li>

<li>
<p><a
href="../Config/ultramessagingjmsoptions.html#CONNECTIONFACTORYQUEUEBROWSERCREATIONDELAY"
target="doccontent"><tt class="LITERAL">queue_browser_creation_delay</tt></a></p>
</li>

<li>
<p><a href="../Config/ultramessagingjmsoptions.html#CONNECTIONFACTORYQUEUEBROWSERTIMEOUT"
target="doccontent"><tt class="LITERAL">queue_browser_timeout</tt></a></p>
</li>
</ul>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="QUEUEBROWSERAUTH" name="QUEUEBROWSERAUTH">4.3.7.1. Queue
Browser Authentication</a></h5>

<p><b class="APPLICATION">UM</b> queues can authenticate <b class="APPLICATION">UM</b>
applications using the Ultra Messaging JMS Queue Browser feature. <b
class="APPLICATION">UM</b> applications can also authenticate the queue.</p>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> Ultra Messaging JMS users do not need to configure authentication for a
Queue Browser. <b class="APPLICATION">UMQ</b> uses a internal default user, <tt
class="LITERAL">jmsuser</tt>, for JMS applications which requires no configuration.</p>
</blockquote>
</div>

<p>The use of any of the queue browser APIs mentioned in <a href="#QUEUEBROWSER"><i>Queue
Browser</i></a>, initiates authentication automatically between your application and the
queue. You can require authentication between your application and the queue, ensuring
that authentication must be successful before queue browsing can occur.</p>

<p>You require authentication by setting the <b class="APPLICATION">UM</b> Configuration
option, <a
href="../Config/ultramessagingqueuingoptions.html#CONTEXTUMQREQUIREQUEUEAUTHENTICATION"
target="doccontent"><tt class="LITERAL">umq_require_queue_authentication</tt></a>, to the
default setting of <b class="APPLICATION">1</b> (authentication required). In addition,
set the queue (<tt class="LITERAL">umestored</tt>) configuration option, <tt
class="LITERAL">require-client-authentication</tt> to the default value of <b
class="APPLICATION">1</b>.</p>

<div class="INFORMALTABLE"><a id="AEN1413" name="AEN1413"></a>
<table border="1" class="CALSTABLE">
<col width="288" />
<col width="288" />
<thead>
<tr>
<th>If you set ...</th>
<th>Then,</th>
</tr>
</thead>

<tbody>
<tr>
<td><tt class="LITERAL">umq_require_queue_authentication</tt> = 1 and <tt
class="LITERAL">require-client-authentication</tt> = 0</td>
<td>Authentication fails. (Possible error code, Core-5990-1) Your application does not
respond to browsing command responses sent by the queue.</td>
</tr>

<tr>
<td><tt class="LITERAL">umq_require_queue_authentication</tt> = 0 and <tt
class="LITERAL">require-client-authentication</tt> = 1</td>
<td>Authentication fails. (Possible error code, CoreApi-5688-4135) Your application may
send queue browsing commands to the queue, but the queue responds with an authentication
failure.</td>
</tr>

<tr>
<td><tt class="LITERAL">umq_require_queue_authentication</tt> = 0 and <tt
class="LITERAL">require-client-authentication</tt> = 0</td>
<td>Authentication can either succeed or fail without effect. Queue Browsing occurs.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="QUEUEBROWSERAUTHCREDENTIALS"
name="QUEUEBROWSERAUTHCREDENTIALS">4.3.7.2. Setting Queue Browser Authentication
Credentials</a></h5>

<p>Perform the following two tasks to set the Queue Browser authentication
credentials.</p>

<ol type="1">
<li>
<p>Use the C API <code class="FUNCTION">lbm_auth_set_credentials()</code> or the Java API
<code class="FUNCTION">LBMAuthUserInfo()</code> in your application to create users and
passwords in your application. A Credential callback provides a way for you to supply
alternate credentials in the event of authentication failure.</p>
</li>

<li>
<p>Generate a <tt class="FILENAME">password.xml</tt> file that contains the usernames and
passwords used by your application. Place <tt class="FILENAME">password.xml</tt> in the
directory configured in the <tt class="LITERAL">umestored</tt> XML configuration file
with the option, <tt class="LITERAL">lbm-password-file</tt>. See <a
href="#UMESTORED-DAEMON-TAGS"><i>Daemon Element</i></a>. The queue accesses this file
during authentication to verify usernames and passwords. You can generate <tt
class="LITERAL">password.xml</tt> in one of the two following ways.</p>

<ul>
<li>
<p>Use the <code class="FUNCTION">lbm_authstorage_*()</code> API calls in an auxiliary
application to create <tt class="FILENAME">password.xml</tt>. This application can import
any existing user credentials (i.e. from LDAP). (No Java equivalent exists for these
functions.)</p>
</li>

<li>
<p>Use the <b class="APPLICATION">UMQ</b> utility, <tt
class="FILENAME">/bin/lbmpwdgen</tt> to generate <tt class="FILENAME">password.xml</tt>.
Usage information appears within the file. (This utility uses <code
class="FUNCTION">lbm_authstorage_*()</code> API calls.)</p>
</li>
</ul>
</li>
</ol>

<p>A sample <tt class="FILENAME">password.xml</tt> appears below. Notice that you can
also create and assign user roles. In the sample you may also notice that <tt
class="FILENAME">/bin/lbmpwdgen</tt> creates an anonymous user (<tt
class="LITERAL">&lt;user name=""&#62;</tt>). <b class="APPLICATION">UMQ</b> requires this
user when authentication has not been enabled. You should not delete or edit this
user.</p>

<pre class="PROGRAMLISTING">
&lt;?xml version="1.0"?&#62;
&lt;um-configuration version="1.0"&#62;
  &lt;users&#62;
    &lt;user name="userSmith"&#62;
      &lt;verifier&#62;69A4aAE70US3NiuZr/TvAbSWztu5na5TbFo8bdHxU5.ILdMu8rLd5ragE3p4Qcuz/nXxAj6kGnwIF2JrKdCf704U/Lxs7jvK.b2uyOQoqKG&lt;/verifier&#62;
        &lt;salt&#62;3BmRWUznvzy0n2&lt;/salt&#62;
        &lt;roles&#62;
          &lt;role name="admin"&#62;&lt;/role&#62;
          &lt;role name="normal"&#62;&lt;/role&#62;
        &lt;/roles&#62;
    &lt;/user&#62;
    &lt;user name=""&#62;
      &lt;verifier/&#62;
      &lt;salt/&#62;
      &lt;roles&#62;
        &lt;role name="admin"/&#62;
      &lt;/roles&#62;
    &lt;/user&#62;
  &lt;/users&#62;
  &lt;roles&#62;
    &lt;role name="admin"&#62;
      &lt;action&#62;MSG_LIST&lt;/action&#62;
      &lt;action&#62;MSG_RETRIEVE&lt;/action&#62;
      &lt;action&#62;TOPIC_LIST&lt;/action&#62;
     &lt;/role&#62;
    &lt;role name="normal"&#62;
      &lt;action&#62;TOPIC_LIST&lt;/action&#62;
    &lt;/role&#62;
  &lt;/roles&#62;
&lt;/um-configuration&#62;
           
</pre>
</div>
</div>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="ULB-OPS" name="ULB-OPS">4.4. Ultra Load Balancing
Operations</a></h3>

<p>ULB, while similar in some ways to <b class="APPLICATION">UMQ</b>, differs in some
other ways. This section provides some details on how ULB works, and some comparisons
with <b class="APPLICATION">UMQ</b>.</p>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="ULB-OPS-PSD" name="ULB-OPS-PSD">4.4.1. Parallel Source
Dissemination (PSD)</a></h4>

<p>ULB supports the Parallel Source Dissemination (PSD) dissemination model. In the
figure below, note that the ULB PSD model operates in a very similar way to the <b
class="APPLICATION">UMQ</b> <a href="#PQD-DIAGRAM"><i>Parallel Queue Dissemination
(PQD)</i></a> model.</p>

<div class="FIGURE"><a id="ULB-PSD-DIAGRAM" name="ULB-PSD-DIAGRAM"></a>
<p><b>Figure 16. ULB Parallel Source Dissemination (PSD)</b></p>

<p><img src="ULB-PSD.png" align="CENTER" /></p>
</div>

<p>The key difference between ULB's PSD model and <b class="APPLICATION">UMQ</b>'s is
that with ULB, the source sends both the data and the assignment/control information on
the same transport session. ULB has no need for a control channel, as with <b
class="APPLICATION">UMQ</b>.</p>

<p>ULB receivers, as with <b class="APPLICATION">UMQ</b>, send unicast Consumption
Reports back to the source.</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="ULB-OPS-FAIRNESS" name="ULB-OPS-FAIRNESS">4.4.2. Source
Fairness</a></h4>

<p>ULB differs from <b class="APPLICATION">UMQ</b> somewhat in source "fairness". While
<b class="APPLICATION">UMQ</b> decouples sources from receivers with a queue -- and
therefore avoids receiver overload -- ULB does not use a queue or other middleware, so
sources could conceivably combine to overload a receiver, because of the real-time nature
of low-latency load balancing.</p>

<p>Therefore, ULB governs fairness between sources by using a) receiver feedback
information and b) receiver portion size, in concert with c) source configuration option
<a
href="../Config/ultramessagingqueuingoptions.html#SOURCEUMQULBAPPLICATIONSETLOADFACTORBEHAVIOR"
 target="doccontent">umq_ulb_application_set_load_factor_behavior</a>. For more, see <a
href="#QUEUE-FEEDBACK"><i>Queue Feedback</i></a> and <a
href="#RECEIVER-PORTION-SIZE"><i>Receiver Portion Size</i></a>.</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="ULB-FLIGHT-SIZE" name="ULB-FLIGHT-SIZE">4.4.3. Ultra Load
Balancing Flight Size</a></h4>

<p>ULB supports a flight size mechanism similar to <a href="#UME-FLIGHT-SIZE"><i>UMP
Flight Size</i></a> and <a href="#QUEUE-FLIGHT-SIZE"><i>UMQ Flight Size</i></a> that
tracks messages in flight from a particular source and responds when a send would exceed
the configured flight size (<a
href="../Config/ultramessagingqueuingoptions.html#SOURCEUMQULBFLIGHTSIZE"
target="doccontent">umq_ulb_flight_size</a>). You can configure <a
href="../Config/ultramessagingqueuingoptions.html#SOURCEUMQULBFLIGHTSIZEBEHAVIOR"
target="doccontent">umq_ulb_flight_size_behavior</a> to either:</p>

<ul>
<li>
<p>block any sends that would exceed the flight size or,</p>
</li>

<li>
<p>allow the sends while notifying your application.</p>
</li>
</ul>

<p>ULB considers a message in-flight until the source receives the MSG_COMPLETE
notification from all application sets. See also <a
href="../Config/ultramessagingqueuingoptions.html#SOURCEUMQULBEVENTS"
target="doccontent">umq_ulb_events</a>.</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="INDEXED-ULB" name="INDEXED-ULB">4.4.4. Indexed Ultra Load
Balancing (ULB)</a></h4>

<p>Indexed Ultra Load Balancing (ULB) is similar to <a href="#INDEXED-QUEUING"><i>Indexed
Queuing</i></a>. The source and receiver APIs are exactly the same with only minor
differences (e.g., receiver event types remain the same as for indexed queueing, but have
a flag set indicating that the source of the event was a ULB source). There are two
important differences to note:</p>

<ul>
<li>
<p>Assignment of indices is done at the source, on a per-source basis, with no global
coordination of index assignments, so multiple sources sending on the same index may
happen to assign the index to different receivers.</p>
</li>

<li>
<p>The advanced <tt class="LITERAL">allow/deny</tt> configuration rules and configuration
option inheritance available via the <tt class="LITERAL">umestored's</tt> <a
href="#INDEX-RULES-ELEMENT"><i>Index Rules Element</i></a> for indexed queueing are not
available for indexed ULB.</p>
</li>
</ul>
</div>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="UME-OPS-UME-EVENTS" name="UME-OPS-UME-EVENTS">4.5. <b
class="APPLICATION">UMP</b> and <b class="APPLICATION">UMQ</b> Events</a></h3>

<p>The <b class="APPLICATION"><span class="TRADEMARK">Ultra Messaging</span></b> API
provides a number of events, callbacks, messages, functions, and settings. The API
reference (<a href="../API/index.html" target="doccontent">C API</a>, <a
href="../JavaAPI/html/index.html" target="doccontent">Java API</a> or <a
href="../DotNetAPI/doc/Index.html" target="doccontent">.NET API</a>) can be used to see the
true extent of the API. In order to design successful applications, though, a high level
understanding of the events and callbacks is essential.</p>

<ul>
<li>
<p><b class="APPLICATION">Events</b> - Source events occur on a per source basis.</p>
</li>

<li>
<p><b class="APPLICATION">Callbacks</b> - Source and receiver callbacks called directly
from <b class="APPLICATION">UMP</b> and <b class="APPLICATION">UMQ</b> internal operation
and usually demands a return value be filled in and/or are informational in nature.
Typically, applications do very little processing in callbacks.</p>
</li>

<li>
<p><b class="APPLICATION">Messages</b> - Messages to receivers can simply contain <b
class="APPLICATION">UMP</b> or <b class="APPLICATION">UMQ</b> information or have impact
on operation.</p>
</li>
</ul>

<p>Some specific languages, such as C, Java, or C# may have specific nuances for the
various events and callbacks. But, by and large, an application should plan on having
access to the items listed in the following sections. For details for a particular
language, consult the <b class="APPLICATION"><span class="TRADEMARK">Ultra
Messaging</span></b> API documentation (<a href="../API/index.html" target="doccontent">C
API</a>, <a href="../JavaAPI/html/index.html" target="doccontent">Java API</a> or <a
href="../DotNetAPI/doc/Index.html" target="doccontent">.NET API</a>).</p>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UME-OPS-SOURCE-EVENTS" name="UME-OPS-SOURCE-EVENTS">4.5.1.
Source Events</a></h4>

<p>The following events and callbacks are available for source applications.</p>

<div class="INFORMALTABLE"><a id="AEN1560" name="AEN1560"></a>
<table border="1" class="CALSTABLE">
<col />
<col />
<col />
<thead>
<tr>
<th>Event Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td><tt class="LITERAL">Store Registration Success</tt></td>
<td>Source Event</td>
<td>Delivered once a source has successfully registered with a single store. Event
contains flags to show if the source is "old" (i.e. a re-registration) as well as the
sequence number that the source should use as its initial sequence number when sending,
and the store information</td>
</tr>

<tr>
<td><tt class="LITERAL">Store Registration Complete</tt></td>
<td>Source Event</td>
<td>Delivered once a source has completed registration with the required store(s). This
indicates the source may send as it desires. Event contains the consensus sequence
number.</td>
</tr>

<tr>
<td><tt class="LITERAL">Store Registration Error</tt></td>
<td>Source Event</td>
<td>Delivered once a source has received an error from the store indicating the requested
registration was not granted. Event contains an error message to indicate what
happened.</td>
</tr>

<tr>
<td><tt class="LITERAL">Queue Registration Complete</tt></td>
<td>Source Event</td>
<td>Delivered once a source has completed registration with the Queue. This indicates the
source may send as it desires. Event contains the Registration ID or Session ID.</td>
</tr>

<tr>
<td><tt class="LITERAL">Queue Registration Error</tt></td>
<td>Source Event</td>
<td>Delivered once a source has received an error from the Queue indicating the requested
registration was not granted. Event contains an error message to indicate what
happened.</td>
</tr>

<tr>
<td><tt class="LITERAL">Store Message Stable</tt></td>
<td>Source Event</td>
<td>Delivered once a message is stable at a single store. Event contains the message
sequence number and indicates if the the message meets Intergroup and/or Intragroup
stability requirements. Also includes the store information.</td>
</tr>

<tr>
<td><tt class="LITERAL">Queue Message Stability ACK</tt></td>
<td>Source Event</td>
<td>Stability acknowledgement sent to the source application by the Queue when a message
sent by the source is stable. If the Queue is configured to persist data to disk, the
message is stable once it has been written to the file. Otherwise, the Queue acknowledges
the message upon receipt.</td>
</tr>

<tr>
<td><tt class="LITERAL">Queue Message ID Information</tt></td>
<td>Source Event</td>
<td>The Queue assigns a unique ID to every message in order to assign the message to a
receiver. This assignment enforces OAOO delivery. The Queue includes assignment
information in the control information sent to receivers in a Parallel Queue
Dissemination (PQD) or Source Dissemination (SD) model.</td>
</tr>

<tr>
<td><tt class="LITERAL">Delivery Confirmation</tt></td>
<td>Source Event</td>
<td>Delivered once a message has been confirmed as delivered and processed by a receiving
application. Event contains the message sequence number as well as indications whether
the message has met the unique confirmations requirement. Also contains the receiver's
Registration ID or Session ID.</td>
</tr>

<tr>
<td><tt class="LITERAL">Store Unresponsive</tt></td>
<td>Source Event</td>
<td>Delivered once a store is seen to be unresponsive due to failure or network
disconnect. Event contains a message with more details suitable for logging. Sources
using the unresponsive store as their only store (not in Round-Robin or Quorum/Consensus)
will be prevented from sending until the store recovers.</td>
</tr>

<tr>
<td><tt class="LITERAL">Store Message Reclaimed</tt></td>
<td>Source Event</td>
<td>Delivered once a message has passed through retention and is about to be released
from memory or disk. Event contains the message sequence number. (Reclaim refers to
storage space reclamation.)</td>
</tr>

<tr>
<td><tt class="LITERAL">Store Forced Reclaim</tt></td>
<td>Callback</td>
<td>Indicates a message is being forcibly released because the memory size limit ( <a
href="../Config/latejoinoptions.html#SOURCERETRANSMITRETENTIONSIZELIMIT"
target="doccontent">retransmit_retention_size_limit</a>) has been exceeded. Event contains the
message sequence number.</td>
</tr>

<tr>
<td><tt class="LITERAL">Flight Size Notification</tt></td>
<td>Callback</td>
<td>Indicates that the number of in-flight messages for a source has exceeded or fallen
below the configured flight size limit for a source. The event indicates if the flight
size has been exceeded (OVER) by a new message send or that a message recently stabilized
has reduced the number of in flight messages to less than the flight size limit (UNDER).
Notification also indicates if the event is for <b class="APPLICATION">UMP</b>, <b
class="APPLICATION">UMQ</b> or ULB.</td>
</tr>

<tr>
<td><tt class="LITERAL">RPP Source Registration Success</tt></td>
<td>Source Event</td>
<td>Delivered once a source has successfully registered with a single store as a RPP
source. The event contains either the RegID or Session ID, the sequence number of the
last message stored for the source and store information.</td>
</tr>

<tr>
<td><tt class="LITERAL">RPP Source Registration Failure</tt></td>
<td>Source Event</td>
<td>Delivered once a source has received an error from the store indicating the requested
registration was not granted. Event contains an error message to indicate what
happened.</td>
</tr>

<tr>
<td><tt class="LITERAL">RPP Source Deregistration Success</tt></td>
<td>Source Event</td>
<td>Delivered once a source successfully deregisters from an individual store. The event
contains either the RegID or Session ID, the sequence number of the last message stored
for the source and store information.</td>
</tr>

<tr>
<td><tt class="LITERAL">RPP Source Deregistration Complete</tt></td>
<td>Source Event</td>
<td>Delivered once UMP receives a successful deregistration event from all stores.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UME-OPS-RECEIVER-EVENTS" name="UME-OPS-RECEIVER-EVENTS">4.5.2.
Receiver Events</a></h4>

<p>The following callbacks and messages are available for receiver applications</p>

<div class="INFORMALTABLE"><a id="AEN1659" name="AEN1659"></a>
<table border="1" class="CALSTABLE">
<col />
<col />
<col />
<thead>
<tr>
<th>Event Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td><tt class="LITERAL">Store Registration Success</tt></td>
<td>Message</td>
<td>Delivered once a receiver has successfully registered with a single store. Message
contains flags to show if the receiver is "old" (i.e. Not a new registration) as well as
the sequence number that the receiver should use as its low sequence number, and the
store information. In addition, the event contains the source's Registration ID or
Session ID and the receiver's Registration ID or Session ID.</td>
</tr>

<tr>
<td><tt class="LITERAL">Store Registration Complete</tt></td>
<td>Message</td>
<td>Delivered once a receiver has completed registration with the store(s) required. This
indicates the receiver may now receive data. Message contains the consensus sequence
number.</td>
</tr>

<tr>
<td><tt class="LITERAL">RPP Receiver Registration Success</tt></td>
<td>Message</td>
<td>Delivered once a receiver has successfully registered with a single store as a RPP
receiver. Message contains either the RegID or Session ID, the sequence number of the
last message stored for the source and store information.</td>
</tr>

<tr>
<td><tt class="LITERAL">RPP Receiver Registration Failure</tt></td>
<td>Message</td>
<td>Delivered once a receiver has received an error from the store indicating the
requested registration was not granted. Event contains an error message to indicate what
happened.</td>
</tr>

<tr>
<td><tt class="LITERAL">RPP Receiver Deregistration Success</tt></td>
<td>Message</td>
<td>Delivered once a receiver successfully deregisters from an individual store. The
message contains either the RegID or Session ID for the receiver and the source, the
sequence number of the last message stored for the source and store information.</td>
</tr>

<tr>
<td><tt class="LITERAL">RPP Receiver Deregistration Complete</tt></td>
<td>Message</td>
<td>Delivered once UMP receives a successful deregistration event from all stores.</td>
</tr>

<tr>
<td><tt class="LITERAL">Queue Registration Complete</tt></td>
<td>Message</td>
<td>Delivered once a receiver has completed registration with the Queue. Message contains
assignment information.</td>
</tr>

<tr>
<td><tt class="LITERAL">Store Registration Error</tt></td>
<td>Message</td>
<td>Delivered once a receiver has received an error from the store indicating the
requested registration was not granted. Message contains an error message to indicate
what happened.</td>
</tr>

<tr>
<td><tt class="LITERAL">Queue Registration Error</tt></td>
<td>Message</td>
<td>Delivered once a receiver has received an error from the Queue indicating the
requested registration was not granted. Message contains an error message to indicate
what happened.</td>
</tr>

<tr>
<td><tt class="LITERAL">Store Registration Change</tt></td>
<td>Message</td>
<td>Delivered once a change in store information is received from the source. The extent
of the change is included in a message suitable for logging.</td>
</tr>

<tr>
<td><tt class="LITERAL">Queue Deregistration Complete</tt></td>
<td>Message</td>
<td>Event delivered to a <b class="APPLICATION">UMQ</b> receiving application by the
Queue when a receiver deregisters from a Queue by calling <code
class="FUNCTION">lbm_rcv_umq_deregister()</code>. All messages must be delivered to the
application before the Queue sends the deregistration event. Deregistered receivers
cannot be assigned any new messages.</td>
</tr>

<tr>
<td><tt class="LITERAL">Store Retransmission</tt></td>
<td>Message</td>
<td>Retransmissions from recovery come in as normal messages with a flag indicating their
status as a retransmission.</td>
</tr>

<tr>
<td><tt class="LITERAL">Store Registration Function</tt></td>
<td>Callback</td>
<td>Called once a receiver receives store information from a source and <b
class="APPLICATION">UMP</b> desires to know the RegID to use for the receiver. Callback
passes the source RegID, the store information, and the source transport name. The return
value is the RegID that <b class="APPLICATION">UMP</b> should request to use from the
store.</td>
</tr>

<tr>
<td><tt class="LITERAL">Store Recovery Sequence Number Function</tt></td>
<td>Callback</td>
<td>Called once registration is about to complete and the low sequence number must be
determined. Callback passes the highest sequence number seen from the source and the
consensus sequence number from the stores or sequence number from the store if using
round-robin.</td>
</tr>

<tr>
<td><tt class="LITERAL">Queue Index Assignment Eligibility Start Complete</tt></td>
<td>Message</td>
<td>Event delivered to a <b class="APPLICATION">UMQ</b> receiving application by the
Queue when a receiver becomes eligible for new index assignments from a Queue as a result
of calling the <code class="FUNCTION">lbm_rcv_umq_index_start_assignment()</code>
function.</td>
</tr>

<tr>
<td><tt class="LITERAL">Queue Index Assignment Eligibility Stop Complete</tt></td>
<td>Message</td>
<td>Event delivered to a <b class="APPLICATION">UMQ</b> receiving application by the
Queue when a receiver becomes ineligible for new index assignments from a Queue as a
result of calling the <code class="FUNCTION">lbm_rcv_umq_index_stop_assignment()</code>
function. After this event is delivered, a receiver no longer receives new index
assignments from the Queue. Existing index assignments remain in place.</td>
</tr>

<tr>
<td><tt class="LITERAL">Queue Index Assigned</tt></td>
<td>Message</td>
<td>Event delivered to a <b class="APPLICATION">UMQ</b> receiving application by the
Queue when the Queue assigns a receiver a new index. After this event is delivered, the
receiver begins receiving messages on the new index.</td>
</tr>

<tr>
<td><tt class="LITERAL">Queue Index Released</tt></td>
<td>Message</td>
<td>Event delivered to a <b class="APPLICATION">UMQ</b> receiving application by the
Queue when the Queue removes one of the receiver's existing index assignments. This
usually occurs after the receiver calls <code
class="FUNCTION">lbm_rcv_umq_index_release()</code>. As a result, the receiver no longer
receives any messages for the removed index.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UME-OPS-CONTEXT-EVENTS" name="UME-OPS-CONTEXT-EVENTS">4.5.3.
Context Events</a></h4>

<p>The following events are available for the context of source and receiver
applications.</p>

<div class="INFORMALTABLE"><a id="AEN1771" name="AEN1771"></a>
<table border="1" class="CALSTABLE">
<col />
<col />
<col />
<thead>
<tr>
<th>Event Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td><tt class="LITERAL">Queue Registration Complete</tt></td>
<td>Context Event</td>
<td>Delivered once a source or receiver application's context has completed registration
with the Queue. A context only needs to register once with a Queue. Event contains the
Registration ID or Session ID.</td>
</tr>

<tr>
<td><tt class="LITERAL">Queue Registration Error</tt></td>
<td>Context Event</td>
<td>Delivered once a source or receiver application has received an error from the Queue
indicating the requested registration was not granted. Event contains an error message
indicating what happened.</td>
</tr>

<tr>
<td><tt class="LITERAL">Instance List Notification</tt></td>
<td>Context Event</td>
<td>Delivered once a queue instance has changed. Event holds information string.</td>
</tr>

<tr>
<td><tt class="LITERAL">Flight Size Notification</tt></td>
<td>Context Event</td>
<td>Indicates that the number of in-flight Multicast Immediate Messages has exceeded or
fallen below the configured flight size limit. The event indicates if the flight size has
been exceeded (OVER) by a new message send or that a message recently stabilized has
reduced the number of in flight messages to less than the flight size limit (UNDER).</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>

<div class="SECTION">
<hr />
<h2 class="SECTION"><a id="TUTORIAL" name="TUTORIAL">5. Enabling Persistence</a></h2>

<p>In this section, we explain how to build a persistence messaging application by
starting with a minimum source and receiver and then adding <b
class="APPLICATION">UMP</b> features incrementally. With the help of example source, this
section explains the following operations.</p>

<ul>
<li>
<p><a href="#TUTORIAL-UMESTORE"><i>Adding the</i> UMP Store to a Source</a></p>
</li>

<li>
<p><a href="#TUTORIAL-ADDINGFAULTRECOVERY"><i>Adding Fault Recovery with Registration
IDs</i></a></p>
</li>

<li>
<p><a href="#TUTORIAL-PERSISTENCESOURCESTORE"><i>Enabling Persistence Between the Source
and Store</i></a></p>
</li>

<li>
<p><a href="#TUTORIAL-PERSISTENCESOURCE"><i>Enabling Persistence in the
Source</i></a></p>
</li>

<li>
<p><a href="#TUTORIAL-PERSISTENCERECEIVER"><i>Enabling Persistence in the
Receiver</i></a></p>
</li>
</ul>

<p>Prerequisite: You should understand basic <b class="APPLICATION"><span
class="TRADEMARK">Ultra Messaging</span></b> concepts such as Sources and Receivers and
the basic methods for configuring them.</p>

<p>The following table lists all source files used in this section. You can also find
links to them in the appropriate task. The files can also be found in the <tt
class="FILENAME">/doc/UME</tt> directory.</p>

<div class="INFORMALTABLE"><a id="AEN1824" name="AEN1824"></a>
<table border="1" class="CALSTABLE">
<col width="192" />
<col width="192" />
<thead>
<tr>
<th>Object</th>
<th>Filename</th>
</tr>
</thead>

<tbody>
<tr>
<td>Source Application</td>
<td><a href="ume-example-src.c" target="doccontent">ume-example-src.c</a></td>
</tr>

<tr>
<td>Receiver Application</td>
<td><a href="ume-example-rcv.c" target="doccontent">ume-example-rcv.c</a></td>
</tr>

<tr>
<td>Source Application 2</td>
<td><a href="ume-example-src-2.c" target="doccontent">ume-example-src-2.c</a></td>
</tr>

<tr>
<td>Receiver Application 2</td>
<td><a href="ume-example-rcv-2.c" target="doccontent">ume-example-rcv-2.c</a></td>
</tr>

<tr>
<td>Source Application 3</td>
<td><a href="ume-example-src-3.c" target="doccontent">ume-example-src-3.c</a></td>
</tr>

<tr>
<td>Receiver Application 3</td>
<td><a href="ume-example-rcv-3.c" target="doccontent">ume-example-rcv-3.c</a></td>
</tr>

<tr>
<td><b class="APPLICATION">UMP</b> Store Configuration File</td>
<td><a href="ume-example-config.xml" target="doccontent">ume-example-config.xml</a></td>
</tr>
</tbody>
</table>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="TUTORIAL-STARTINGCONFIGURATION"
name="TUTORIAL-STARTINGCONFIGURATION">5.1. Starting Configuration</a></h3>

<p>We begin with the minimal source and receiver used by the <a
href="../QuickStart/index.html" target="doccontent">QuickStart Guide</a>. To more easily
demonstrate the <b class="APPLICATION">UMP</b> features we are interested in, we have
modified the QuickStart source and receiver in the following ways.</p>

<ul>
<li>
<p>Modified the source to send 20 messages with a one second pause between each
message</p>
</li>

<li>
<p>Modified the receiver to anticipate 20 messages instead of just one</p>
</li>

<li>
<p>Assigned the topic, UME Queue Example, to both the source and receiver</p>
</li>

<li>
<p>Modified the receiver to not exit on unexpected receiver events</p>
</li>
</ul>

<p>The last change allows us to better demonstrate basic operation and evolve our
receiver slowly without having to anticipate all the options that <b
class="APPLICATION">UMP</b> provides up front.</p>

<p>Example files for our exercise are:</p>

<div class="INFORMALTABLE"><a id="AEN1879" name="AEN1879"></a>
<table border="1" class="CALSTABLE">
<col width="192" />
<col width="192" />
<thead>
<tr>
<th>Object</th>
<th>File</th>
</tr>
</thead>

<tbody>
<tr>
<td>Source Application</td>
<td><a href="ume-example-src.c" target="doccontent">ume-example-src.c</a></td>
</tr>

<tr>
<td>Receiver Application</td>
<td><a href="ume-example-rcv.c" target="doccontent">ume-example-rcv.c</a></td>
</tr>
</tbody>
</table>
</div>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> Be sure to build <tt class="LITERAL">ume-example-rcv.c</tt> and <tt
class="LITERAL">ume-example-src.c</tt>. Instructions for building them are at the
beginning of the source files.</p>
</blockquote>
</div>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="TUTORIAL-UMESTORE" name="TUTORIAL-UMESTORE">5.2. Adding the <b
class="APPLICATION">UMP</b> Store to a Source</a></h3>

<p>The fundamental component of a <b class="APPLICATION">UMP</b> persistence solution is
the persistent store. To use a store, a source needs to be configured to use one by
setting <a href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMESTORE"
target="doccontent"><tt class="LITERAL">ume_store</tt></a> for the source. We can do that with
the following piece of code.</p>

<pre class="SCREEN">
err = lbm_src_topic_attr_str_setopt(&amp;attr, "ume_store", "127.0.0.1:14567");
</pre>

<p>This sets the <b class="APPLICATION">UMP</b> persistent store for the source to the
store running at 127.0.0.1 on port 14567.</p>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> If you desire to run a store on a different machine than where the source
and receiver are run, then you should replace 127.0.0.1 with the IP address (not
hostname) of the machine running the <b class="APPLICATION">UMP</b> persistent store.</p>
</blockquote>
</div>

<p>Example files for our exercise are:</p>

<div class="INFORMALTABLE"><a id="AEN1914" name="AEN1914"></a>
<table border="1" class="CALSTABLE">
<col width="192" />
<col width="192" />
<thead>
<tr>
<th>Object</th>
<th>Filename</th>
</tr>
</thead>

<tbody>
<tr>
<td>Source Application</td>
<td><a href="ume-example-src.c" target="doccontent">ume-example-src.c</a></td>
</tr>

<tr>
<td>Receiver Application</td>
<td><a href="ume-example-rcv.c" target="doccontent">ume-example-rcv.c</a></td>
</tr>

<tr>
<td><b class="APPLICATION">UMP</b> Store Configuration File</td>
<td><a href="ume-example-config.xml" target="doccontent">ume-example-config.xml</a></td>
</tr>
</tbody>
</table>
</div>

<p>After adding the ume-store specification to the source, perform the following
steps.</p>

<ol type="1">
<li>
<p>Create the cache and state directories. <tt class="LITERAL">$ mkdir umestored-cache ;
mkdir umestored-state</tt></p>
</li>

<li>
<p>Start up the store. <tt class="LITERAL">$ umestored ume-example-config.xml</tt></p>
</li>

<li>
<p>Start the Receiver. <tt class="LITERAL">$ ume-example-rcv</tt></p>
</li>

<li>
<p>Start the Source. <tt class="LITERAL">$ ume-example-src</tt></p>
</li>
</ol>

<p>You should see a message on the source that says:</p>

<pre class="SCREEN">
INFO: Source "UME Example" Late Join not set, but UME store specified. Setting Late Join.
</pre>

<p>This is an informational message from <b class="APPLICATION">UMP</b> and merely means
Late Join was not set and that <b class="APPLICATION">UMP</b> is going to set it.</p>

<p>Notice that the receiver was not configured with any store information. That is
because setting it on the source is all that is needed. The receiver learns <b
class="APPLICATION">UMP</b> store settings from the source through the normal <b
class="APPLICATION">UM</b> topic resolution process. Receivers don't need to do anything
special to leverage the usage of a store by a source.</p>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="TUTORIAL-ADDINGFAULTRECOVERY"
name="TUTORIAL-ADDINGFAULTRECOVERY">5.3. Adding Fault Recovery with Registration
IDs</a></h3>

<p>If the source or receiver crashes, how does the source and receiver tell the store
that they have restarted and wish to resume where they left off? We need to add in some
sort of identifiers to the source and receiver so that the store knows which sources and
receivers they are.</p>

<p>In <b class="APPLICATION">UMP</b> , these identifiers are called Registration IDs or
RegIDs. <b class="APPLICATION">UMP</b> allows the application to control the use of
RegIDs as it wishes. This allows applications to migrate sources and receivers not just
between systems, but between locations with true, unprecedented freedom. However, <b
class="APPLICATION">UMP</b> requires an application to be careful of how it uses RegIDs.
Specifically, an application must not use the same RegID for multiple sources and/or
receivers at the same time.</p>

<p>Now let's look at how we can use RegIDs to provide complete fault recovery of sources
and receivers. We'll first handle RegIDs in the simplest manner by using static IDs for
our source and receiver. For the source, the RegID of 1000 can be added to the existing
store specification by changing the string to</p>

<pre class="SCREEN">
127.0.0.1:14567:1000
</pre>

<p>This yields the source code in <a href="ume-example-src-2.c"
target="doccontent">ume-example-src-2.c</a></p>

<p>For the receiver, we accomplish this in two steps.</p>

<ol type="1">
<li>
<p>Set a callback function to be called when we desire to set the RegID to 1100. This is
done by declaring the callback function, <tt class="LITERAL">app_rcv_regid_callback</tt>,
which will return the RegID value 1100 to <b class="APPLICATION">UMP</b> .</p>
</li>

<li>
<p>Inform the <b class="APPLICATION">UMP</b> configuration for the receiver to use this
callback function. That is accomplished by setting the <a
href="../Config/ultramessagingpersistenceoptions.html#RECEIVERUMEREGISTRATIONEXTENDEDFUNCTION"
 target="doccontent"><tt class="LITERAL">ume_registration_extended_function</tt></a> similar to
example code below.</p>
</li>
</ol>

<pre class="SCREEN">
lbm_ume_rcv_regid_ex_func_t id;      /* structure to hold registration function information */
id.func = app_rcv_regid_callback;    /* the callback function to call */
id.clientd = NULL;                   /* the value to pass in the clientd to the function */
err = lbm_rcv_topic_attr_setopt(&amp;attr, "ume_registration_extended_function", &amp;id, sizeof(id));
         
</pre>

<p>Once this is done, the receiver has the ability to control what RegID it will use.
This yields the source code in <a href="ume-example-rcv-2.c"
target="doccontent">ume-example-rcv-2.c</a>.</p>

<p>With these in place, you can experiment with killing the receiver and bringing it back
(as long as you bring it back before the source is finished), as well as killing the
source and bringing it back.</p>

<p>The restriction to this initial approach to RegIDs is that the RegIDs 1000 and 1100
may not be used by any other objects at the same time. If you run additional sources or
receivers, they must be assigned new RegIDs, not 1000 or 1100. Let's now take a more
sophisticated approach to RegIDs that will allow much more flexibility</p>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="TUTORIAL-PERSISTENCESOURCESTORE"
name="TUTORIAL-PERSISTENCESOURCESTORE">5.4. Enabling Persistence Between the Source and
Store</a></h3>

<p>Let's refine our source to include some desired behavior following a crash. Upon
restart, we want our source to resume with the first unsent message. For example, if the
source sent 10 messages and crashed, we want our source to resume with the 11th message
and continue until it has sent the 20th message.</p>

<p>Accomplishing this graceful resumption requires us to ensure that our source is the
only source that uses the RegID assigned to it. The same RegID should be used as long as
the source has not sent the 20th message regardless of any crashes that may occur. We can
do this with the following changes to the store:</p>

<ol type="1">
<li>
<p>Configure the store to assign a RegID when the source starts.</p>
</li>

<li>
<p>Configure the store to save the RegID to disk so that it can be used after a
crash.</p>
</li>
</ol>

<p>In addition to these two changes to the store's configuration, the following two
sections explain the changes needed for the source and receiver, which become fairly easy
due to the events that <b class="APPLICATION">UMP</b> delivers to the application during
<b class="APPLICATION">UMP</b> operation.</p>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> While the following sections are instructive about how <b
class="APPLICATION">UMP</b> uses RegIDs to provide persistence, RegIDs can also be
managed easily with the use of Session IDs. See <a href="#SESSION-IDS"><i>Managing RegIDs
with Session IDs</i></a>.</p>
</blockquote>
</div>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="TUTORIAL-PERSISTENCESOURCE"
name="TUTORIAL-PERSISTENCESOURCE">5.5. Enabling Persistence in the Source</a></h3>

<p>With the above mentioned behaviors in mind, let's turn to looking at how they may be
implemented with <b class="APPLICATION">UMP</b> , starting with the source. We can
summarize the changes we need by the following list.</p>

<ol type="1">
<li>
<p>At source startup, use any saved RegID information found in the file by setting
information in the <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMESTORE" target="doccontent"><tt
class="LITERAL">ume_store</tt></a> configuration variable.</p>
</li>

<li>
<p>After the store registration is successful, if a new RegID was assigned to the source,
save the RegID to the file.</p>
</li>

<li>
<p>Set the message number to begin sending. Refer to the explanation below.</p>
</li>

<li>
<p>Send until message number 20 has been sent.</p>
</li>

<li>
<p>After message 20 has been sent, delete the saved RegID file.</p>
</li>
</ol>

<p>For Step 3, if the source has just been initialized, the application starts with
message number 1. If the source has been restarted after a crash, the application looks
to <b class="APPLICATION">UMP</b> to establish the beginning message number because <b
class="APPLICATION">UMP</b> will use the next sequence number. For this simple example,
we can make the assumption that each message is one sequence number for <b
class="APPLICATION">UMP</b> and that <b class="APPLICATION">UMP</b> starts with sequence
number 0. Thus the application can set the message number it begins resending with the
value of the <b class="APPLICATION">UMP</b> sequence number + 1.</p>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> Using sequence numbers to set the message number is a good practice if
you send messages smaller than 8K.</p>
</blockquote>
</div>

<p>These changes yield the source code in <a href="ume-example-src-3.c"
target="doccontent">ume-example-src-3.c</a>.</p>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="TUTORIAL-PERSISTENCERECEIVER"
name="TUTORIAL-PERSISTENCERECEIVER">5.6. Enabling Persistence in the Receiver</a></h3>

<p>Let's also refine the receiver to resume where it left off after a crash. Just as with
the source, the receiver can have the store assign it a RegID if the receiver is just
beginning. Once the receiver receives the 20th message from the source, it can get rid of
the RegID and exit. Because the receiver can receive some messages, crash, and come back,
we should only need to look at a message and check if it is the 20th message based on the
message contents or sequence number. <b class="APPLICATION">UMP</b> provides all the
events to the application that we need to create these behaviors in the receiver.</p>

<p>The receiver changes are summarized below.</p>

<ol type="1">
<li>
<p>At receiver startup, use any saved RegID information found in the file for callback
information when needed.</p>
</li>

<li>
<p>When RegID callback is called: Check to see if the source RegID matches the saved
source RegID. If it does, return the saved receiver RegID. RegID matches the saved source
RegID if so, return the saved receiver RegID.</p>
</li>

<li>
<p>After store registration is successful: If not using a previously saved RegID, then
save the RegID assigned by the store to the source to a file, as well as the store
information and the source RegID.</p>
</li>

<li>
<p>After the last message is received (message number 20 or <b
class="APPLICATION">UMP</b> sequence number 19), end the application and delete the saved
RegID file.</p>
</li>
</ol>

<p>RegIDs in <b class="APPLICATION">UMP</b> can be considered to be per source and per
topic. Thus the receiver does not want to use the wrong RegID for a different source on
the same topic. To avoid this, we save the source RegID and even store information so
that the <tt class="LITERAL">app_rcv_regid_callback</tt> can make sure to use the correct
RegID for the given source RegID. These changes yield the source code in <a
href="ume-example-rcv-3.c" target="doccontent">ume-example-rcvc-3.c</a></p>

<p>The above sources and receivers are simplified for illustration purposes and do have
some limitations. The receiver will only keep the information for one source at a time
saved to the file. This is fine for illustration purposes, but would be lacking in
completeness for production applications unless it was assured that a single source for
any topic would be in use. To extend the receiver to include several sources is simply a
matter of saving each to the file, reading them in at startup, and being able to search
for the correct one for each callback invoked.</p>
</div>
</div>

<div class="SECTION">
<hr />
<h2 class="SECTION"><a id="DEMONSTRATING-UME-PERSISTENCE"
name="DEMONSTRATING-UME-PERSISTENCE">6. Demonstrating Persistence</a></h2>

<p>This section demonstrates the following events using the <tt
class="LITERAL">ume-example</tt> applications described in <a
href="#TUTORIAL"><i>Enabling Persistence</i></a>.</p>

<ul>
<li>
<p><a href="#RUNNING-UME-EXAMPLE-APPLICATIONS"><i>Running</i> UMP Example
Applications</a></p>
</li>

<li>
<p><a href="#SINGLE-RECEIVER-FAILS-RECOVERS"><i>Single Receiver Fails and
Recovers</i></a></p>
</li>

<li>
<p><a href="#SINGLE-SOURCE-FAILS-RECOVERS"><i>Single Source Fails and
Recovers</i></a></p>
</li>

<li>
<p><a href="#SINGLE-STORE-FAILS"><i>Single Store Fails</i></a></p>
</li>
</ul>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> While these four sections demonstrate how <b class="APPLICATION">UMP</b>
uses RegIDs to provide persistence, RegIDs can also be managed easily with the use of
Session IDs. See <a href="#SESSION-IDS"><i>Managing RegIDs with Session IDs</i></a>.</p>
</blockquote>
</div>

<p>The following table lists all source files used in this section. The files can also be
found in the <tt class="FILENAME">/doc/UME</tt> directory.</p>

<div class="INFORMALTABLE"><a id="AEN2072" name="AEN2072"></a>
<table border="1" class="CALSTABLE">
<col width="192" />
<col width="192" />
<thead>
<tr>
<th>Object</th>
<th>Filename</th>
</tr>
</thead>

<tbody>
<tr>
<td>Source Application 3</td>
<td><a href="ume-example-src-3.c" target="doccontent">ume-example-src-3.c</a></td>
</tr>

<tr>
<td>Receiver Application 3</td>
<td><a href="ume-example-rcv-3.c" target="doccontent">ume-example-rcv-3.c</a></td>
</tr>

<tr>
<td><b class="APPLICATION">UMP</b> Store Configuration File</td>
<td><a href="ume-example-config.xml" target="doccontent">ume-example-config.xml</a></td>
</tr>
</tbody>
</table>
</div>

<p>Perform the following tasks first.</p>

<ol type="1">
<li>
<p>Build <a href="ume-example-src-3.c" target="doccontent"><tt
class="LITERAL">ume-example-rcv-3.c</tt></a> and <a href="ume-example-rcv-3.c"
target="doccontent"><tt class="LITERAL">ume-example-src-3.c</tt></a>. Instructions for building
them are at the beginning of the source files.</p>
</li>

<li>
<p>Create default directories, <tt class="LITERAL">umestored-cache</tt> and <tt
class="LITERAL">umestored-state</tt> in the <tt class="FILENAME">/doc/UME</tt> directory
where the other ume-example files are located. Our sample XML store configuration file,
<tt class="LITERAL"><a href="ume-example-config.xml"
target="doccontent">ume-example-config.xml</a></tt>, doesn't specify directories for the
store's cache and state files, so those will be placed in the default directories.</p>
</li>

<li>
<p>Start the store. <tt class="LITERAL">$ umestored <a href="ume-example-config.xml"
target="doccontent">ume-example-config.xml</a></tt></p>
</li>
</ol>

<p>You should see no output if the store started successfully. However, you should find a
new log file, <tt class="LITERAL">ume-example-stored.log</tt>, in the directory you ran
the store in. The first couple lines should look similar to below.</p>

<pre class="PROGRAMLISTING">
Fri Feb 01 07:34:28 2009 [INFO]: Latency Busters Persistent Store version 2.0
Fri Feb 01 07:34:28 2009 [INFO]: LBM 3.3 [UME-2.0] Build: Jan 31 2009, 02:10:43 
( DEBUG license LBT-RM LBT-RU ) WC[PCRE 6.7 04-Jul-2006, appcb]
       
</pre>

<p>You'll also be able to view the store's web monitor. Open a web browser and go to:</p>

<pre class="PROGRAMLISTING">
      http://127.0.0.1:15304/
       
</pre>

<p>You should see the store's web monitor page, which is a diagnostic and monitoring tool
for the <b class="APPLICATION">UMP</b> store. See <a
href="#UME-STORE-WEB-MONITOR"><i>Ultra Messaging Web Monitor</i></a>.</p>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="RUNNING-UME-EXAMPLE-APPLICATIONS"
name="RUNNING-UME-EXAMPLE-APPLICATIONS">6.1. Running <b class="APPLICATION">UMP</b>
Example Applications</a></h3>

<p>With the store running, let's try our example source and receiver applications.</p>

<ol type="1">
<li>
<p>Start the Receiver. <tt class="LITERAL">$ ume-example-rcv-3.exe</tt></p>
</li>

<li>
<p>Start the Source. <tt class="LITERAL">$ ume-example-src-3.exe</tt></p>
</li>
</ol>

<p>You should see output for the source similar to the following:</p>

<pre class="PROGRAMLISTING">
saving RegID info to "UME-example-src-RegID" - 127.0.0.1:14567:2795623327
       
</pre>

<p>You should see output for the receiver similar to the following:</p>

<pre class="PROGRAMLISTING">
UME Store 0: 127.0.0.1:14567 [TCP:169.254.97.160:14371][2795623327] Requesting RegID: 0
saving RegID info to "UME-example-rcv-RegID" - 127.0.0.1:14567:2795623327:2795623328
Received 15 bytes on topic UME Example (sequence number 0) 'UME Message 01'
Received 15 bytes on topic UME Example (sequence number 1) 'UME Message 02'
Received 15 bytes on topic UME Example (sequence number 2) 'UME Message 03'
Received 15 bytes on topic UME Example (sequence number 3) 'UME Message 04'
...
       
</pre>

<p>The example source sends 20 messages. After the 20th messages, both the source and
receiver exit and print the message <tt class="LITERAL">removing saved RegID file...</tt>
So what just happened? Let's walk through the output line by line.</p>

<p><b class="APPLICATION">Source</b></p>

<pre class="PROGRAMLISTING">
saving RegID info to "UME-example-src-RegID" - 127.0.0.1:14567:2795623327
       
</pre>

<p>The source successfully registered with the store using its pre-configured store
address and port of 127.0.0.1:14567. It didn't ask for a specific RegID from the store,
so the store automatically assigned one to it. In this case, the store assigned the ID,
2795623327. Your source's ID will likely be different because stores assign random
RegIDs.</p>

<p>If you run the test again, you'll notice the source application has written a file
called <tt class="LITERAL">UME-example-src-RegID</tt> that contains the same information
the source printed on startup, namely the IP address and port of the store it registered
with, along with its RegID assigned by the store.</p>

<p><b class="APPLICATION">Receiver</b></p>

<pre class="PROGRAMLISTING">
UME Store 0: 127.0.0.1:14567 [TCP:169.254.97.160:14371][2795623327] Requesting RegID: 0
saving RegID info to "UME-example-rcv-RegID" - 127.0.0.1:14567:2795623327:2795623328
       
</pre>

<p>The receiver has been informed of how to connect to the store by the source, and it
also successfully registered with the store. The store's IP address and port are shown,
followed by the source's unique identifier string (in this case, it's a TCP source on
port 14371), and the source's RegID. The receiver then requests RegID 0 from the store,
which is a special value that means <span class="emphasis"><i class="EMPHASIS">pick an ID
for me</i></span> (Although not displayed, the source requested ID 0 when it started up
as well).</p>

<p>In parallel with the source application, the receiver application writes its RegID
with this store to the file, <tt class="LITERAL">UME-example-rcv-RegID</tt>.</p>

<p>After sending 20 messages under normal, stable conditions, the source and receiver
applications exit and remove their RegID files.</p>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="SINGLE-RECEIVER-FAILS-RECOVERS"
name="SINGLE-RECEIVER-FAILS-RECOVERS">6.2. Single Receiver Fails and Recovers</a></h3>

<p>Perform the following procedure with the store running to see what happens when a
receiver fails and recovers.</p>

<ol type="1">
<li>
<p>Start the Receiver. <tt class="LITERAL">$ ume-example-rcv-3.exe</tt></p>
</li>

<li>
<p>Start the source. <tt class="LITERAL">$ ume-example-src-3.exe</tt> Let it run for a
few seconds so the receiver gets a few messages.</p>

<pre class="PROGRAMLISTING">
UME Store 0: 127.0.0.1:14567 [TCP:169.254.97.160:14371][3735579353] Requesting RegID: 0
saving RegID info to "UME-example-rcv-RegID" - 127.0.0.1:14567:3735579353:3735579354
Received 15 bytes on topic UME Example (sequence number 0) 'UME Message 01'
Received 15 bytes on topic UME Example (sequence number 1) 'UME Message 02'
Received 15 bytes on topic UME Example (sequence number 2) 'UME Message 03'
           
</pre>
</li>

<li>
<p>Stop the receiver (<b class="APPLICATION">Ctrl/C</b>) and leave the source running.
Wait a few more seconds so that the source sends some messages while the receiver was
down.</p>
</li>

<li>
<p>Restart the Receiver and let it run to completion. <tt class="LITERAL">$
ume-example-rcv-3.exe</tt></p>

<pre class="PROGRAMLISTING">
read in saved RegID info from "UME-example-rcv-RegID" - 127.0.0.1:14567 RegIDs 
source 3735579353, receiver 3735579354
UME Store 0: 127.0.0.1:14567 [TCP:169.254.97.160:14371][3735579353] 
Requesting RegID: 3735579354
Received 15 bytes on topic UME Example (sequence number 3) 'UME Message 04'
Received 15 bytes on topic UME Example (sequence number 4) 'UME Message 05'
Received 15 bytes on topic UME Example (sequence number 5) 'UME Message 06'
Received 15 bytes on topic UME Example (sequence number 6) 'UME Message 07'
Received 15 bytes on topic UME Example (sequence number 7) 'UME Message 08'
Received 15 bytes on topic UME Example (sequence number 8) 'UME Message 09'
Received 15 bytes on topic UME Example (sequence number 9) 'UME Message 10'
Received 15 bytes on topic UME Example (sequence number 10) 'UME Message 11'
           
</pre>
</li>
</ol>

<p>Notice that the receiver picked up the message stream right where it had left off -
after message 3. The first few messages (which the source had sent while the receiver was
down) appear to come in much faster than the source's normal rate of one per second.
That's because they are being served to the receiver from the store. The remaining
messages continue to come in at the normal one-per-second rate because they're being
received from the source's live message stream. This is <span class="emphasis"><i
class="EMPHASIS">durable subscription</i></span> at work.</p>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="SINGLE-SOURCE-FAILS-RECOVERS"
name="SINGLE-SOURCE-FAILS-RECOVERS">6.3. Single Source Fails and Recovers</a></h3>

<p>Perform the following procedure with the store running to see what happens when a
source fails and recovers.</p>

<ol type="1">
<li>
<p>Start the Receiver. <tt class="LITERAL">$ ume-example-rcv-3.exe</tt></p>
</li>

<li>
<p>Start the source. <tt class="LITERAL">$ ume-example-src-3.exe</tt> Let it run for a
few seconds so the receiver gets a few messages.</p>
</li>

<li>
<p>Stop the Source (<b class="APPLICATION">Ctrl/C</b>).</p>
</li>

<li>
<p>Restart the Source and let it run to completion. <tt class="LITERAL">$
ume-example-rcv-3.exe</tt></p>
</li>
</ol>

<p><b class="APPLICATION">Source</b></p>

<p>You should see output similar to the following on the second run of the source.</p>

<pre class="PROGRAMLISTING">
read in saved RegID info from "UME-example-src-RegID" - 127.0.0.1:14567:2118965523
will start with message number 5
removing saved RegID file "UME-example-src-RegID"
           
</pre>

<p><b class="APPLICATION">Receiver</b></p>

<p>The receiver's output looks like the following.</p>

<pre class="PROGRAMLISTING">
UME Store 0: 127.0.0.1:14567 [TCP:169.254.97.160:14371][2118965523] Requesting RegID: 0
saving RegID info to "UME-example-rcv-RegID" - 127.0.0.1:14567:2118965523:2118965524
Received 15 bytes on topic UME Example (sequence number 0) 'UME Message 01'
Received 15 bytes on topic UME Example (sequence number 1) 'UME Message 02'
Received 15 bytes on topic UME Example (sequence number 2) 'UME Message 03'
Received 15 bytes on topic UME Example (sequence number 3) 'UME Message 04'
UME Store 0: 127.0.0.1:14567 [TCP:169.254.97.160:14371][2118965523] Requesting RegID: 2118965524
saving RegID info to "UME-example-rcv-RegID" - 127.0.0.1:14567:2118965523:2118965524
Received 15 bytes on topic UME Example (sequence number 4) 'UME Message 05'
Received 15 bytes on topic UME Example (sequence number 5) 'UME Message 06'
Received 15 bytes on topic UME Example (sequence number 6) 'UME Message 07'
Received 15 bytes on topic UME Example (sequence number 7) 'UME Message 08'
...
           
</pre>

<p>When the source was restarted, it read in its previously saved RegID and requested the
same ID when registering with the store. The store informed the source that it had left
off at sequence number 3 (UME Message 04), and the next sequence number it should send is
4 (UME Message 05). Bringing the source back up also caused the receiver to re-register
with the store. Receivers can <span class="emphasis"><i class="EMPHASIS">only</i></span>
find out about stores from sources they are listening to. Once the receiver re-registered
with the store, it continued receiving messages from the source where it had left
off.</p>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="SINGLE-STORE-FAILS" name="SINGLE-STORE-FAILS">6.4. Single
Store Fails</a></h3>

<p>Perform the following procedure with the store running to see what happens when the
store itself fails.</p>

<ol type="1">
<li>
<p>Start the Receiver. <tt class="LITERAL">$ ume-example-rcv-3.exe</tt></p>
</li>

<li>
<p>Start the source. <tt class="LITERAL">$ ume-example-src-3.exe</tt> Let it run for a
few seconds so the receiver gets a few messages.</p>
</li>

<li>
<p>Stop the Store (<b class="APPLICATION">Ctrl/C</b>).</p>
</li>
</ol>

<p>Notice that with this simple example program, the source simply prints the following
and exits.</p>

<pre class="PROGRAMLISTING">
saving RegID info to "UME-example-src-RegID" - 127.0.0.1:14567:4095035673
Store unresponsive: store 0 [127.0.0.1:14567] unresponsive
Store unresponsive: store 0 [127.0.0.1:14567] unresponsive - no registration response.
line 318: not currently registered with enough <b class="APPLICATION">UMP</b> stores
           
</pre>

<p>When a source application tries to send a message without being registered with a
store, the send call returns an error. Messages sent while not registered with a store
cannot be persisted. See <a href="#UME-STORES"><i>UMP Stores</i></a> for information
about using multiple stores.</p>

<p>Your source application(s) should assume an unresponsive store is a temporary problem
and wait before sending the message again. See <a href="../example/umesrc.c"
target="doccontent"><tt class="LITERAL">umesrc.c</tt></a>, <a
href="../java_example/umesrc.java" target="doccontent"><tt
class="LITERAL">umesrc.java</tt></a>, or <a href="../dotnet_example/umesrc.cs"
target="doccontent"><tt class="LITERAL">umesrc.cs</tt></a> for examples of this behavior.</p>
</div>
</div>

<div class="SECTION">
<hr />
<h2 class="SECTION"><a id="DESIGNING-PERSISTENT-APPLICATIONS"
name="DESIGNING-PERSISTENT-APPLICATIONS">7. Designing Persistence Applications</a></h2>

<p>This section discusses considerations and methods for utilizing <b
class="APPLICATION">UMP</b> persistence in your applications.</p>

<ul>
<li>
<p><a href="#PIECES-OF-PERSISTENT-SOLUTION"><i>Pieces of a Persistence
Solution</i></a></p>
</li>

<li>
<p><a href="#FAULT-RECOVERY"><i>Fault Recovery</i></a></p>
</li>
</ul>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="PIECES-OF-PERSISTENT-SOLUTION"
name="PIECES-OF-PERSISTENT-SOLUTION">7.1. Pieces of a Persistence Solution</a></h3>

<p>In <b class="APPLICATION">UMP</b> , a persistent system is composed of <b
class="APPLICATION">sources</b>, <b class="APPLICATION">receivers</b>, and <b
class="APPLICATION">stores</b> managed by one or more applications. Sources and receivers
are the endpoints of communication and the store(s) provide fault recovery and
persistence of state information. Your application can leverage <b
class="APPLICATION">UMP</b> 's flexible methods of persistence to add an unprecedented
level of fault tolerance. With this flexibility your applications assume new
responsibilities not normally required in other persistent messaging systems. This
section identifies the important considerations for your messaging applications when
implementing the following <b class="APPLICATION">UMP</b> features.</p>

<ul>
<li>
<p><a href="#REGISTRATION-IDENTIFIERS"><i>Registration Identifiers</i></a></p>
</li>

<li>
<p><a href="#UME-SOURCES"><i>UMP Sources</i></a></p>
</li>

<li>
<p><a href="#UME-RECEIVERS"><i>UMP Receivers</i></a></p>
</li>

<li>
<p><a href="#UME-STORES"><i>UMP Stores</i></a></p>
</li>
</ul>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="REGISTRATION-IDENTIFIERS"
name="REGISTRATION-IDENTIFIERS">7.1.1. Registration Identifiers</a></h4>

<p>As mentioned in <a href="#UMECONCEPTS-REGID"><i>Registration Identifier</i></a> and <a
href="#TUTORIAL-ADDINGFAULTRECOVERY"><i>Adding Fault Recovery with Registration
IDs</i></a>, stores use RegIDs to identify sources and receivers. <b
class="APPLICATION">UMP</b> offers three main methods for managing RegIDs.</p>

<ul>
<li>
<p>Your applications assign static RegIDs and ensure that the same RegID is not assigned
to multiple sources and/or receivers. See <a href="#USE-STATIC-REGIDS"><i>Use Static
RegIDs</i></a>.</p>
</li>

<li>
<p>You can allow <b class="APPLICATION">UMP</b> stores to assign RegIDs and then save the
assigned RegIDs. See <a href="#SAVE-ASSIGNED-REGIDS"><i>Save Assigned RegIDs</i></a></p>
</li>

<li>
<p>Use Session IDs to enable the <b class="APPLICATION">UMP</b> store to both assign and
manage RegIDs. See <a href="#SESSION-IDS"><i>Managing RegIDs with Session IDs</i></a></p>
</li>
</ul>

<p>Your applications can manage RegIDs for the lifetime of a source or receiver as long
as multiple applications do not reuse RegIDs simultaneously on the same store. RegIDs
only need to be unique on the same store and may be reused between stores as desired. You
can use a static mapping of RegIDs to applications or use some simple service to assign
them.</p>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="USE-STATIC-REGIDS" name="USE-STATIC-REGIDS">7.1.1.1. Use
Static RegIDs</a></h5>

<p>The simplest method uses static RegIDs for individual applications. This method works
best if:</p>

<ul>
<li>
<p>Applications use separate stores</p>
</li>

<li>
<p>Multiple instances of an application also use separate stores</p>
</li>
</ul>

<p>In the latter case, the same static source RegID can be used in every instance of the
application because receivers will identify every Store/Source RegID tuple as unique.</p>

<p>The following source code examples assign a static RegID to a source by adding the
RegID, <tt class="LITERAL">1000</tt>, to the <tt class="LITERAL">ume_store</tt>
attribute. (See also <a href="ume-example-src-2.c"
target="doccontent">ume-example-src-2.c</a>.)</p>

<p><b class="APPLICATION">C API</b></p>

<pre class="PROGRAMLISTING">
lbm_src_topic_attr_t * sattr;

if (lbm_src_topic_attr_create(&amp;sattr) == LBM_FAILURE) {
        fprintf(stderr, "lbm_src_topic_attr_create: %s\n", lbm_errmsg());
        exit(1);
}
if (lbm_src_topic_attr_str_setopt(sattr, "ume_store", "127.0.0.1:14567:1000")
== LBM_FAILURE) {
        fprintf(stderr, "lbm_src_topic_attr_str_setopt: %s\n", lbm_errmsg());
        exit(1);
}
       
</pre>

<p><b class="APPLICATION">JAVA API</b></p>

<pre class="PROGRAMLISTING">
LBMSourceAttributes sattr = null;
try {
sattr = new LBMSourceAttributes();
sattr.setValue("ume_store", "127.0.0.1:14567:1000");
}
catch (LBMException ex) {
System.err.println("Error creating source attribute: " + ex.toString());
System.exit(1);
}
       
</pre>

<p><b class="APPLICATION">.NET API</b></p>

<pre class="PROGRAMLISTING">
LBMSourceAttributes sattr = null;
try {
sattr = new LBMSourceAttributes();
sattr.setValue("ume_store", "127.0.0.1:14567:1000");
}
catch (LBMException ex) {
System.Console.Error.WriteLine ("Error creating source attribute: " + ex.toString());
System.Environment.Exit(1);
       }
       
</pre>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="SAVE-ASSIGNED-REGIDS" name="SAVE-ASSIGNED-REGIDS">7.1.1.2.
Save Assigned RegIDs</a></h5>

<p>Your application can save the RegID assigned to a source or receiver from the store
because the <b class="APPLICATION">UMP</b> API informs your application of the RegID used
for each registration. This method of managing RegIDs is perhaps the most flexible, but
also requires some work by the application to save RegIDs and retrieve them in some
way.</p>

<p>The following source code examples save the RegID assigned to a source to a file. (See
also <a href="ume-example-src-3.c" target="doccontent">ume-example-src-3.c</a>.)</p>

<p><b class="APPLICATION">C API</b></p>

<pre class="PROGRAMLISTING">
typedef struct src_info_t_stct {
    int existing_regid;       
    int message_num;          
} src_info_t;

#define SRC_REGID_SAVE_FILENAME "UME-example-src-RegID"

int save_src_regid_to_file(const char *filename, lbm_src_event_ume_registration_ex_t *reg)
{
    FILE *fp;           
    
    if ((fp = fopen(filename, "w")) == NULL)
        return -1;
    fprintf(fp, "%s:%u", reg-&#62;store, reg-&#62;registration_id);
    printf("saving RegID info to \"%s\" - %s:%u\n", filename, reg-&#62;store, reg-&#62;registration_id);
    fflush(fp);
    fclose(fp);
    return 0;
}
       
</pre>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="SESSION-IDS" name="SESSION-IDS">7.1.1.3. Managing RegIDs with
Session IDs</a></h5>

<p>The RegIDs used by stores to identify sources and receivers must be unique. Rather
than maintaining RegIDs (either statically or dynamically), applications can use a
Session ID, which is simply a 64-bit value that uniquely identifies any set of sources
with unique topics and receivers with unique topics. A single Session ID allows <b
class="APPLICATION">UMP</b> stores to correctly identify all the sources and receivers
for a particular application.</p>

<p>Combinations of sources and receivers that make up a single valid session include the
following.</p>

<ul>
<li>
<p>Sources for topics A, B, and C</p>
</li>

<li>
<p>Receivers for topics A, B, and C</p>
</li>

<li>
<p>Sources for topics A, B, and C, and receivers for topics X, Y and Z</p>
</li>

<li>
<p>Sources for topics A, B, and C, and receivers for topics A, B, and C</p>
</li>
</ul>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> Note that any topic can be used for a source and a receiver at the same
time, but not for more than one of each. Two sources using topic A, for example, would
need to be split into two different contexts.</p>
</blockquote>
</div>

<p>The <b class="APPLICATION">UMP</b> configuration option, <a
href="../Config/ultramessagingpersistenceoptions.html#CONTEXTUMESESSIONID"
target="doccontent"><tt class="LITERAL">ume_session_id</tt></a> , specifies a Session ID for a
source, receiver or a context. If you want all sources and receivers for a particular
context to use the same Session ID, use <a
href="../Config/ultramessagingpersistenceoptions.html#CONTEXTUMESESSIONID"
target="doccontent"><tt class="LITERAL">(context) ume_session_id</tt></a> . Any source or
receiver that does not specify its own Session ID inherits the context's session ID. If a
source or receiver specifies its own Session ID, it overrides the context Session ID for
that individual source or receiver.</p>

<p>Of the two mutually exclusive methods for managing RegIDs, ...</p>

<ol type="1">
<li>
<p>Enable your application to assign and manage every RegID, ensuring no two objects
registered with an individual store share the same RegID.</p>
</li>

<li>
<p>Allow the store to assign every RegID and enable your application to persist the
RegIDs.</p>
</li>
</ol>

<p>... using Session IDs simplifies the second management method. Since you cannot
combine these two strategies at any single store, you also cannot combine the first
method with the use of Session IDs at a single store.</p>

<div class="SECTION">
<hr />
<h6 class="SECTION"><a id="SESSIONIDS-REGIDS" name="SESSIONIDS-REGIDS">7.1.1.3.1. How
Stores Associate Session IDs and RegIDs</a></h6>

<p>Session IDs do not replace the use of RegIDs by <b class="APPLICATION">UMP</b> but
rather simplify RegID management. Using Session IDs equates to your application
specifying a 0 (zero) RegID for all sources and receivers. However, instead of your
application persisting the RegID assigned by the store, the store maintains the RegID for
you.</p>

<p>When a store receives a registration request from a source or receiver with a
particular Session ID, it checks to see if it already has a source or receiver for that
topic/Session ID. If it does, then it responds with that source's or receiver's
RegID.</p>

<p>If it does not find a source or receiver for that topic/Session ID pair, the store
...</p>

<ol type="1">
<li>
<p>Assigns a new RegID.</p>
</li>

<li>
<p>Associates the topic/Session ID with the new RegID.</p>
</li>

<li>
<p>Responds to the source or receiver with the new RegID.</p>
</li>
</ol>

<p>The source can then advertise with the RegID supplied by the store. Receivers include
the source's RegID in their registration request.</p>
</div>
</div>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UME-SOURCES" name="UME-SOURCES">7.1.2. <b
class="APPLICATION">UMP</b> Sources</a></h4>

<p>The major concerns of sources revolve around RegID management and message retention.
This section discusses the following topics.</p>

<ul>
<li>
<p><a href="#NEW-OR-RE-REGISTRATION"><i>New or Re-Registration</i></a></p>
</li>

<li>
<p><a href="#SOURCES-MUST-BE-ABLE-TO-RESUME-SENDING"><i>Sources Must Be Able to Resume
Sending</i></a></p>
</li>

<li>
<p><a href="#SOURCE-MESSAGE-RETENTION-AND-RELEASE"><i>Source Message Retention and
Release</i></a></p>
</li>

<li>
<p><a href="#SOURCE-RELEASE-POLICY-OPTIONS"><i>Source Release Policy Options</i></a></p>
</li>

<li>
<p><a href="#CONFIRMED-DELIVERY"><i>Confirmed Delivery</i></a></p>
</li>

<li>
<p><a href="#SOURCES-USING-RR-STORE-CONFIGURATION"><i>Sources Using Round-Robin Store
Configuration</i></a></p>
</li>

<li>
<p><a href="#SOURCES-USING-QC-STORE-CONFIGURATION"><i>Sources Using Quorum/Consensus
Store Configuration</i></a></p>
</li>

<li>
<p><a href="#SOURCE-EVENT-HANDLER"><i>Source Event Handler</i></a></p>
</li>

<li>
<p><a href="#SOURCE-EVENT-HANDLER-STAB-CONF"><i>Source Event Handler - Stability,
Confirmation and Release</i></a></p>
</li>

<li>
<p><a href="#MESSAGE-NUMBERS-TO-SEQUENCE-NUMBERS"><i>Mapping Your Message Numbers to</i>
UMS/<i>UMP</i> Sequence Numbers</a></p>
</li>

<li>
<p><a href="#RECEIVER-LIVENESS-DETECTION"><i>Receiver Liveness Detection</i></a></p>
</li>
</ul>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="NEW-OR-RE-REGISTRATION" name="NEW-OR-RE-REGISTRATION">7.1.2.1.
New or Re-Registration</a></h5>

<p>Any source needs to know at start-up if it is a new registration or a re-registration.
The answer determines how a source registers with the store. <b
class="APPLICATION">UMP</b> can not answer this question. Therefore, it is essential that
the developer consider what identifies the lifetime of a source and how a source
determines the appropriate value to use as the RegID when it is ready to register. RegIDs
are per source per topic per store, thus a single RegID per store is needed.</p>

<p>The following source code examples look for an existing RegID from a file and uses a
new RegID assigned from the store if it finds no existing RegID. (See also <a
href="ume-example-src-3.c" target="doccontent">ume-example-src-3.c</a>.)</p>

<p><b class="APPLICATION">C API</b></p>

<pre class="PROGRAMLISTING">
    err = lbm_context_create(&amp;ctx, NULL, NULL, NULL);
    if (err) {printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);}

    srcinfo.message_num = 1;
    srcinfo.existing_regid = 0;
    
    err = read_src_regid_from_file(SRC_REGID_SAVE_FILENAME, store_info, sizeof(store_info));
    if (!err) { srcinfo.existing_regid = 1; }

        err = lbm_src_topic_attr_create(&amp;attr);
        if (err) {printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);}

        err = lbm_src_topic_attr_str_setopt(attr, "ume_store", store_info);
        if (err) {printf("line %d: %s\n", __LINE__, lbm_errmsg()); exit(1);}
       
</pre>

<p>The use of Session IDs allows <b class="APPLICATION">UMP</b> , as opposed to your
application, to accomplish the same RegID management. See <a
href="#SESSION-IDS"><i>Managing RegIDs with Session IDs</i></a>.</p>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="SOURCES-MUST-BE-ABLE-TO-RESUME-SENDING"
name="SOURCES-MUST-BE-ABLE-TO-RESUME-SENDING">7.1.2.2. Sources Must Be Able to Resume
Sending</a></h5>

<p>A source sends messages unless <b class="APPLICATION">UMP</b> prevents it, in which
case, the send function returns an error. A source may lose the ability to send messages
temporarily if the store(s) in use become unresponsive, e.g. the store(s) die or become
disconnected from the source. Once the store(s) are responsive again, sending can
continue. Thus source applications need to take into account that sending may fail
temporarily under specific failure cases and be able to resume sending when the failure
is removed.</p>

<p>The following source code examples demonstrate how a failed send function can sleep
for a second and try again.</p>

<p><b class="APPLICATION">C API</b></p>

<pre class="PROGRAMLISTING">
   while (lbm_src_send(src, message, len, 0) == LBM_FAILURE) {
        If (lbm_errnum() == LBM_EUMENOREG) {
            printf("Send unsuccessful. Waiting...\n");
            sleep(1);
            continue;
        }
        fprintf(stderr, "lbm_src_send: %s\n", lbm_errmsg());
                        exit(1);
                }
       
</pre>

<p><b class="APPLICATION">JAVA API</b></p>

<pre class="PROGRAMLISTING">
   for (;;) {
        try {
            src.send(message, len, 0);
        }
        catch (UMENoRegException ex) {
            System.out.println("Send unsuccessful. Waiting...");
            try {
                Thread.sleep(1000);
            }
            catch (InterruptedException e) { }
            continue;
        }
        catch (LBMException ex) {
            System.err.println("Error sending message: " + ex.toString());
System.exit(1);
        }
        break;
    }
       
</pre>

<p><b class="APPLICATION">.NET API</b></p>

<pre class="PROGRAMLISTING">
   for (;;) {
        try {
            src.send(message, len, 0);
        }
        catch (UMENoRegException ex) {
            System.Console.Out.WriteLine("Send unsuccessful. Waiting...");
            System.Threading.Thread.Sleep(1000);
            continue;
        }
        catch (LBMException ex) {
            System.Console.Out.WriteLine ("Error sending message: " + ex.toString());
System.exit(1);
        }
        break;
    }

       
</pre>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="SOURCE-MESSAGE-RETENTION-AND-RELEASE"
name="SOURCE-MESSAGE-RETENTION-AND-RELEASE">7.1.2.3. Source Message Retention and
Release</a></h5>

<p><b class="APPLICATION">UMP</b> allows streaming of messages from a source without
regard to message stability at a store, which is one reason for <b
class="APPLICATION">UMP</b>'s performance advantage over other persistent messaging
systems. Sources retain all messages until notified by the active store(s) that they are
stable. This provides a method for stores to be brought up to date when restarted or
started anew.</p>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> Source message retention is separate from the persistence of messages in
the store.</p>
</blockquote>
</div>

<p>When messages are considered stable at the store, the source can release them which
frees up source retention memory for new messages. Generally, the source releases older
stable messages first. To release the oldest retained message, all the following
conditions must be met:</p>

<ul>
<li>
<p>message must meet stability requirements of the source, which can range from a single
stability notice from the active store to stability notices from a group of stores (See
<a href="#SOURCES-USING-QC-STORE-CONFIGURATION"><i>Sources Using Quorum/Consensus Store
Configuration</i></a>)</p>

<p>and</p>
</li>

<li>
<p>message must have been confirmed as delivered by a configured number of receivers (<tt
class="LITERAL">ume_retention_unique_confirmations</tt>),</p>

<p>and</p>
</li>

<li>
<p>the aggregate amount of buffered messages exceeds <tt
class="LITERAL">retransmit_retention_size_threshold</tt> bytes in payload and
headers.</p>
</li>
</ul>

<p>Some things to note:</p>

<ul>
<li>
<p>If the <tt class="LITERAL">retransmit_retention_size_threshold</tt> is not met, no
messages will be released regardless of stability.</p>
</li>

<li>
<p>If the source registered with a "no-cache" store (See <a href="#UME-STORES"><i>UMP
Stores</i></a>) or <tt class="LITERAL">ume_message_stability_notification</tt> is turned
off, <tt class="LITERAL">ume_retention_unique_confirmations</tt> is the only way to allow
the source to release messages before retention size options come into play.</p>
</li>

<li>
<p>If the aggregate amount of buffered messages exceeds <tt
class="LITERAL">retransmit_retention_size_limit</tt> bytes in payload and headers, then
the oldest retained message is forcibly released even if it does not meet one or more of
the conditions above. This condition should be avoided and suggests increasing the <tt
class="LITERAL">retransmit_retention_size_limit</tt> or lowering the <tt
class="LITERAL">retransmit_retention_size_threshold</tt>.</p>
</li>
</ul>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="SOURCE-RELEASE-POLICY-OPTIONS"
name="SOURCE-RELEASE-POLICY-OPTIONS">7.1.2.4. Source Release Policy Options</a></h5>

<p>sources use a set of configuration options to release messages that, in effect,
specify the source's release policy. The following configuration options directly impact
when the source may release retained messages.</p>

<ul>
<li>
<p><a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMEMESSAGESTABILITYNOTIFICATION"
 target="doccontent"><tt class="LITERAL">ume_message_stability_notification</tt></a></p>
</li>

<li>
<p><a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMERETENTIONUNIQUECONFIRMATIONS"
 target="doccontent"><tt class="LITERAL">ume_retention_unique_confirmations</tt></a></p>
</li>

<li>
<p><a href="../Config/latejoinoptions.html#SOURCERETRANSMITRETENTIONSIZETHRESHOLD"
target="doccontent"><tt class="LITERAL">retransmit_retention_size_threshold</tt></a></p>
</li>

<li>
<p><a href="../Config/latejoinoptions.html#SOURCERETRANSMITRETENTIONSIZELIMIT"
target="doccontent"><tt class="LITERAL">retransmit_retention_size_limit</tt></a></p>
</li>
</ul>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="CONFIRMED-DELIVERY" name="CONFIRMED-DELIVERY">7.1.2.5.
Confirmed Delivery</a></h5>

<p>As mentioned earlier, <tt class="LITERAL">ume_retention_unique_confirmations</tt>
requires a message to have a minimum number of unique confirmations from different
receivers before the message may be released. This retains messages that have not been
confirmed as being received and processed and keeps them available to fulfill any
retransmission requests.</p>

<p>The following code samples show how to require a message to have 10 unique receiver
confirmations</p>

<p><b class="APPLICATION">C API</b></p>

<pre class="PROGRAMLISTING">
lbm_src_topic_attr_t * sattr;

if (lbm_src_topic_attr_create(&amp;sattr) == LBM_FAILURE) {
        fprintf(stderr, "lbm_src_topic_attr_create: %s\n", lbm_errmsg());
        exit(1);
}
if (lbm_src_topic_attr_str_setopt(sattr, "ume_retention_unique_confirmations",
"10") 
== LBM_FAILURE) {
        fprintf(stderr, "lbm_src_topic_attr_str_setopt: %s\n", lbm_errmsg());
        exit(1);
}
       
</pre>

<p><b class="APPLICATION">JAVA API</b></p>

<pre class="PROGRAMLISTING">
LBMSourceAttributes sattr = null;
try {
sattr = new LBMSourceAttributes();
sattr.setValue("ume_retention_unique_confirmations", "10");
}
catch (LBMException ex) {
System.err.println("Error creating source attribute: " + ex.toString());
System.exit(1);
}
       
</pre>

<p><b class="APPLICATION">.NET API</b></p>

<pre class="PROGRAMLISTING">
LBMSourceAttributes sattr = null;
try {
sattr = new LBMSourceAttributes();
sattr.setValue("ume_retention_unique_confirmations", "10");
}
catch (LBMException ex) {
System.Console.Error.WriteLine ("Error creating source attribute: " + ex.toString());
System.Environment.Exit(1);
       }
       
</pre>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="SOURCES-USING-RR-STORE-CONFIGURATION"
name="SOURCES-USING-RR-STORE-CONFIGURATION">7.1.2.6. Sources Using Round-Robin Store
Configuration</a></h5>

<p>The source retains messages until they are considered stable at the active store(s).
For Round-Robin store behavior, this means the current active store notifies the source
that it has stabilized the message via a message stability notification. The following
configuration file statements implement Round-Robin behavior among 3 stores.</p>

<pre class="PROGRAMLISTING">
source ume_store 10.29.3.77:15313:150000:0
source ume_store 10.29.3.76:16313:160000:0 
source ume_store 10.29.3.75:17313:170000:0
source ume_message_stability_notification 1
source ume_store_behavior rr 
       
</pre>

<p>See also <a href="#ROUND-ROBIN-STORE-USAGE"><i>Round-Robin Store Usage</i></a></p>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="SOURCES-USING-QC-STORE-CONFIGURATION"
name="SOURCES-USING-QC-STORE-CONFIGURATION">7.1.2.7. Sources Using Quorum/Consensus Store
Configuration</a></h5>

<p>In the case of Quorum/Consensus store behavior, a message is considered stable after
it has been successfully stored within a group of stores or among groups of stores
according to the two settings, intergroup behavior and intragroup behavior, described
below.</p>

<ul>
<li>
<p>The <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMERETENTIONINTRAGROUPSTABILITYBEHAVIOR"
 target="doccontent">intragroup behavior</a> specifies the requirements needed to stabilize a
message among the stores within a group. A message is stable for the group once it is
successfully stored at a quorum (majority) of the group's stores or successfully stored
in all the stores in the group.</p>
</li>

<li>
<p>The <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMERETENTIONINTERGROUPSTABILITYBEHAVIOR"
 target="doccontent">intergroup behavior</a> specifies the requirements needed to stabilize a
message among groups of stores. A message is stable among the groups if it is
successfully stored at any group, a majority of groups, or all groups.</p>
</li>
</ul>

<p>Notice that a message needs to meet intragroup stability requirements before it can
meet intergroup stability requirements. These options provide a number of possibilities
for retention of messages for the source.</p>

<p>The following configuration file statements implement a 3-group Quorum/Consensus
configuration with each group on a different machine, in which a message is considered
stable when it has been successfully stored at a quorum of stores in at least one group.
(See <a href="#QC-CONFIG-SINGLE-LOCATION-GROUPS"><i>Quorum/Consensus - Single Location
Groups</i></a> for more information about this configuration.)</p>

<pre class="PROGRAMLISTING">
source ume_store 10.29.3.77:10313:101000:0
source ume_store 10.29.3.77:11313:110000:0
source ume_store 10.29.3.77:12313:120000:0
source ume_store 10.29.3.77:13313:130000:0
source ume_store 10.29.3.77:14313:140000:0
source ume_store 10.29.3.78:15313:150000:1
source ume_store 10.29.3.78:16313:160000:1
source ume_store 10.29.3.78:17313:170000:1
source ume_store 10.29.3.79:18313:180000:2
source ume_store 10.29.3.79:19313:190000:2
source ume_store 10.29.3.79:29313:290000:2
source ume_store 10.29.3.79:39313:390000:2
source ume_store 10.29.3.79:49313:490000:2

source ume_message_stability_notification 1
source ume_store_behavior qc

source ume_store_group 0:5
source ume_store_group 1:3
source ume_store_group 2:5

source ume_retention_intragroup_stability_behavior quorum
source ume_retention_intergroup_stability_behavior any
       
</pre>

<p>See also <a href="#QUORUM-CONSENSUS-STORE-USAGE"><i>Quorum/Consensus Store
Usage</i></a> and <a href="#QC-CONFIG-MIXED-LOCATION-GROUPS"><i>Quorum/Consensus - Mixed
Location Groups</i></a>.</p>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="SOURCE-EVENT-HANDLER" name="SOURCE-EVENT-HANDLER">7.1.2.8.
Source Event Handler</a></h5>

<p>The Source Event Handler is a function callback initialized at source creation to
provide source events to your application related to the operation of the source. The
following source code examples illustrate the use of a source event handler for
registration events. To accept other source events, additional case statements would be
required, one for each additional source event. See also <a
href="#UME-OPS-UME-EVENTS"><i>UMP and UMQ Events</i></a>.</p>

<p><b class="APPLICATION">C API</b></p>

<pre class="PROGRAMLISTING">
int handle_src_event(lbm_src_t *src, int event, void *ed, void *cd)
{
    switch (event) {
    case LBM_SRC_EVENT_UME_REGISTRATION_ERROR:
{
const char *errstr = (const char *)ed;
        printf("Error registering source with UME store: %s\n", errstr);
}
break;
        case LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX:
            {
                lbm_src_event_ume_registration_ex_t *reg = 
                        (lbm_src_event_ume_registration_ex_t *)ed;

                    printf("UME store %u: %s registration success. RegID %u. Flags %x ", 
                                reg-&#62;store_index, reg-&#62;store, reg-&#62;registration_id, 
                                reg-&#62;flags);
                    if (reg-&#62;flags &amp; LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_OLD)
                        printf("OLD[SQN %x] ", reg-&#62;sequence_number);
                    if (reg-&#62;flags &amp; LBM_SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_NOACKS)
                        printf("NOACKS ");
                    printf("\n");
            }
         break;
        case LBM_SRC_EVENT_UME_REGISTRATION_COMPLETE_EX:
            {
                    lbm_src_event_ume_registration_complete_ex_t *reg;

                        reg  = (lbm_src_event_ume__complete_ex_t *)ed;
                    printf("UME registration complete. SQN %x. Flags %x ", reg-&#62;sequence_number, 
                        reg-&#62;flags);
                    if (reg-&#62;flags &amp; LBM_SRC_EVENT_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM)
                     printf("QUORUM ");
                    printf("\n");
            }
         break;
        case LBM_SRC_EVENT_UME_STORE_UNRESPONSIVE:
        {
            const char *infostr = (const char *)ed;
            printf("UME store: %s\n", infostr);
        }
        break;
    default:
            printf("Unknown source event %d\n", event);
            break;
    }
   return 0;
}
       
</pre>

<p><b class="APPLICATION">JAVA API</b></p>

<pre class="PROGRAMLISTING">
public int onSourceEvent(Object arg, LBMSourceEvent sourceEvent)
{
    switch (sourceEvent.type()) {
    case LBM.SRC_EVENT_UME_REGISTRATION_ERROR:
System.out.println("Error registering source with UME store: "
+ sourceEvent.dataString());
break;
    case LBM.SRC_EVENT_UME_REGISTRATION_SUCCESS_EX:
 UMESourceEventRegistrationSuccessInfo reg = sourceEvent.registrationSuccessInfo();
 System.out.print("UME store " + reg.storeIndex() + ": " + reg.store()
+ " registration success. RegID " + reg.registrationId() + ". Flags "
+ reg.flags() + " ");
                if (((reg.flags() &amp; LBM.SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_OLD)) 
                != 0) {
 System.out.print("OLD[SQN " + reg.sequenceNumber() + "] ");
                }
                if (((reg.flags() &amp; LBM.SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_NOACKS)) 
                != 0) {
System.out.print("NOACKS ");
                }
                System.out.println();
                break;
    case LBM.SRC_EVENT_UME_REGISTRATION_COMPLETE_EX:
                UMESourceEventRegistrationCompleteInfo regcomp = 
                sourceEvent.registrationCompleteInfo();
                System.out.print("UME registration complete. SQN " + regcomp.sequenceNumber()
+ ". Flags " + regcomp.flags() + " ");
                if ((regcomp.flags() &amp; 
                LBM.SRC_EVENT_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM) != 0) {
System.out.print("QUORUM ");
                }
                System.out.println();
                break;
    case LBM.SRC_EVENT_UME_STORE_UNRESPONSIVE:
                System.out.println("UME store: "
                    + sourceEvent.dataString());
                break;
    ...
    default:
                System.out.println("Unknown source event "
+ sourceEvent.type());
                break;
        }
        return 0;
}
       
</pre>

<p><b class="APPLICATION">.NET API</b></p>

<pre class="PROGRAMLISTING">
public int onSourceEvent(Object arg, LBMSourceEvent sourceEvent)
{
    switch (sourceEvent.type()) {
    case LBM.SRC_EVENT_UME_REGISTRATION_ERROR:
System.Console.Out.WriteLine("Error registering source with UME store: "
+ sourceEvent.dataString());
break;
    case LBM.SRC_EVENT_UME_REGISTRATION_SUCCESS_EX:
 UMESourceEventRegistrationSuccessInfo reg = sourceEvent.registrationSuccessInfo();
 System.Console.Out.Write("UME store " + reg.storeIndex() + ": " + reg.store()
+ " registration success. RegID " + reg.registrationId() + ". Flags "
+ reg.flags() + " ");
                if (((reg.flags() &amp; LBM.SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_OLD)) 
                != 0) {
 System.Console.Out.Write("OLD[SQN " + reg.sequenceNumber() + "] ");
                }
                if (((reg.flags() &amp; LBM.SRC_EVENT_UME_REGISTRATION_SUCCESS_EX_FLAG_NOACKS)) 
                != 0) {
System.Console.Out.Write("NOACKS ");
                }
                System.Console.Out.WriteLine();
                break;
    case LBM.SRC_EVENT_UME_REGISTRATION_COMPLETE_EX:
                UMESourceEventRegistrationCompleteInfo regcomp = 
                sourceEvent.registrationCompleteInfo();
                System.Console.Out.Write("UME registration complete. SQN " + 
                regcomp.sequenceNumber()
+ ". Flags " + regcomp.flags() + " ");
                if ((regcomp.flags() &amp; 
                LBM.SRC_EVENT_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM) != 0) {
System.Console.Out.Write("QUORUM ");
                }
                System.Console.Out.WriteLine();
                break;
    case LBM.SRC_EVENT_UME_STORE_UNRESPONSIVE:
                System.Console.Out.WriteLine("UME store: "
                          + sourceEvent.dataString());
                break;
    ...
    default:
                System.Console.Out.WriteLine("Unknown source event "
+ sourceEvent.type());
                break;
        }
        return 0;
}
       
</pre>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="SOURCE-EVENT-HANDLER-STAB-CONF"
name="SOURCE-EVENT-HANDLER-STAB-CONF">7.1.2.9. Source Event Handler - Stability,
Confirmation and Release</a></h5>

<p>As shown in <a href="#SOURCE-EVENT-HANDLER">Section 7.1.2.8</a> above, the Source
Event Handler can be expanded to handle more source events by adding additional case
statements. The following source code examples show case statements to handle message
stability events, delivery confirmation events and message release (reclaim) events. See
also <a href="#UME-OPS-UME-EVENTS"><i>UMP and UMQ Events</i></a>.</p>

<p><b class="APPLICATION">C API</b></p>

<pre class="PROGRAMLISTING">
case LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX:  
/* requires that source ume_message_stability_notification attribute is enabled */
        {
            lbm_src_event_ume_ack_ex_info_t *info = (lbm_src_event_ume_ack_ex_info_t *)ed;
    
            printf("UME store %u: %s message stable. SQN %x (msgno %d). Flags %x ", 
            info-&#62;store_index, info-&#62;store,
                    info-&#62;sequence_number, (int)info-&#62;msg_clientd - 1, info-&#62;flags);
            if (info-&#62;flags &#38; LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_INTRAGROUP_STABLE)
                    printf("IA "); /* Stable within store group */
            if (info-&#62;flags &#38; LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_INTERGROUP_STABLE)
                    printf("IR "); /* Stable amongst all stores */
            if (info-&#62;flags &#38; LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_STABLE)
                    printf("STABLE ");  /* Just plain stable */
            if (info-&#62;flags &#38; LBM_SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_STORE)
                    printf("STORE ");   /* Stability reported by UME Store */
            printf("\n");   
        }
        break;

case LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX:   
/* requires that source ume_confirmed_delivery_notification attribute is enabled */
        {
            lbm_src_event_ume_ack_ex_info_t *info = (lbm_src_event_ume_ack_ex_info_t *)ed;

                printf("UME delivery confirmation. SQN %x, Receiver RegID %u (msgno %d). Flags %x ",
                       info-&#62;sequence_number, info-&#62;rcv_registration_id, 
                       (int)info-&#62;msg_clientd - 1, info-&#62;flags);
                if (info-&#62;flags &#38; LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_UNIQUEACKS)
                    printf("UNIQUEACKS ");   
                    /* Satisfied number of unique ACKs requirement */
                if (info-&#62;flags &#38; LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_UREGID)
                    printf("UREGID ");       
                    /* Confirmation contains receiver application registration ID */
                if (info-&#62;flags &#38; LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_OOD)
                    printf("OOD ");          
                    /* Confirmation received from arrival order receiver */
                if (info-&#62;flags &#38; LBM_SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_EXACK)
                    printf("EXACK ");        
                    /* Confirmation explicitly sent by receiver */
                printf("\n");
        }
        break;
    
case LBM_SRC_EVENT_UME_MESSAGE_RECLAIMED:  
/* requires that source ume_confirmed_delivery_notification or ume_message_stability_notification 
attributes are enabled */
        {
                lbm_src_event_ume_ack_info_t *ackinfo = (lbm_src_event_ume_ack_info_t *)ed;

                printf("UME message released - sequence number %x (msgno %d)\n",
                       ackinfo-&#62;sequence_number, (int)ackinfo-&#62;msg_clientd - 1);
        }
        break;

       
</pre>

<p><b class="APPLICATION">JAVA API</b></p>

<pre class="PROGRAMLISTING">
case LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX: 
// requires that source ume_message_stability_notification attribute is enabled
        UMESourceEventAckInfo staInfo = sourceEvent.ackInfo();
        System.out.print("UME store " + staInfo.storeIndex() + ": "
                    + staInfo.store() + " message stable. SQN " + staInfo.sequenceNumber()
                    + " (msgno " + staInfo.clientObject() + "). Flags " 
                    + staInfo.flags() + " ");
        if ((staInfo.flags() &#38; LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_INTRAGROUP_STABLE) 
        != 0) {
                System.out.print("IA "); // Stable within store group
        }
        if ((staInfo.flags() &#38; LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_INTERGROUP_STABLE) 
        != 0) {
                System.out.print("IR ");  // Stable amongst all stores
        }
        if ((staInfo.flags() &#38; LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_STABLE) != 0) {
                System.out.print("STABLE ");  // Just plain stable
        }
        if ((staInfo.flags() &#38; LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_STORE) != 0) {
                System.out.print("STORE ");   // Stability reported by UME Store
        }
        System.out.println();
        break;

case LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX:  
// requires that source ume_confirmed_delivery_notification attribute is enabled
        UMESourceEventAckInfo cdelvinfo = sourceEvent.ackInfo();
        System.out.print("UME delivery confirmation. SQN " + cdelvinfo.sequenceNumber()
                    + ", RcvRegID " + cdelvinfo.receiverRegistrationId() + " (msgno "
                    + cdelvinfo.clientObject() + "). Flags " + cdelvinfo.flags() + " ");
        if ((cdelvinfo.flags() &#38; LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_UNIQUEACKS) 
        != 0) {
                System.out.print("UNIQUEACKS "); // Satisfied number of unique ACKs requirement
        }
        if ((cdelvinfo.flags() &#38; LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_UREGID) 
        != 0) {
                System.out.print("UREGID ");    // Confirmation contains receiver application 
                registration ID
        }
        if ((cdelvinfo.flags() &#38; LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_OOD) 
        != 0) {
                System.out.print("OOD ");      // Confirmation received from arrival order 
                receiver
        }
        if ((cdelvinfo.flags() &#38; LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_EXACK) 
        != 0) {
                System.out.print("EXACK ");    // Confirmation explicitly sent by receiver
        }
        System.out.println();
        break;

case LBM.SRC_EVENT_UME_MESSAGE_RECLAIMED:  
// requires that source ume_confirmed_delivery_notification or 
// ume_message_stability_notification attributes are enabled
        System.out.println("UME message released - sequence number "
                + Long.toHexString(sourceEvent.sequenceNumber())
                + " (msgno "
                + Long.toHexString(((Integer)sourceEvent.clientObject()).longValue())
                + ")");
        break;
       
</pre>

<p><b class="APPLICATION">.NET API</b></p>

<pre class="PROGRAMLISTING">
case LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX: 
// requires that source ume_message_stability_notification attribute is enabled
            UMESourceEventAckInfo staInfo = sourceEvent.ackInfo();
            System.Console.Out.Write("UME store " + staInfo.storeIndex() + ": "
                        + staInfo.store() + " message stable. SQN " + staInfo.sequenceNumber()
                        + " (msgno " + ((int)staInfo.clientObject()).ToString("x") + "). 
                        Flags " + staInfo.flags() + " ");
            if ((staInfo.flags() &#38; LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_INTRAGROUP_STABLE) 
            != 0)
            {
                    System.Console.Out.Write("IA ");  // Stable within store group
            }
            if ((staInfo.flags() &#38; LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_INTERGROUP_STABLE) 
            != 0) 
            {
                    System.Console.Out.Write("IR ");  // Stable amongst all stores
            }
            if ((staInfo.flags() &#38; LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_STABLE) != 0)
            {
                    System.Console.Out.Write("STABLE ");  // Just plain stable
            }
            if ((staInfo.flags() &#38; LBM.SRC_EVENT_UME_MESSAGE_STABLE_EX_FLAG_STORE) != 0)
            {
                    System.Console.Out.Write("STORE ");  // Stability reported by UME Store
            }
            System.Console.Out.WriteLine();
            break;

case LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX:  
// requires that source ume_confirmed_delivery_notification attribute is enabled

            UMESourceEventAckInfo cdelvinfo = sourceEvent.ackInfo();
            
            System.Console.Out.Write("UME delivery confirmation. SQN " + 
            cdelvinfo.sequenceNumber()
                        + ", RcvRegID " + cdelvinfo.receiverRegistrationId() + " (msgno "
                        + ((int)cdelvinfo.clientObject()).ToString("x") + "). Flags " + 
                        cdelvinfo.flags() + " ");
            if ((cdelvinfo.flags() &#38; 
            LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_UNIQUEACKS) != 0)
            {
                    System.Console.Out.Write("UNIQUEACKS ");  // Satisfied number of unique 
                    ACKs requirement
            }
            if ((cdelvinfo.flags() &#38; LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_UREGID) 
            != 0)
            {
                    System.Console.Out.Write("UREGID ");  // Confirmation contains receiver 
                    application registration ID
            }
            if ((cdelvinfo.flags() &#38; LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_OOD) 
            != 0)
            {
                    System.Console.Out.Write("OOD ");  // Confirmation received from arrival 
                    order receiver
            }
            if ((cdelvinfo.flags() &#38; LBM.SRC_EVENT_UME_DELIVERY_CONFIRMATION_EX_FLAG_EXACK) 
            != 0)
            {
                    System.Console.Out.Write("EXACK ");  // Confirmation explicitly sent by 
                    receiver
            }
            System.Console.Out.WriteLine();                    
            break;

case LBM.SRC_EVENT_UME_MESSAGE_RECLAIMED: 
// requires that source ume_confirmed_delivery_notification or 
// ume_message_stability_notification attributes are enabled
            
            System.Console.Out.WriteLine("UME message released - sequence number "
                               + sourceEvent.sequenceNumber().ToString("x")
                               + " (msgno "
                               + ((int)sourceEvent.clientObject()).ToString("x")
                               + ")");
            break;

       
</pre>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="MESSAGE-NUMBERS-TO-SEQUENCE-NUMBERS"
name="MESSAGE-NUMBERS-TO-SEQUENCE-NUMBERS">7.1.2.10. Mapping Your Message Numbers to <b
class="APPLICATION">UMS</b>/<b class="APPLICATION">UMP</b> Sequence Numbers</a></h5>

<p><tt class="LITERAL">lbm_src_sendv_ex()</tt> allows you to create a pointer to an
object or structure. This pointer will be returned to your application along with all
source events. You can then update the object or structure with source event information.
For example, if your messages exceed 8K - which requires fragmentation your application's
message into more than one <b class="APPLICATION">UM</b> message - receiving sequence
number events with this pointer allows you to determine all the <b
class="APPLICATION">UM</b> sequence numbers for the message and, therefore, how many
release (reclaim) events to expect. The following two source code examples show how
to:</p>

<ul>
<li>
<p>Enable message sequence number information</p>
</li>

<li>
<p>Handle sequence number source events to determine the application message number in
the Source Event Handler</p>
</li>
</ul>

<p><b class="APPLICATION">C API - Enable Message Information</b></p>

<pre class="PROGRAMLISTING">
lbm_src_send_ex_info_t exinfo;

/* Enable message sequence number info to be returned */
exinfo.flags = LBM_SRC_SEND_EX_FLAG_UME_CLIENTD | LBM_SRC_SEND_EX_FLAG_SEQUENCE_NUMBER_INFO;
exinfo.ume_msg_clientd = (void *)(msgno + 1); 
/* msgno set to application message number (can't evaluate to NULL) */
while (lbm_src_send_ex(src, message, msglen, 0, &amp;exinfo) == LBM_FAILURE)
{
    if (lbm_errnum() == LBM_EUMENOREG)
        {
        printf("Send unsuccessful. Waiting...\n");
                SLEEP_MSEC(1000);   /* Sleep for 1 second */
        }
    else
    {
        fprintf(stderr, "lbm_src_send: %s\n", lbm_errmsg());
        break;
    }
}
       
</pre>

<p><b class="APPLICATION">C API - Sequence Number Event Handler</b></p>

<pre class="PROGRAMLISTING">
int handle_src_event(lbm_src_t *src, int event, void *ed, void *cd)
{
      switch (event) {
      case LBM_SRC_EVENT_SEQUENCE_NUMBER_INFO:
            {
                  lbm_src_event_sequence_number_info_t *info = 
                  (lbm_src_event_sequence_number_info_t *)ed;

                  if (info-&#62;first_sequence_number != info-&#62;last_sequence_number) {
                        printf("SQN [%x,%x] (msgno %d)\n", info-&#62;first_sequence_number, 
                        info-&#62;last_sequence_number, (int)info-&#62;msg_clientd - 1);
                  } else {
                        printf("SQN %x (msgno %d)\n", info-&#62;last_sequence_number, 
                        (int)info-&#62;msg_clientd - 1);
                }
            }
            break;
      ...
      }
      return 0;
}
       
</pre>

<p><b class="APPLICATION">JAVA API - Enable Message Information</b></p>

<pre class="PROGRAMLISTING">
LBMSourceSendExInfo exinfo = new LBMSourceSendExInfo();
exinfo.setClientObject(new Integer(msgno));  // msgno set to application message number
exinfo.setFlags(LBM.SRC_SEND_EX_FLAG_SEQUENCE_NUMBER_INFO);  
// Enable message sequence number info to be returned 
for (;;)
{
    try 
    {
        src.send(message, msglen, 0, exinfo);
    }
    catch(UMENoRegException ex)
    {
            try
            {
                Thread.sleep(1000);
            }
            catch (InterruptedException e) { }
        continue;

    }
    catch (LBMException ex)
    {
            System.err.println("Error sending message: " + ex.toString());  
    }
    break;
}
       
</pre>

<p><b class="APPLICATION">JAVA API - Sequence Number Event Handler</b></p>

<pre class="PROGRAMLISTING">
public int onSourceEvent(Object arg, LBMSourceEvent sourceEvent)
{
      switch (sourceEvent.type())
      {
            case LBM.SRC_EVENT_SEQUENCE_NUMBER_INFO:
                  LBMSourceEventSequenceNumberInfo info = sourceEvent.sequenceNumberInfo();
                  if (info.firstSequenceNumber() != info.lastSequenceNumber()) {
                        System.out.println("SQN [" + info.firstSequenceNumber()
                            + "," + info.lastSequenceNumber() + "] (msgno "
                            + info.clientObject() + ")");
                  }
                  else {
                        System.out.println("SQN " + info.lastSequenceNumber()
                            + " (msgno " + info.clientObject() + ")");
                  }
                  break;
          ...
      }
      return 0;
}
       
</pre>

<p><b class="APPLICATION">.NET API - Enable Message Information</b></p>

<pre class="PROGRAMLISTING">
LBMSourceSendExInfo exinfo = new LBMSourceSendExInfo();
exinfo.setClientObject(msgno);  // msgno set to application message number
exinfo.setFlags(LBM.SRC_SEND_EX_FLAG_SEQUENCE_NUMBER_INFO);  
// Enable message sequence number info to be returned
for (;;)
{
    try 
    {
        src.send(message, msglen, 0, exinfo);
    }
    catch(UMENoRegException ex)
    {
            System.Threading.Thread.Sleep(100);
        continue;

    }
    catch (LBMException ex)
    {
            System.Console.Out.WriteLine("Error sending message: " + ex.Message()); 
    }
    break;
}
       
</pre>

<p><b class="APPLICATION">.NET API - Sequence Number Event Handler</b></p>

<pre class="PROGRAMLISTING">
public void onSourceEvent(Object arg, LBMSourceEvent sourceEvent)
{
      switch (sourceEvent.type())
      {
            case LBM.SRC_EVENT_SEQUENCE_NUMBER_INFO:
                  LBMSourceEventSequenceNumberInfo info = sourceEvent.sequenceNumberInfo();
                  if (info.firstSequenceNumber() != info.lastSequenceNumber())
                  {
                        System.Console.Out.WriteLine("SQN [" + info.firstSequenceNumber()
                              + "," + info.lastSequenceNumber() + "] (cd "
                              + ((int)info.clientObject()).ToString("x") + ")");
                  }
                  else
                  {
                        System.Console.Out.WriteLine("SQN " + info.lastSequenceNumber()
                              + " (msgno " + ((int)info.clientObject()).ToString("x") + ")");
                  }
                  break;
          ...

      }
      return 0;
}
       
</pre>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="RECEIVER-LIVENESS-DETECTION"
name="RECEIVER-LIVENESS-DETECTION">7.1.2.11. Receiver Liveness Detection</a></h5>

<p>As an extension to <a href="#CONFIRMED-DELIVERY"><i>Confirmed Delivery</i></a>, you
can set receivers to send a keepalive to a source during a measured absence of delivery
confirmations (due to traffic lapse). In the event that neither message reaches the
source within a designated interval, or if the delivery confirmation TCP connection
breaks down, the receiver is assumed to have "died". <b class="APPLICATION">UM</b> then
notifies the publishing application via context event callback. This lets the publisher
assign a new subscriber.</p>

<p>To use this feature, set these five configuration options:</p>

<ul>
<li>
<p><a href="../Config/ultramessagingpersistenceoptions.html#UMESOURCELIVENESSTIMEOUT"
target="doccontent"><tt class="LITERAL">ume_source_liveness_timeout</tt></a></p>
</li>

<li>
<p><a href="../Config/ultramessagingpersistenceoptions.html#UMERECEIVERLIVENESSINTERVAL"
target="doccontent"><tt class="LITERAL">ume_receiver_liveness_interval</tt></a></p>
</li>

<li>
<p><a
href="../Config/ultramessagingpersistenceoptions.html#UMECONFIRMEDDELIVERYNOTIFICATION"
target="doccontent"><tt class="LITERAL">ume_confirmed_delivery_notification</tt></a></p>
</li>

<li>
<p><a
href="../Config/ultramessagingpersistenceoptions.html#UMEUSERRECEIVERREGISTRATIONID"
target="doccontent"><tt class="LITERAL">ume_user_receiver_registration_id</tt></a></p>
</li>

<li>
<p><a href="../Config/ultramessagingpersistenceoptions.html#UMESESSIONID"
target="doccontent"><tt class="LITERAL">ume_session_id</tt></a></p>
</li>
</ul>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> You must set the <tt class="LITERAL">ume_source_liveness_timeout</tt>
option to 5 times the value of <tt
class="LITERAL">ume_receiver_liveness_interval</tt>.</p>
</blockquote>
</div>

<p>This specialized feature is not recommended for general use. If you are considering
it, please note the following caveats:</p>

<ul>
<li>
<p>Do not use in conjunction with a <b class="APPLICATION">UM</b> Gateway.</p>
</li>

<li>
<p>There is a variety of potential network occurrences that can break or reset the TCP
connection and falsely indicate the death of a receiver.</p>
</li>

<li>
<p>In cases where a receiver object is deleted while its context is not, the publisher
may still falsely assume the receiver to be alive. Other false receiver-alive assumptions
could be caused by the following:</p>
</li>

<li>
<p>TCP connections can enter a half-open or otherwise corrupted state.</p>
</li>

<li>
<p>Failed TCP connections sometimes do not fully close, or experience objectionable
delays before fully closing.</p>
</li>

<li>
<p>A switch or router failure along the path does not affect the TCP connection
state.</p>
</li>
</ul>
</div>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UME-RECEIVERS" name="UME-RECEIVERS">7.1.3. <b
class="APPLICATION">UMP</b> Receivers</a></h4>

<p>Receivers are predominantly interested in RegID management and recovery management.
This section discusses the following topics.</p>

<ul>
<li>
<p><a href="#RECEIVER-REGID-MANAGEMENT"><i>Receiver RegID Management</i></a></p>
</li>

<li>
<p><a href="#RECEIVER-MESSAGE-EVENT-HANDLER"><i>Receiver Message and Event
Handler</i></a></p>
</li>

<li>
<p><a href="#RECOVERY-MANAGEMENT"><i>Recovery Management</i></a></p>
</li>

<li>
<p><a href="#SETTING-CALLBACK-FOR-RECOVERY-SEQUENCE-NUMBER"><i>Setting Callback Function
to Set Recovery Sequence Number</i></a></p>
</li>

<li>
<p><a href="#MESSAGE-CONSUMPTION"><i>Message Consumption</i></a></p>
</li>
</ul>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="RECEIVER-REGID-MANAGEMENT"
name="RECEIVER-REGID-MANAGEMENT">7.1.3.1. Receiver RegID Management</a></h5>

<p>RegIDs are slightly more involved for receivers than for sources. Since RegIDs are per
source per topic per store and a topic may have several sources, a receiver may have to
manage several RegIDs per store in use. Fortunately, receivers in <b
class="APPLICATION">UMP</b> can leverage the RegID of the source with the use of a
callback as discussed in <a href="#TUTORIAL-ADDINGFAULTRECOVERY"><i>Adding Fault Recovery
with Registration IDs</i></a> and shown in <a href="ume-example-rcv-2.c"
target="doccontent">ume-example-rcv-2.c</a>. Your application can determine the correct RegID
to use and return it to <b class="APPLICATION">UMP</b> . You can also use Session IDs to
enable <b class="APPLICATION">UMP</b> to manage receiver RegIDs. See <a
href="#SESSION-IDS"><i>Managing RegIDs with Session IDs</i></a>.</p>

<p>Much like sources, receivers typically have a lifetime based on an amount of work,
perhaps an infinite amount. And just like sources, it may be helpful to consider that a
RegID is "assigned" at the start of that work and is out of use at the end. In between,
the RegID is in use by the instance of the receiver application. However, the nature of
RegIDs being per source means that the expected lifetime of a source should play a role
in how RegIDs on the receiver are managed. Thus, it may be helpful for the application
developer to consider the source application lifetime when deciding how best to handle
RegIDs on the receiver.</p>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="RECEIVER-MESSAGE-EVENT-HANDLER"
name="RECEIVER-MESSAGE-EVENT-HANDLER">7.1.3.2. Receiver Message and Event
Handler</a></h5>

<p>The Receiver Message and Event Handler is a function callback started at receiver
initialization to provide Receiver messages to your application on behalf of the
receiver. The following source code examples illustrate the use of a receiver message and
event handler for registration messages. To accept other receiver events, additional case
statements would be required, one for each additional event. See also <a
href="#UME-OPS-UME-EVENTS"><i>UMP and UMQ Events</i></a>.</p>

<p><b class="APPLICATION">C API</b></p>

<pre class="PROGRAMLISTING">
int rcv_handle_msg(lbm_rcv_t *rcv, lbm_msg_t *msg, void *clientd)
{
    switch (msg-&#62;type) {
    ...
    case LBM_MSG_UME_REGISTRATION_ERROR:
            printf("[%s][%s] UME registration error: %s\n", msg-&#62;topic_name, msg-&#62;source, 
                msg-&#62;data); 
            exit(0);
    break;
    case LBM_MSG_UME_REGISTRATION_SUCCESS:
            {
                    lbm_msg_ume_registration_t *reg = (lbm_msg_ume_registration_t *)
                        (msg-&#62;data);

                    printf("[%s][%s] UME registration successful. SrcRegID %u RcvRegID %u\n",
                     msg-&#62;topic_name, msg-&#62;source, reg-&#62;src_registration_id, 
                         reg-&#62;rcv_registration_id);
            }
         break;
    case LBM_MSG_UME_REGISTRATION_SUCCESS_EX:
            {
                    lbm_msg_ume_registration_ex_t *reg = (lbm_msg_ume_registration_ex_t *)
                        (msg-&#62;data);

                    printf("[%s][%s] store %u: %s UME registration successful. SrcRegID %u 
                        RcvRegID %u. Flags %x ",
                msg-&#62;topic_name, msg-&#62;source, reg-&#62;store_index, reg-&#62;store,
                reg-&#62;src_registration_id, reg-&#62;rcv_registration_id, reg-&#62;flags);
                if (reg-&#62;flags &amp; LBM_MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_OLD)
                     printf("OLD[SQN %x] ", reg-&#62;sequence_number);
                    if (reg-&#62;flags &amp; LBM_MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_NOCACHE)
                        printf("NOCACHE ");
                    printf("\n");
            }
            break;
    case LBM_MSG_UME_REGISTRATION_COMPLETE_EX:
         {
                    lbm_msg_ume_registration_complete_ex_t *reg;

reg  = (lbm_msg_ume_registration_complete_ex_t *)(msg-&#62;data);
printf("[%s][%s] UME registration complete. SQN %x. Flags %x ",
                    msg-&#62;topic_name, msg-&#62;source, reg-&#62;sequence_number, reg-&#62;flags);
                    if (reg-&#62;flags &amp; LBM_MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM)
                     printf("QUORUM ");
                 if (reg-&#62;flags &amp; LBM_MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_RXREQMAX)
                        printf("RXREQMAX ");
                    printf("\n");
            }
        break;
    case LBM_MSG_UME_REGISTRATION_CHANGE:
            printf("[%s][%s] UME registration change: %s\n", msg-&#62;topic_name, msg-&#62;source, 
                msg-&#62;data);
            break;
    ...
    default:
            printf("Unknown lbm_msg_t type %x [%s][%s]\n", msg-&#62;type, msg-&#62;topic_name, 
                msg-&#62;source);
         break;
    }
    return 0;
}
       
</pre>

<p><b class="APPLICATION">JAVA API</b></p>

<pre class="PROGRAMLISTING">
public int onReceive(Object cbArg, LBMMessage msg) 
{
    case LBM.MSG_UME_REGISTRATION_ERROR:
            System.out.println("[" + msg.topicName() + "][" + msg.source()
                    + "] UME registration error: " + msg.dataString());
            break;
    case LBM.MSG_UME_REGISTRATION_SUCCESS_EX:
            UMERegistrationSuccessInfo reg = msg.registrationSuccessInfo();
            System.out.print("[" + msg.topicName() + "][" + msg.source()
                    + "] store " + reg.storeIndex() + ": "
                    + reg.store() + " UME registration successful. SrcRegID "
                    + reg.sourceRegistrationId() + " RcvRegID " + reg.receiverRegistrationId()
                    + ". Flags " + reg.flags() + " ");
            if ((reg.flags() &amp; LBM.MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_OLD) != 0)
                System.out.print("OLD[SQN " + reg.sequenceNumber() + "] ");
            if ((reg.flags() &amp; LBM.MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_NOCACHE) != 0)
                System.out.print("NOCACHE ");
            System.out.println();
            break;
    case LBM.MSG_UME_REGISTRATION_COMPLETE_EX:
            UMERegistrationCompleteInfo regcomplete = msg.registrationCompleteInfo();
            System.out.print("[" + msg.topicName() + "][" + msg.source()
                    + "] UME registration complete. SQN " + regcomplete.sequenceNumber()
                    + ". Flags " + regcomplete.flags() + " ");
            if ((regcomplete.flags() &amp; LBM.MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM) 
            != 0) {
                System.out.print("QUORUM ");
            }
            if ((regcomplete.flags() &amp; LBM.MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_RXREQMAX) 
            != 0) {
                System.out.print("RXREQMAX ");
            }
            System.out.println();
            break;
    case LBM.MSG_UME_REGISTRATION_CHANGE:
            System.out.println("[" + msg.topicName() + "][" + msg.source()
                    + "] UME registration change: " + msg.dataString());
            break;
    ...
    default:
            System.err.println("Unknown lbm_msg_t type " + msg.type() + " ["
                    + msg.topicName() + "][" + msg.source() + "]");
            break;
        }
    return 0;
}
       
</pre>

<p><b class="APPLICATION">.NET API</b></p>

<pre class="PROGRAMLISTING">
public int onReceive(Object cbArg, LBMMessage msg) 
{
    case LBM.MSG_UME_REGISTRATION_ERROR:
            System. Console.Out.WriteLine("[" + msg.topicName() + "][" + msg.source()
                    + "] UME registration error: " + msg.dataString());
            break;
    case LBM.MSG_UME_REGISTRATION_SUCCESS_EX:
            UMERegistrationSuccessInfo reg = msg.registrationSuccessInfo();
            System.Console.Out.Write("[" + msg.topicName() + "][" + msg.source()
                    + "] store " + reg.storeIndex() + ": "
                    + reg.store() + " UME registration successful. SrcRegID "
                    + reg.sourceRegistrationId() + " RcvRegID " + reg.receiverRegistrationId()
                    + ". Flags " + reg.flags() + " ");
            if ((reg.flags() &amp; LBM.MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_OLD) != 0)
                    System.Console.Out.Write ("OLD[SQN " + reg.sequenceNumber() + "] ");
            if ((reg.flags() &amp; LBM.MSG_UME_REGISTRATION_SUCCESS_EX_FLAG_NOCACHE) != 0)
                    System.Console.Out.Write ("NOCACHE ");
            System.Console.Out.WriteLine();
            break;
    case LBM.MSG_UME_REGISTRATION_COMPLETE_EX:
            UMERegistrationCompleteInfo regcomplete = msg.registrationCompleteInfo();
            System.Console.Out.Write("[" + msg.topicName() + "][" + msg.source()
                    + "] UME registration complete. SQN " + regcomplete.sequenceNumber()
                    + ". Flags " + regcomplete.flags() + " ");
            if ((regcomplete.flags() &amp; LBM.MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_QUORUM) 
            != 0) {
                System.Console.Out.Write("QUORUM ");
            }
            if ((regcomplete.flags() &amp; LBM.MSG_UME_REGISTRATION_COMPLETE_EX_FLAG_RXREQMAX) 
            != 0) {
                System.Console.Out.Write("RXREQMAX ");
            }
System.Console.Out.WriteLine();
            break;
    case LBM.MSG_UME_REGISTRATION_CHANGE:
            System.Console.Out.WriteLine("[" + msg.topicName() + "][" + msg.source()
                    + "] UME registration change: " + msg.dataString());
            break;
    ...
    default:
            System.Console.Out.WriteLine("Unknown lbm_msg_t type " + msg.type() + " ["
                    + msg.topicName() + "][" + msg.source() + "]");
            break;
        }
    return 0;
}
       
</pre>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="RECOVERY-MANAGEMENT" name="RECOVERY-MANAGEMENT">7.1.3.3.
Recovery Management</a></h5>

<p>Recovery management for receivers is fairly simple because <b
class="APPLICATION">UMP</b> requests any missing messages from the store(s) and delivers
them as they are retransmitted. However, your application can specify a different message
to begin retransmission with using either the <a
href="../Config/latejoinoptions.html#RECEIVERRETRANSMITREQUESTMAXIMUM" target="doccontent"><tt
class="LITERAL">retransmit_request_maximum</tt></a> configuration option or <tt
class="LITERAL">lbm_ume_rcv_recovery_info_ex_func_t</tt>.</p>

<p>For example, assume a source sends 7 messages with sequence numbers 0-6 which are
stabilized at the store. The receiver, configured with the <a
href="../Config/latejoinoptions.html#RECEIVERRETRANSMITREQUESTMAXIMUM" target="doccontent"><tt
class="LITERAL">retransmit_request_maximum</tt></a> set to 2, consumes message 0, goes
down, then comes back at message 6. <tt
class="LITERAL">lbm_ume_rcv_recovery_info_ex_func_t</tt> returns the following:</p>

<pre class="PROGRAMLISTING">
high_sequence_number = 6
low_rxreq_max_sequence_number = 4
low_sequence_number = 1

NOTE: low_rxreq_max_sequence_number = high_sequence_number - retransmit_request_maximum
       
</pre>

<ul>
<li>
<p><b class="APPLICATION">UMP</b> obeys the <a
href="../Config/latejoinoptions.html#RECEIVERRETRANSMITREQUESTMAXIMUM" target="doccontent"><tt
class="LITERAL">retransmit_request_maximum</tt></a> configuration option and restarts
with message 4. This is the default.</p>
</li>

<li>
<p>If you modify the <tt class="LITERAL">low_sequence_number</tt> to satisfy some other
requirements, you can override the configuration option and restart at message 0, 2, 3, 5
or 6. See <a href="#SETTING-CALLBACK-FOR-RECOVERY-SEQUENCE-NUMBER"><i>Setting Callback
Function to Set Recovery Sequence Number</i></a> below.</p>
</li>

<li>
<p>The only way to restart at message 1 in this case, is to set the <a
href="../Config/latejoinoptions.html#RECEIVERRETRANSMITREQUESTMAXIMUM" target="doccontent"><tt
class="LITERAL">retransmit_request_maximum</tt></a> configuration option to its default
value of 0. If your application changes the <tt class="LITERAL">low_sequence_number</tt>
and for whatever reason, the calculation results in the same value as the <tt
class="LITERAL">low_sequence_number</tt>, <b class="APPLICATION">UMP</b> ignores the
calculation and restarts with message 4.</p>
</li>
</ul>

<p>All messages retransmitted to a receiver are marked as retransmissions via a flag in
the message structure. Thus it is easy for an application to determine if a message is a
new message from the source or a retransmission, which may or may not have been processed
before the failure. The presence or absence of the retransmit flag gives the application
a hint of how best to handle the message with regard to it being processed previously or
not.</p>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="SETTING-CALLBACK-FOR-RECOVERY-SEQUENCE-NUMBER"
name="SETTING-CALLBACK-FOR-RECOVERY-SEQUENCE-NUMBER">7.1.3.4. Setting Callback Function
to Set Recovery Sequence Number</a></h5>

<p>The sample source code below demonstrates how to use the recovery sequence number info
function to determine the stored message with which to restart a receiver. This method
retrieves the low sequence number from the recovery sequence number structure and adds an
offset to determine the beginning sequence number. The offset is a value completely under
the control of your application. For example, if a receiver was down for a "long" period
and you only want the receiver to receive the last 10 messages, use an offset to start
the receiver with the 10th most recent message. If you wish not to receive any messages,
set the <tt class="LITERAL">low_sequence_number</tt> to the <tt
class="LITERAL">high_sequence_number</tt> plus one.</p>

<p><b class="APPLICATION">C API</b></p>

<pre class="PROGRAMLISTING">
lbm_ume_rcv_recovery_info_ex_func_t cb;

cb.func = ume_rcv_seqnum_ex;
cb.clientd = NULL;
if (lbm_rcv_topic_attr_setopt(&amp;rcv_attr, "ume_recovery_sequence_number_info_function", 
&amp;cb, sizeof(cb)) == LBM_FAILURE) {
            fprintf(stderr, 
            "lbm_rcv_topic_attr_setopt:ume_recovery_sequence_number_info_function: %s\n", 
            lbm_errmsg());
            exit(1);
}
printf("Will use seqnum info with low offset %u.\n", seqnum_offset); 

int ume_rcv_seqnum_ex(lbm_ume_rcv_recovery_info_ex_func_info_t *info, void *clientd)
{
     lbm_uint_t new_lo = info-&#62;low_sequence_number + seqnum_offset;

     printf("[%s] SQNs Low %x (will set to %x), Low rxreqmax %x, High %x (CD %p)\n",
info-&#62;source, info-&#62;low_sequence_number,
             new_lo, info-&#62;low_rxreq_max_sequence_number, info-&#62;high_sequence_number, 
info-&#62;source_clientd);
        info-&#62;low_sequence_number = new_lo;
        return 0;
}
       
</pre>

<p><b class="APPLICATION">JAVA API</b></p>

<pre class="PROGRAMLISTING">
UMERcvRecInfo umerecinfocb = new UMERcvRecInfo(seqnum_offset);
rcv_attr.setRecoverySequenceNumberCallback(umerecinfocb, null);
System.out.println("Will use seqnum info with low offset " + seqnum_offset + ".");

class UMERcvRecInfo implements UMERecoverySequenceNumberCallback {
    private long _seqnum_offset = 0;

    public UMERcvRecInfo(long seqnum_offset) {
        _seqnum_offset = seqnum_offset;
    }

    public int setRecoverySequenceNumberInfo(Object cbArg, 
    UMERecoverySequenceNumberCallbackInfo cbInfo) 
    {
long new_low = cbInfo.lowSequenceNumber() + _seqnum_offset;
if (new_low &#60; 0) {
System.out.println("New low sequence number would be negative.  
Leaving low SQN unchanged.");
new_low = cbInfo.lowSequenceNumber();
         }
            System.out.println("SQNs Low " + cbInfo.lowSequenceNumber() + " (will set to "
                    + new_low + "), Low rxreqmax " + cbInfo.lowRxReqMaxSequenceNumber()
                 + ", High " + cbInfo.highSequenceNumber());
            try {
                    cbInfo.setLowSequenceNumber(new_low);
         }
            catch (LBMEInvalException e) {
                    System.err.println(e.getMessage());
        }
            return 0;
 }
       
</pre>

<p><b class="APPLICATION">.NET API</b></p>

<pre class="PROGRAMLISTING">
UMERcvRecInfo umerecinfocb = new UMERcvRecInfo(seqnum_offset);
rcv_attr.setRecoverySequenceNumberCallback(umerecinfocb, null);
System.Console.Out.WriteLine("Will use seqnum info with low offset " + seqnum_offset + ".");

class UMERcvRecInfo implements UMERecoverySequenceNumberCallback {
    private long _seqnum_offset = 0;

    public UMERcvRecInfo(long seqnum_offset) {
        _seqnum_offset = seqnum_offset;
    }

    public int setRecoverySequenceNumberInfo(Object cbArg, 
    UMERecoverySequenceNumberCallbackInfo cbInfo) 
    {
long new_low = cbInfo.lowSequenceNumber() + _seqnum_offset;
if (new_low &#60; 0) {
System.Console.Out.WriteLine ("New low sequence number would be negative.  
Leaving low SQN unchanged.");
new_low = cbInfo.lowSequenceNumber();
         }
            System.Console.Out.WriteLine ("SQNs Low " + cbInfo.lowSequenceNumber() + " 
                (will set to "
                    + new_low + "), Low rxreqmax " + cbInfo.lowRxReqMaxSequenceNumber()
                 + ", High " + cbInfo.highSequenceNumber());
            try {
                    cbInfo.setLowSequenceNumber(new_low);
         }
            catch (LBMEInvalException e) {
                    System.Console.Out.WriteLine (e.getMessage());
        }
            return 0;
 }
       
</pre>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="MESSAGE-CONSUMPTION" name="MESSAGE-CONSUMPTION">7.1.3.5.
Message Consumption</a></h5>

<p>Receivers use message consumption, defined as message deletion, to indicate that <b
class="APPLICATION">UMP</b> should notify the store(s) that the application consumed the
message. This notification takes the form of an acknowledgement, or ACK, to the store(s)
in use as well as to the source if you configured the source for <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMECONFIRMEDDELIVERYNOTIFICATION"
 target="doccontent">delivery confirmation</a>.</p>

<ul>
<li>
<p>In the <a href="../API/index.html" target="doccontent">C API</a>, message deletion happens
by default when the receive callback returns, unless the callback uses <code
class="FUNCTION">lbm_msg_retain()</code>. If the callback uses <code
class="FUNCTION">lbm_msg_retain()</code> then the application has responsibility to use
<code class="FUNCTION">lbm_msg_delete()</code> when it has finished processing the
message.</p>
</li>

<li>
<p>In the <a href="../JavaAPI/html/index.html" target="doccontent">Java API</a> and <a
href="../DotNetAPI/doc/Index.html" target="doccontent">.NET API</a>, message deletion must be
triggered explicitly by the application by using the <tt class="LITERAL">dispose()</tt>
method of the message object. Without explicit usage of <tt
class="LITERAL">dispose()</tt>, <b class="APPLICATION">UMP</b> does not know when the
application has finished processing the message.</p>
</li>
</ul>

<div class="SECTION">
<hr />
<h6 class="SECTION"><a id="BATCHINGACKS" name="BATCHINGACKS">7.1.3.5.1. Batching
Acknowledgments</a></h6>

<p>You can configure <b class="APPLICATION">UMP</b> to acknowledge message consumption to
a store(s) for a series of messages independent of when the receiving application
consumed the messages. This option works well if multiple threads process messages off of
an event queue, which may result in messages being consumed out of order. This feature is
not compatible with <a href="#EXPLICITACKS"><i>Explicit Acknowledgments</i></a>.</p>

<p>If you set <a
href="../Config/ultramessagingpersistenceoptions.html#RECEIVERUMEUSEACKBATCHING"
target="doccontent"><tt class="LITERAL">ume_use_ack_batching</tt></a> to <b
class="APPLICATION">1</b>, <b class="APPLICATION">UMP</b> does not acknowledge individual
messages as the application consumes them. Instead, <b class="APPLICATION">UMP</b> checks
the consumed, but unacknowledged messages at the interval configured with <a
href="../Config/ultramessagingpersistenceoptions.html#CONTEXTUMEACKBATCHINGINTERVAL"
target="doccontent"><tt class="LITERAL">ume_ack_batching_interval</tt></a>. When <b
class="APPLICATION">UMP</b> discovers a contiguous series of consumed message sequence
numbers (<tt class="LITERAL">sqn</tt>), it sends acknowledgments to the store(s) for all
the contiguous messages.</p>

<p>For example, assume your application consumes and acknowledges messages 1 and 2, then
consumes subsequent messages in the following order: 4, 5, 7, 8, 6, 10, 3. At the next <a
href="../Config/ultramessagingpersistenceoptions.html#CONTEXTUMEACKBATCHINGINTERVAL"
target="doccontent"><tt class="LITERAL">ume_ack_batching_interval</tt></a>, <b
class="APPLICATION">UMP</b> sends consumption acknowledgments to the store(s) for
messages 3 - 8.</p>
</div>

<div class="SECTION">
<hr />
<h6 class="SECTION"><a id="EXPLICITACKS" name="EXPLICITACKS">7.1.3.5.2. Explicit
Acknowledgments</a></h6>

<p>In addition, <b class="APPLICATION">UMP</b> supports Explicit ACKs ( <a
href="../Config/ultramessagingpersistenceoptions.html#RECEIVERUMEEXPLICITACKONLY"
target="doccontent"><tt class="LITERAL">ume_explicit_ack_only</tt></a>), which silences <b
class="APPLICATION">UMP</b>'s acknowledgement behavior, allowing your application control
of message consumption notification. See also <code
class="FUNCTION">lbm_msg_ume_send_explicit_ack()</code> in the <a
href="../API/index.html" target="doccontent">C API</a> and the <tt
class="LITERAL">LBMMessage</tt> class method <code
class="FUNCTION">sendExplicitAck()</code> in the <a href="../JavaAPI/html/index.html"
target="doccontent">Java API</a> and <a href="../DotNetAPI/doc/Index.html" target="doccontent">.NET
API</a>.</p>

<p>The explicit ACK sending function/method automatically supplies additional ACKs for
missing messages in sequence number gaps. This can be a useful efficiency feature, but
note that to acknowledge each message consumption individually, you must issue their ACKs
in ascending sequence-number order.</p>
</div>

<div class="SECTION">
<hr />
<h6 class="SECTION"><a id="OBJECT-FREEEXPLICITACKS"
name="OBJECT-FREEEXPLICITACKS">7.1.3.5.3. Object-free Explicit Acknowledgments</a></h6>

<p>When using explicit ACKs in your <a href="../JavaAPI/html/index.html"
target="doccontent">Java</a> or <a href="../DotNetAPI/doc/Index.html" target="doccontent">.NET</a>
application, you can extract ACK information from messages and then send acknowledgements
to the store(s) for any sequence number. You can also extract ACK information from a
message when using the <a href="../API/index.html" target="doccontent">C API</a> with <code
class="FUNCTION">lbm_msg_extract_ume_ack()</code>.</p>

<p>The following source code examples show how to extract ACK information and send an
explicit ACK.</p>

<p><b class="APPLICATION">C API</b></p>

<pre class="PROGRAMLISTING">
int rcv_handle_msg(lbm_rcv_t *rcv, lbm_msg_t *msg, void *clientd)
{
    lbm_ume_rcv_ack_t *ack = NULL;
...

    ack = lbm_msg_extract_ume_ack(msg);
    lbm_ume_ack_send_explicit_ack(ack, msg-&#62;sequence_number);
    lbm_ume_ack_delete(ack);
...

}
       
</pre>

<p><b class="APPLICATION">JAVA API or .NET API</b></p>

<pre class="PROGRAMLISTING">
public int onReceive(Object cbArg, LBMMessage msg)
{
    UMEMessageAck ack;
...

    ack = msg.extractUMEAck();
    ack.sendExplicitAck(msg.sequenceNumber());
    ack.dispose();

...

}
       
</pre>
</div>
</div>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UME-STORES" name="UME-STORES">7.1.4. <b
class="APPLICATION">UMP</b> Stores</a></h4>

<p>As mentioned in <a href="#UMECONCEPTS-PERSISTENCESTORE"><i>Persistent Store</i></a>,
the <b class="APPLICATION">UMP</b> persistent stores, also just called stores, actually
persist the source and receiver state and use RegIDs to identify sources and receivers.
Each source to which a store provides persistence may have zero or more receivers. The
store maintains each receiver's state along with the source's state and the messages the
source has sent.</p>

<p>The store can be configured with its own set of <a href="../UME/umestored-config.html"
target="doccontent">options</a> to persist this state information on disk or simply in memory.
The term <span class="emphasis"><i class="EMPHASIS">disk store</i></span> is used to
signify a store that persists state to disk, and the term <span class="emphasis"><i
class="EMPHASIS">memory store</i></span> is used to signify a store that persists state
only in memory. A store may also be configured not to cache the source's data, but to
simply persist the source and receiver state in memory. This is called a <span
class="emphasis"><i class="EMPHASIS">no-cache store</i></span>.</p>

<p>Unlike many persistent systems, the persistent store in <b class="APPLICATION">UMP</b>
is not in the message path. In other words, a source does not send data to the store and
then have the store forward it to the receivers. In <b class="APPLICATION">UMP</b> , the
source sends to the receiver(s) and the store(s) in parallel. See <a
href="#UME-OPS-NORMAL-OPERATION"><i>Normal Operation</i></a>. Thus, <b
class="APPLICATION">UMP</b> can provide extremely low latency to receiving
applications.</p>

<p>The store(s) that a source uses are part of the source's configuration settings.
Sources must be configured to use specific store(s) and use one of two different types of
store failover behaviors to match expected failure scenarios. See <a
href="#ROUND-ROBIN-STORE-USAGE"><i>Round-Robin Store Usage</i></a> and <a
href="#QUORUM-CONSENSUS-STORE-USAGE"><i>Quorum/Consensus Store Usage</i></a> below for
more about store failover scenarios.</p>

<p>Receivers, on the other hand, do not need to be configured with store information a
priori. The source advertises store information as part of the normal <b
class="APPLICATION">UM</b> topic resolution process. Thus the receivers will learn the
store(s) to use from the source without needing to be configured themselves. Because
receivers learn about the store(s) a source is using via topic resolution, the source
needs to be available to receivers as long as the receivers may need them. However, the
source does not have to be actively sending data to do this.</p>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="ROUND-ROBIN-STORE-USAGE"
name="ROUND-ROBIN-STORE-USAGE">7.1.4.1. Round-Robin Store Usage</a></h5>

<p>Stores can be used in a Round-Robin fashion by a source during failover. A source
provides <b class="APPLICATION">UMP</b> with a list of stores to use. The first is the
primary, the second is the secondary, the third is the tertiary, etc. The source uses a
single store at any one time. If the currently active store becomes unresponsive due to a
crash or network disconnect, <b class="APPLICATION">UMP</b> tries other stores in the
list one by one until it finds a responsive store.</p>

<p>With round-robin store usage, inactive stores do not receive data from the source.
Thus, a store that becomes the active store will not have any data from the source. In
this case, the source may be configured to retain messages and stream those messages to
the new store using <a href="../Config/latejoinoptions.html#SOURCELATEJOIN"
target="doccontent">Late Join</a>. Cascading failures of sources, stores and receivers may
require using stores in a Quorum/Consensus fashion.</p>

<p>See also <a href="#SOURCES-USING-RR-STORE-CONFIGURATION"><i>Sources Using Round-Robin
Store Configuration</i></a>.</p>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="QUORUM-CONSENSUS-STORE-USAGE"
name="QUORUM-CONSENSUS-STORE-USAGE">7.1.4.2. Quorum/Consensus Store Usage</a></h5>

<p>To provide the highest degree of resiliency in the face of failures, <b
class="APPLICATION">UMP</b> provides the Quorum/Consensus failover strategy which allows
a source to provide <b class="APPLICATION">UMP</b> with a number of stores to be used at
the same time. Multiple stores can fail and <b class="APPLICATION">UMP</b> can continue
operation unhindered. Moreover, Late Join is not needed as in Round-Robin.</p>

<p>Quorum/Consensus, also called QC, allows a source and the associated receivers to have
their persisted state maintained at several stores at the same time. Central to QC is the
concept of a group of stores, which is a logical grouping of stores that are intended to
signify a single entity of resilience. Within the group, individual stores may fail but
for the group as a whole to be viable and provide resiliency, a quorum must be available.
In <b class="APPLICATION">UMP</b> , a quorum is a simple majority. For example, in a
group of five stores, three stores are required to maintain a quorum. One or two stores
may fail and the group continues to provide resiliency. <b class="APPLICATION">UMP</b>
requires a source to have a quorum of stores available in the group in order to send
messages. A group can consist of a single store.</p>

<p>QC also provides the ability to use multiple groups. As long as a single group
maintains quorum, then <b class="APPLICATION">UMP</b> allows a source to proceed. Groups
are logical in nature and can be combined in any way imaginable, such as by store
location, store type, etc. In addition, QC provides the ability to specify backup stores
within groups. Backups may be used if or when a store in the group becomes unresponsive
to the source. Quorum/Consensus allows a source many different failure scenarios simply
not available in other persistent messaging systems.</p>

<p>See also <a href="#SOURCES-USING-QC-STORE-CONFIGURATION"><i>Sources Using
Quorum/Consensus Store Configuration</i></a>, <a
href="#QC-CONFIG-SINGLE-LOCATION-GROUPS"><i>Quorum/Consensus - Single Location
Groups</i></a> and <a href="#QC-CONFIG-MIXED-LOCATION-GROUPS"><i>Quorum/Consensus - Mixed
Location Groups</i></a>.</p>
</div>
</div>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="FAULT-RECOVERY" name="FAULT-RECOVERY">7.2. Fault
Recovery</a></h3>

<p>Recovery from source and receiver failure is the real heart of <b
class="APPLICATION">UMP</b> operation. For a source, this means continuing operation from
where it stopped. For a receiver, this means essentially the same thing, but with the
retransmission of missed messages. Application developers can easily leverage the
information in <b class="APPLICATION">UMP</b> to make their applications recover from
failure in graceful ways.</p>

<p><a href="../Design/lbm-features.html#USING-LATE-JOIN" target="doccontent">Late Join</a> is
the mechanism of <b class="APPLICATION">UMP</b> recovery as well as an <b
class="APPLICATION">UM</b> streaming feature. If Late Join is turned off on a source ( <a
href="../Config/latejoinoptions.html#SOURCELATEJOIN" target="doccontent"><tt
class="LITERAL">late_join</tt></a>) or receiver ( <a
href="../Config/latejoinoptions.html#RECEIVERUSELATEJOIN" target="doccontent"><tt
class="LITERAL">use_late_join</tt></a>), it also turns off <b class="APPLICATION">UMP</b>
recovery. In order to control Late Join behavior, <b class="APPLICATION">UMP</b> provides
a mechanism for a receiver to control the low sequence number. See <a
href="#RECOVERY-MANAGEMENT"><i>Recovery Management</i></a>.</p>

<p>Not all failures are recoverable. For application developers it usually pays in the
long run to identify what types of errors are non-recoverable and how best to handle them
when possible. Such an exercise establishes the precise boundaries of expected versus
abnormal operating conditions.</p>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> <b class="APPLICATION">UMP</b> does not acknowledge messages that are
lost. If the store is unable to recover a lost message, any receivers attempting to
recover this message from the store will experience unrecoverable loss as well. Sources
can pay attention to any gaps in stability or confirmed delivery acknowledgements as
these most likely represent unrecoverable loss at the store or receivers,
respectively.</p>
</blockquote>
</div>

<p>This section discussed the following recovery topics.</p>

<ul>
<li>
<p><a href="#SOURCE-RECOVERY"><i>Source Recovery</i></a></p>
</li>

<li>
<p><a href="#RECEIVER-RECOVERY"><i>Receiver Recovery</i></a></p>
</li>
</ul>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="SOURCE-RECOVERY" name="SOURCE-RECOVERY">7.2.1. Source
Recovery</a></h4>

<p>The following shows the basic steps of source recovery.</p>

<ol type="1">
<li>
<p>Re-register with the store.</p>
</li>

<li>
<p>Determine the highest sequence number that the store has from the source.</p>
</li>

<li>
<p>Resume sending with the next sequence number.</p>
</li>
</ol>

<p>Because <b class="APPLICATION">UMP</b> allows you to stream messages and not wait
until a message is stable at the persistent store before sending the next message, the
main task of source recovery is to determine what messages the persistent store(s) have
and what they don't. Therefore, when a source re-registers with a store during recovery,
the store tells the source what sequence number it has as the most recent from the
source. The registration event informs the application of this sequence number. See <a
href="#SOURCE-EVENT-HANDLER"><i>Source Event Handler</i></a>.</p>

<p>In addition, a mechanism exists (<tt
class="LITERAL">LBM_SRC_EVENT_SEQUENCE_NUMBER_INFO</tt>) that allows the application to
know the sequence number assigned to every piece of data it sends. The combination of
registration and sequence number information allows an application to know exactly what a
store does have and what it does not and where it should pick up sending. An application
designed to stream data in this way should consider how best to maintain this
information.</p>

<p>When QC is in use, <b class="APPLICATION">UMP</b> uses the consensus of the group(s)
to determine what sequence number to use in the first message it will send. This is
necessary as not all stores can be expected to be in total agreement about what was sent
in a distributed system. The application can configure the source with the <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMECONSENSUSSEQUENCENUMBERBEHAVIOR "
 target="doccontent"><tt class="LITERAL">ume_consensus_sequence_number_behavior</tt></a> to use
the lowest sequence number of the latest group of sequence numbers seen from any store,
the highest, or the majority. In most cases, the majority, which is the default, makes
the most sense as the consensus. The lowest is a very conservative setting. And the
highest is somewhat optimistic. Your application has the flexibility to handle this in
any way needed.</p>

<p>If streaming is not what an application desires due to complexity, then it is very
simple to use the <b class="APPLICATION">UMP</b> events (<a
href="#UME-OPS-UME-EVENTS"><i>UMP and UMQ Events</i></a>) delivered to the application to
mimic the behavior of restricting a source to having only one unstable message at a
time.</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="RECEIVER-RECOVERY" name="RECEIVER-RECOVERY">7.2.2. Receiver
Recovery</a></h4>

<p>The following shows the basic steps of receiver recovery.</p>

<ol type="1">
<li>
<p>Re-register with the store.</p>
</li>

<li>
<p>Determine the low sequence number.</p>
</li>

<li>
<p>Request retransmission of messages starting with the low sequence number.</p>
</li>
</ol>

<p><b class="APPLICATION">UMP</b> provides extensive options for controlling how
receivers handle recovery. By default, receivers want to restart after the last piece of
data that was consumed prior to failure or graceful suspension. Since <b
class="APPLICATION">UMP</b> persists receiver state at the store, receivers request this
state from the store as part of re-registration and recovery.</p>

<p>The actual sequence number that a receiver uses as the first topic level message to
resume reception with is called the "low sequence number". <b class="APPLICATION">UMP</b>
provides a means of modifying this sequence number if desired. An application can decide
to use the sequence number as is, to use an even older sequence number, to use a more
recent sequence number, or to simply use the most recent sequence number from the source.
See <a href="#RECOVERY-MANAGEMENT"><i>Recovery Management</i></a> and <a
href="#SETTING-CALLBACK-FOR-RECOVERY-SEQUENCE-NUMBER"><i>Setting Callback Function to Set
Recovery Sequence Number</i></a>. This allows receivers great flexibility on a per source
basis when recovering. New receivers, receivers with no pre-existing registration, also
have the same flexibility in determining the sequence number to begin data reception.</p>

<p>Like sources, when QC is in use, <b class="APPLICATION">UMP</b> uses the consensus of
the group(s) to determine the low sequence number. And as with sources, this is necessary
as not all stores can be expected to be in total agreement about what was acknowledged.
The application can configure the receiver with <a
href="../Config/ultramessagingpersistenceoptions.html#RECEIVERUMECONSENSUSSEQUENCENUMBERBEHAVIOR"
 target="doccontent"><tt class="LITERAL">ume_consensus_sequence_number_behavior</tt></a> to use
the lowest sequence number of the latest group of sequence numbers seen from any store,
the highest, or the majority. In most cases, the majority, which is the default, makes
the most sense as the consensus. The lowest is a very conservative setting. And the
highest is somewhat optimistic. In addition, this sequence number may be modified by the
application after the consensus is determined.</p>

<p>For QC, <b class="APPLICATION">UMP</b> load balances receiver retransmission requests
among the available stores. In addition, if requests are unanswered, retransmissions of
the actual requests will use different stores. This means that as long as a single store
has a message, then it is possible for that message to be retransmitted to a requesting
receiver.</p>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> Receivers need to consider if the use of arrival order delivery is
appropriate. See <a href="../Config/majoroptions.html#RECEIVERORDEREDDELIVERY"
target="doccontent"><tt class="LITERAL">ordered_delivery</tt></a>. <b
class="APPLICATION">UMP</b> stores save the highest sequence number acknowledged by a
receiver. When receivers using arrival order delivery receive - and thereby acknowledge -
messages out of order, recovery problems may arise because stores will not have earlier
messages not acknowledged by the receiver.</p>
</blockquote>
</div>
</div>
</div>
</div>

<div class="SECTION">
<hr />
<h2 class="SECTION"><a id="ENABLING-QUEUING" name="ENABLING-QUEUING">8. Enabling
Queuing</a></h2>

<p>This section describes how to add queuing to a minimum <b class="APPLICATION">UM</b>
source and receiver with the following.</p>

<ul>
<li>
<p><a href="#QUEUE-STARTING-CONFIG"><i>Starting Configuration</i></a></p>
</li>

<li>
<p><a href="#ADDING-QUEUE-TO-SOURCE"><i>Adding a Queue to a Source</i></a></p>
</li>

<li>
<p><a href="#SENDING-TO-QUEUE"><i>Sending to the Queue</i></a></p>
</li>

<li>
<p><a href="#RECEIVING-FROM-QUEUE"><i>Receiving from the Queue</i></a></p>
</li>
</ul>

<p><b class="APPLICATION">UMQ</b> Prerequisite: You should understand basic <b
class="APPLICATION"><span class="TRADEMARK">Ultra Messaging</span></b> concepts such as
Sources and Receivers along with the basic methods for configuring them.</p>

<p>The following table lists all source files used in this section. You can also find
links to them in the appropriate task. The files can also be found in the <tt
class="FILENAME">/doc/UME</tt> directory.</p>

<div class="INFORMALTABLE"><a id="AEN2908" name="AEN2908"></a>
<table border="1" class="CALSTABLE">
<col width="240" />
<col width="192" />
<thead>
<tr>
<th>Object</th>
<th>Filename</th>
</tr>
</thead>

<tbody>
<tr>
<td>Source Application</td>
<td><a href="q-example-src.c" target="doccontent">q-example-src.c</a></td>
</tr>

<tr>
<td>Receiver Application</td>
<td><a href="q-example-rcv.c" target="doccontent">q-example-rcv.c</a></td>
</tr>

<tr>
<td><b class="APPLICATION">UMQ</b> Configuration File</td>
<td><a href="q-example-config.xml" target="doccontent">q-example-config.xml</a></td>
</tr>
</tbody>
</table>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="QUEUE-STARTING-CONFIG" name="QUEUE-STARTING-CONFIG">8.1.
Starting Configuration</a></h3>

<p>We begin with the minimal source and receiver used by the <a
href="../QuickStart/index.html" target="doccontent">UM QuickStart Guide</a>. To more easily
demonstrate the <b class="APPLICATION">UMQ</b> features we are interested in, we have
modified the QuickStart source and receiver in the following ways.</p>

<ul>
<li>
<p>Modified the source to send 20 messages with a one second pause between each
message.</p>
</li>

<li>
<p>Modified the receiver to anticipate 20 messages instead of just one.</p>
</li>

<li>
<p>Assigned the topic, <b class="APPLICATION">UME Queue Example</b>, to both the source
and receiver.</p>
</li>

<li>
<p>Modified the receiver to not exit on unexpected receiver events.</p>
</li>
</ul>

<p>The last change allows us to better demonstrate basic operation and evolve our
receiver slowly without having to anticipate all the options that <b
class="APPLICATION">UMQ</b> provides up front.</p>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> Be sure to build <a href="q-example-src.c"
target="doccontent">q-example-src.c</a> and <a href="q-example-rcv.c"
target="doccontent">q-example-rcv.c</a>. Instructions for building them are at the beginning of
the source files.</p>
</blockquote>
</div>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="ADDING-QUEUE-TO-SOURCE" name="ADDING-QUEUE-TO-SOURCE">8.2.
Adding a Queue to a Source</a></h3>

<p>To enable queuing, a source needs to be configured to use a queue by setting the <a
href="../Config/ultramessagingqueuingoptions.html#SOURCEUMQQUEUENAME" target="doccontent"><tt
class="LITERAL">umq_queue_name</tt></a> for the source. The following <a
href="q-example-src.c" target="doccontent">q-example-src.c</a> code sets the source's queue to
the <tt class="LITERAL">queue_name</tt> established in the <b class="APPLICATION">UMQ</b>
configuration file (<tt class="LITERAL">q-example-config.xml</tt> ).</p>

<pre class="SCREEN">
err = lbm_src_topic_attr_str_setopt(&amp;attr, "umq_queue_name", queue_name);
</pre>

<p>Examining <a href="q-example-config.xml" target="doccontent">q-example-config.xml</a>
reveals that <tt class="LITERAL">queue_name</tt> is set to <b class="APPLICATION">Queue
Training</b> and listens on port 14567 for registrations.</p>

<p>Let's instantiate the queue with the following command.</p>

<pre class="SCREEN">
$ umestored q-example-config.xml
</pre>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="SENDING-TO-QUEUE" name="SENDING-TO-QUEUE">8.3. Sending to the
Queue</a></h3>

<p>Further examination of <a href="q-example-config.xml"
target="doccontent">q-example-config.xml</a> shows that the <b class="APPLICATION">Queue
Training</b> is configured for <a href="#SQD"><i>Serial Queue Dissemination
(SQD)</i></a>. In this model, sources send messages to topics as usual, but receivers
interested in the topic need not even be started because topic messages go to the Queue
first.</p>

<p>Therefore we can take the next step and run the source with the following command.</p>

<pre class="SCREEN">
$ q-example-src
</pre>

<p>The sample output below shows that the source sends 20 messages on the <b
class="APPLICATION">UME Queue Example</b> topic.</p>

<pre class="SCREEN">
tmont@agentmbp:/Volumes/source$ ./q-example-src 
INFO: Host has multiple multicast-capable interfaces. Default multicast interface: [en1][192.168.0.41] 
INFO: Source "UME Queue Example" Late Join not set, but UME store or UMQ queue specified. Setting Late Join. 
Sent Message 01 
Sent Message 02 
Sent Message 03 
Sent Message 04 
Sent Message 05 
Sent Message 06 
Sent Message 07 
Sent Message 08 
Sent Message 09 
Sent Message 10 
Sent Message 11 
Sent Message 12 
Sent Message 13 
Sent Message 14 
Sent Message 15 
Sent Message 16 
Sent Message 17 
Sent Message 18 
Sent Message 19 
Sent Message 20
</pre>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="RECEIVING-FROM-QUEUE" name="RECEIVING-FROM-QUEUE">8.4.
Receiving from the Queue</a></h3>

<p>At this point, only the Queue is running. The receiving application can start up at
anytime and receive any messages from the Queue on the topic it subscribes to.</p>

<pre class="SCREEN">
tmont@agentmbp:/Volumes/source$ ./q-example-rcv 
INFO: Host has multiple multicast-capable interfaces. Default multicast interface: [en1][192.168.0.41] 
Received 20 bytes on topic UME Queue Example: 'UME Queue Message 01' 
Received 20 bytes on topic UME Queue Example: 'UME Queue Message 02' 
Received 20 bytes on topic UME Queue Example: 'UME Queue Message 03' 
Received 20 bytes on topic UME Queue Example: 'UME Queue Message 04' 
Received 20 bytes on topic UME Queue Example: 'UME Queue Message 05' 
Received 20 bytes on topic UME Queue Example: 'UME Queue Message 06' 
Received 20 bytes on topic UME Queue Example: 'UME Queue Message 07' 
Received 20 bytes on topic UME Queue Example: 'UME Queue Message 08' 
Received 20 bytes on topic UME Queue Example: 'UME Queue Message 09' 
Received 20 bytes on topic UME Queue Example: 'UME Queue Message 10' 
Received 20 bytes on topic UME Queue Example: 'UME Queue Message 11' 
Received 20 bytes on topic UME Queue Example: 'UME Queue Message 12' 
Received 20 bytes on topic UME Queue Example: 'UME Queue Message 13' 
Received 20 bytes on topic UME Queue Example: 'UME Queue Message 14' 
Received 20 bytes on topic UME Queue Example: 'UME Queue Message 15' 
Received 20 bytes on topic UME Queue Example: 'UME Queue Message 16' 
Received 20 bytes on topic UME Queue Example: 'UME Queue Message 17' 
Received 20 bytes on topic UME Queue Example: 'UME Queue Message 18' 
Received 20 bytes on topic UME Queue Example: 'UME Queue Message 19' 
Received 20 bytes on topic UME Queue Example: 'UME Queue Message 20'
</pre>
</div>
</div>

<div class="SECTION">
<hr />
<h2 class="SECTION"><a id="DESIGNING-QUEUING-APPLICATIONS"
name="DESIGNING-QUEUING-APPLICATIONS">9. Designing Queuing Applications</a></h2>

<p><b class="APPLICATION">UMQ</b> applications are much like <b
class="APPLICATION">UMP</b> persistence applications, but with even fewer recovery
concerns.</p>

<ul>
<li>
<p>First, <b class="APPLICATION">UMQ</b> receivers typically have no concept of recovery.
In queuing semantics, the individual receiver has no requirement to pick up where it left
off. By default, the Queue assigns another receiver if the original receiver goes away.
However, you can also configure a queue to avoid reassignment or to never reassign.</p>
</li>

<li>
<p>Secondly, sources either submit messages to queues or they don't. Sources that fail
before a queue can acknowledge the messages as stable should simply resend the messages
once recovered. In this regard, the same recovery sequence for sources at a high level
can be applied to <b class="APPLICATION">UMQ</b> sources. Thus recovery from failure for
applications is fairly straightforward.</p>
</li>
</ul>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="QUEUE-REG-IDS" name="QUEUE-REG-IDS">9.1. Queue Registration
IDs</a></h3>

<p>Each context belonging to a <b class="APPLICATION">UMQ</b> source or receiver
application registers with a queue. This registration uses a Registration ID, which is
not used in the same manner as with <b class="APPLICATION">UMP</b> persistent stores
(which register sources and receivers). <b class="APPLICATION">UMQ</b> Registration IDs
identify individual contexts and not individual source and receiver objects. Also, <b
class="APPLICATION">UMQ</b> Registration IDs can (and should) vary per invocation.
Applications can set the use of specific Registration IDs with specific queues if they
desire. But we recommend you let <b class="APPLICATION">UMQ</b> generate these
Registration IDs or use <a href="#QUEUE-SES-IDS"><i>Queue Session IDs</i></a> to
generate/manage them.</p>

<p><b class="APPLICATION">UMQ</b> directs the registration of contexts with queues
internally. The following is a high level description of the registration sequence.</p>

<ul>
<li>
<p>Context creates a source object with <a
href="../Config/ultramessagingqueuingoptions.html#SOURCEUMQQUEUENAME" target="doccontent"><tt
class="LITERAL">umq_queue_name</tt></a> set to the desired Queue.</p>
</li>

<li>
<p>The context resolves the Queue using Queue Information Records (QIR) and Queue Query
Records (QQR).</p>
</li>

<li>
<p>The context generates a Registration ID randomly or uses one provided by your
application from the <tt class="LITERAL">lbm_umq_queue_entry_t</tt> for the context.</p>
</li>

<li>
<p><b class="APPLICATION">UMQ</b> registers the context with the Queue by sending the
Registration ID to be used to the Queue.</p>
</li>
</ul>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="QUEUE-SES-IDS" name="QUEUE-SES-IDS">9.2. Queue Session
IDs</a></h3>

<p>Like <b class="APPLICATION">UMP</b>, you can use Session IDs to manage context
registration IDs and receiver assignment IDs. The Session ID is a 64-bit value that that
identifies a receiving context and its set of receivers for a particular topic. A single
Session ID allows queues to correctly identify all receivers for a particular
application.</p>

<p>With Session IDs, a receiver that fails can return with its original assignment ID and
continue to receive queued messages, and receive them in the correct order. In this
scenario, with option <tt class="LITERAL">message-reassignment-timeout</tt> (see <a
href="#UMESTORED-TOPIC-OPTIONS"><i>Options for a Topic's ume-attributes Element</i></a>)
set to 0 (never reassign), the queue continues to send queued messages to the same
designated receiver in the designated order, even in the event of receiver failure and
recovery.</p>

<p>To set the queue Session ID, set option <a
href="../Config/ultramessagingqueuingoptions.html#CONTEXTUMQSESSIONID" target="doccontent"><tt
class="LITERAL">umq_session_id</tt></a> to a unique value. Do not replicate this value
elsewhere, even for sending applications.</p>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="MESSAGE-IDS" name="MESSAGE-IDS">9.3. Message IDs</a></h3>

<p><b class="APPLICATION">UMQ</b> assigns each message a unique Message ID (<tt
class="LITERAL">lbm_umq_msgid_t</tt>), which is composed of the sending application's
context Registration ID and a unique, incrementing stamp. These Message IDs must be
unique for a given queue, however, the application can use them for a variety of
processing purposes.</p>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="MESSAGE-LIFETIMES-REASSIGN"
name="MESSAGE-LIFETIMES-REASSIGN">9.4. Message Lifetimes and Reassignment</a></h3>

<p>Because receivers may be assigned messages and have failures before they can consume a
message (or fail while consuming a message), queues use the following parameters to
control how long a message should take to be consumed.</p>

<ul>
<li>
<p>total lifetime</p>
</li>

<li>
<p>reassignment timeout</p>
</li>

<li>
<p>maximum reassignments</p>
</li>
</ul>

<p>If the assigned receiver does not consume a message after the reassignment timeout
expires, the queue reassigns the message to another receiver provided the total lifetime
has not expired.</p>

<p>A queue can reassign an unconsumed message repeatedly until either it reaches the
maximum reassignments or the total lifetime expires. The queue marks reassigned messages
as having been re-assigned. Receivers may use this re-assignment flag as a hint that they
may want to treat the message differently.</p>

<p>The lifetime begins when the queue first assigns the message. When the total lifetime
expires, the queue either discards the message from the queue permanently or sends it to
the <a href="#DEAD-LETTER-QUEUE"><i>Dead Letter Queue</i></a>, if configured.</p>

<p>You can set a message lifetime in the following ways.</p>

<ul>
<li>
<p><b class="APPLICATION">For a Source</b> - To set a message lifetime default for a
particular source, set <a
href="../Config/ultramessagingqueuingoptions.html#SOURCEUMQMSGTOTALLIFETIME"
target="doccontent"><tt class="LITERAL">umq_msg_total_lifetime</tt></a> to the number of
milliseconds after which the message should not be assigned. Set <tt
class="LITERAL">message-reassignment-timeout</tt> and <tt
class="LITERAL">message-max-reassignments</tt> in <a href="#APP-SET-OPTIONS"><i>Options
for an Application Set's ume-attributes Element</i></a>.</p>
</li>

<li>
<p><b class="APPLICATION">For a Source Sending to ULB Receivers</b> - Set the message
lifetime default with <a
href="../Config/ultramessagingqueuingoptions.html#SOURCEUMQULBAPPLICATIONSETMESSAGELIFETIME"
 target="doccontent"><tt class="LITERAL">umq_ulb_application_set_message_lifetime</tt></a>. Set
the reassignment timeout with <a
href="../Config/ultramessagingqueuingoptions.html#SOURCEUMQULBAPPLICATIONSETMESSAGEREASSIGNMENTTIMEOUT"
 target="doccontent"><tt
class="LITERAL">umq_ulb_application_set_message_reassignment_timeout</tt></a>. Set the
maximum reassignments with <a
href="../Config/ultramessagingqueuingoptions.html#SOURCEUMQULBAPPLICATIONSETMESSAGEMAXREASSIGNMENTS"
 target="doccontent"><tt
class="LITERAL">umq_ulb_application_set_message_max_reassignments</tt></a>.</p>
</li>

<li>
<p><b class="APPLICATION">For a Queue Topic</b> - Set the <tt
class="LITERAL">umestored</tt> Queue Topic attribute, <tt
class="LITERAL">message-total-lifetime</tt>, to the number of milliseconds after which
the message should not be assigned. Set <tt
class="LITERAL">message-reassignment-timeout</tt> and <tt
class="LITERAL">message-max-reassignments</tt> in <a href="#QTOPIC-OPTIONS"><i>Options
for a Queue Topic's ume-attributes Element</i></a>.</p>
</li>

<li>
<p><b class="APPLICATION">For a particular message send</b> - Use an extended send call,
<code class="FUNCTION">lbm_src_send_ex</code>, that includes a pointer to <a
href="../API/structlbm__umq__msg__total__lifetime__info__t__stct.html" target="doccontent"><tt
class="LITERAL">lbm_umq_msg_total_lifetime_info_t</tt></a> in <tt
class="LITERAL">lbm_src_send_ex_info_t</tt>. Set the <tt
class="LITERAL">umq_msg_total_lifetime</tt> member to a <tt
class="LITERAL">lbm_umq_msg_total_lifetime_info_t</tt> structure and set the <tt
class="LITERAL">lbm_umq_msg_total_lifetime_info_t.umq_msg_total_lifetime</tt> to override
the total lifetime configured via <a
href="../Config/ultramessagingqueuingoptions.html#SOURCEUMQMSGTOTALLIFETIME"
target="doccontent"><tt class="LITERAL">umq_msg_total_lifetime</tt></a>.</p>
</li>

<li>
<p><b class="APPLICATION">For MIM</b> - To set a message lifetime default for Multicast
Immediate Messages (MIM), set the message lifetime option for the context, <a
href="../Config/ultramessagingqueuingoptions.html#CONTEXTUMQMSGTOTALLIFETIME"
target="doccontent"><tt class="LITERAL">umq_msg_total_lifetime</tt></a>, to the number of
milliseconds after which the message should not be assigned.</p>
</li>
</ul>

<p>A receiving application can pre-empt reassignment configurations by using <code
class="FUNCTION">lbm_msg_umq_reassign()</code> for either <b class="APPLICATION">UMQ</b>
or ULB receivers. This function takes an <tt class="LITERAL">lbm_msg_t</tt> and flags for
arguments. With no flags set, the queue reassigns the message. With the
LBM_MSG_UMQ_REASSIGN_FLAG_DISCARD flag set, the queue discards the message. The
corresponding Java and .NET methods are <tt
class="LITERAL">LBMMessage.reassign()</tt>.</p>
</div>
</div>

<div class="SECTION">
<hr />
<h2 class="SECTION"><a id="UME-FAULT-TOLERANCE" name="UME-FAULT-TOLERANCE">10. Fault
Tolerance</a></h2>

<p>This section discusses the following.</p>

<ul>
<li>
<p><a href="#CONFIGURING-FOR-PERSISTENCE-AND-RECOVERY"><i>Configuring for Persistence and
Recovery</i></a></p>
</li>

<li>
<p><a href="#PROXYSOURCES"><i>Proxy Sources</i></a></p>
</li>

<li>
<p><a href="#QUEUE-REDUNDANCY"><i>Queue Redundancy</i></a></p>
</li>

<li>
<p><a href="#QUEUE-FAILOVER"><i>Queue Failover</i></a></p>
</li>
</ul>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="CONFIGURING-FOR-PERSISTENCE-AND-RECOVERY"
name="CONFIGURING-FOR-PERSISTENCE-AND-RECOVERY">10.1. Configuring for Persistence and
Recovery</a></h3>

<p>Deployment decisions play a huge role in the success of any persistent system.
Configuration in <b class="APPLICATION">UMP</b> has a number of options that aid in
performance, fault recovery, and overall system stability. It is not possible, or at
least not wise, to totally divorce configuration from application development for high
performance systems. This is true not only for persistent systems, but for practically
all distributed systems. When designing systems, deployment considerations need to be
taken into account. This section discusses the following deployment considerations.</p>

<ul>
<li>
<p><a href="#SOURCE-CONSIDERATIONS"><i>Source Considerations</i></a></p>
</li>

<li>
<p><a href="#RECEIVER-CONSIDERATIONS"><i>Receiver Considerations</i></a></p>
</li>

<li>
<p><a href="#STORE-CONFIGURATION-CONSIDERATIONS"><i>Store Configuration
Considerations</i></a></p>
</li>

<li>
<p><a href="#UME-CONFIGURATIONS"><i>UMP Configuration Examples</i></a></p>
</li>
</ul>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="SOURCE-CONSIDERATIONS" name="SOURCE-CONSIDERATIONS">10.1.1.
Source Considerations</a></h4>

<p>Performance of sources is heavily impacted by:</p>

<ul>
<li>
<p>the release policy that the source uses</p>
</li>

<li>
<p>streaming methods of the source</p>
</li>

<li>
<p>the throughput and latency requirements of the data</p>
</li>
</ul>

<p>Source release settings have a direct impact on memory usage. As messages are
retained, they consume memory. You reclaim memory when you release messages. Message
stability, delivery confirmation and retention size all interact to create your release
policies. <b class="APPLICATION">UMP</b> provides a hard limit on the memory usage. When
exceeded, a Forced Reclamation event is delivered. Thus applications that anticipate
forced reclamations can handle them appropriately. See also <a
href="#SOURCE-MESSAGE-RETENTION-AND-RELEASE"><i>Source Message Retention and
Release</i></a>.</p>

<p>How the source streams data has a direct impact on latency and throughput. One
streaming method sets a maximum, outstanding count of messages. Once reached, the source
does not send any more until message stability notifications come in to reduce the number
of outstanding messages. The <a href="../example/umesrc.c" target="doccontent"><tt
class="LITERAL">umesrc</tt></a> example program uses this mechanism to limit the speed of
a source to something a store can handle comfortably. This also provides a maximum bound
on recovery that can simplify handling of streaming source recovery.</p>

<p>The throughput and latency requirements of the data are normal <b
class="APPLICATION">UM</b> concerns. See <a href="../Design/index.html" target="doccontent"><b
class="APPLICATION"><span class="TRADEMARK">Ultra Messaging</span></b> <b
class="APPLICATION">Concepts</b></a>.</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="RECEIVER-CONSIDERATIONS"
name="RECEIVER-CONSIDERATIONS">10.1.2. Receiver Considerations</a></h4>

<p>In addition to the following, receiver performance shares the same considerations as
receivers during normal operation.</p>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="ACKNOWLEDGEMENT-GENERATION"
name="ACKNOWLEDGEMENT-GENERATION">10.1.2.1. Acknowledgement Generation</a></h5>

<p>Receivers in a persistence implementation of <b class="APPLICATION">UMP</b> send an a
message consumption acknowledgement to stores and the message source. Some applications
may want to control this acknowledgement explicitly themselves. In this case, <a
href="../Config/ultramessagingpersistenceoptions.html#RECEIVERUMEEXPLICITACKONLY"
target="doccontent"><tt class="LITERAL">ume_explicit_ack_only</tt></a> can be used.</p>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="CONTROLLING-RETRANSMISSION"
name="CONTROLLING-RETRANSMISSION">10.1.2.2. Controlling Retransmission</a></h5>

<p>Receivers in <b class="APPLICATION">UMP</b> during fault recovery are another matter
entirely. Receivers send retransmission requests and receive and process retransmissions.
Control over this process is crucial when handling very long recoveries, such as hundreds
of thousands or millions of messages. A receiver only sends a certain number of
retransmission requests at a time.</p>

<p>This means that a receiver will not, unless configured to with <a
href="../Config/latejoinoptions.html#RECEIVERRETRANSMITREQUESTOUTSTANDINGMAXIMUM"
target="doccontent"><tt class="LITERAL">retransmit_request_outstanding_maximum</tt></a>,
request everything at once. The value of the low sequence number (<a
href="#RECEIVER-RECOVERY"><i>Receiver Recovery</i></a>) has a direct impact on how many
requests need to be handled. A receiving application can decide to only handle the last X
number of messages instead of recovering them all using the option, <a
href="../Config/latejoinoptions.html#RECEIVERRETRANSMITREQUESTMAXIMUM" target="doccontent"><tt
class="LITERAL">retransmit_request_maximum</tt></a>. The timeout used between requests,
if the retransmission does not arrive, is totally controllable with <a
href="../Config/latejoinoptions.html#RECEIVERRETRANSMITREQUESTINTERVAL" target="doccontent"><tt
class="LITERAL">retransmit_request_interval</tt></a>. And the total time given to recover
all messages is also controllable.</p>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="RECOVERY-PROCESS" name="RECOVERY-PROCESS">10.1.2.3. Recovery
Process</a></h5>

<p>Theoretically, receivers can handle up to roughly 2 billion messages during recovery.
This limit is implied from the sequence number arithmetic and not from any other
limitation. For recovery, the crucial limiting factor is how a receiver processes and
handles retransmissions which come in as fast as <b class="APPLICATION">UMP</b> can
request them and a store can retransmit them. This is perhaps much faster than an
application can handle them. In this case, it is crucial to realize that as recovery
progresses, the source may still be transmitting new data. This data will be buffered
until recovery is complete and then handed to the application. It is prudent to
understand application processing load when planning on how much recovery is going to be
needed and how it may need to be configured within <b class="APPLICATION">UMP</b> .</p>
</div>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="STORE-CONFIGURATION-CONSIDERATIONS"
name="STORE-CONFIGURATION-CONSIDERATIONS">10.1.3. Store Configuration
Considerations</a></h4>

<p><b class="APPLICATION">UMP</b> stores have numerous configuration options. See <a
href="#UMESTORED-CONFIG"><i>Configuration Reference for Umestored</i></a>. This section
presents issues relating to these options.</p>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="CONFIGURING-STORE-USAGE-PER-SOURCE"
name="CONFIGURING-STORE-USAGE-PER-SOURCE">10.1.3.1. Configuring Store Usage per
Source</a></h5>

<p>A store handles persisted state on a per topic per source basis. Based on the load of
topics and sources, it may be prudent to spread the topic space, or just source space,
across stores as a way to handle large loads. As configuration of store usage is per
source, this is extremely easy to do. It is easy to spread CPU load via multi-threading
as well as hard disk usage across stores. A single store process can have a set of
virtual stores within it, each with their own thread.</p>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="DISK-VS.-MEMORY" name="DISK-VS.-MEMORY">10.1.3.2. Disk vs.
Memory</a></h5>

<p>As mentioned previously in <a href="#UME-STORES"><i>UMP Stores</i></a>, stores can be
memory based or disk based. Disk stores also have the ability to spread hard disk usage
across multiple physical disks by using multiple virtual stores within a single store
process. This gives great flexibility on a per source basis for spreading data reception
and persistent data load.</p>

<p><b class="APPLICATION">UMP</b> stores provide settings for controlling memory usage
and for caching messages for retransmission in memory as well as on disk. See <a
href="#UMESTORED-TOPIC-OPTIONS"><i>Options for a Topic's ume-attributes Element</i></a>.
All messages in a store, whether in memory or on disk, have some small memory state. This
is roughly about 72 bytes per message. For very large caches of messages, this can become
non-trivial in size.</p>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="ACTIVITY-TIMEOUTS" name="ACTIVITY-TIMEOUTS">10.1.3.3. Activity
Timeouts</a></h5>

<p><b class="APPLICATION">UMP</b> stores are NOT archives and are not designed for
archival. Stores persist source and receiver state with the aim of providing fault
recovery. Central to this is the concept that a source or receiver has an activity
timeout attached to it. Once a source or receiver suspends operation or has a failure, it
has a set time before the store will forget about it. This activity timeout needs to be
long enough to handle the recovery demands of sources and receivers. However, it can not
and should not be infinite. Each source takes up memory and disk space, therefore an
appropriate timeout should be chosen that meets the requirements of recovery, but is not
excessively long so that the limited resources of the store are exhausted.</p>
</div>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UME-CONFIGURATIONS" name="UME-CONFIGURATIONS">10.1.4. <b
class="APPLICATION">UMP</b> Configuration Examples</a></h4>

<p>The following example configurations are offered to illustrate some of the many
options available to configuring <b class="APPLICATION">UMP</b> .</p>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="UME-CONFIGURATION-NAT-FIREWALL"
name="UME-CONFIGURATION-NAT-FIREWALL">10.1.4.1. <b class="APPLICATION">UMP</b>
Configuration with NAT/Firewall</a></h5>

<p>Although the diagram, <a href="#UME-OPS-NORMAL-OPERATION"><i>Normal Operation</i></a>,
demonstrates the typical message interaction in <b class="APPLICATION">UMP</b> , sources,
receivers, and stores may be arranged in almost limitless configurations. Some
configurations make more sense than others for certain situations. One of those
situations involves a Network Address Translation configuration (NAT) and/or Firewall. In
such configurations, the source is the key element behind the NAT or Firewall. Although
not the only viable NAT/Firewall configuration for <b class="APPLICATION">UMP</b> , the
figure below demonstrates one approach to such an arrangement.</p>

<div class="FIGURE"><a id="UMECONFIGFIREWALL" name="UMECONFIGFIREWALL"></a>
<p><b>Figure 17. UMP Configuration with NAT/Firewall</b></p>

<p><img src="UMEConfigFirewall.png" align="CENTER" /></p>
</div>

<p>The <tt class="LITERAL">lbmrd</tt> (29west Resolution Daemon) is an optional piece,
but used in most situations where a NAT or Firewall is involved. It provides unicast
support for topic resolution. The <tt class="LITERAL">lbmrd</tt> and the store are placed
on the outside (or at least are non-NATed or on a DMZ). Important characteristics of this
configuration are:</p>

<ul>
<li>
<p>The LBMRD acts as a proxy for the topic resolution information.</p>
</li>

<li>
<p>The store is accessible by the source and receiver directly.</p>
</li>
</ul>

<p>In this situation, receivers and stores unicast control information back to the
source, therefore the NAT or Firewall router needs to port forward information back to
the source.</p>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="QC-CONFIG-SINGLE-LOCATION-GROUPS"
name="QC-CONFIG-SINGLE-LOCATION-GROUPS">10.1.4.2. Quorum/Consensus - Single Location
Groups</a></h5>

<p>Quorum/Consensus provides a huge set of options for store arrangements in <b
class="APPLICATION">UMP</b> . Between backups and groups, the number of viable approaches
is practically limitless. Below are two approaches using single location groups and
multiple location groups.</p>

<p>In short, as long as one of the groups in the figure maintains quorum, then the source
can continue. See <a href="#SOURCES-USING-QC-STORE-CONFIGURATION"><i>Sources Using
Quorum/Consensus Store Configuration</i></a> to view a <b class="APPLICATION">UM</b>
configuration file for this example.</p>

<div class="FIGURE"><a id="QCCONFIGLOC" name="QCCONFIGLOC"></a>
<p><b>Figure 18. Quorum/Consensus - Single Location Groups</b></p>

<p><img src="QCConfigLoc.png" align="CENTER" /></p>
</div>

<p>The above figure shows three groups arranged on a location basis. Each group is a
single location. Just SOME possible failure scenarios are:</p>

<ul>
<li>
<p>Failure of any 3 stores in Group 0</p>
</li>

<li>
<p>Failure of any 1 store in Group 1</p>
</li>

<li>
<p>Failure of any 2 stores in Group 2</p>
</li>

<li>
<p>Failure of all stores in Group 0 and 1</p>
</li>

<li>
<p>Failure of all stores in Group 1 and 2</p>
</li>

<li>
<p>Failure of all stores in Group 0 and 2</p>
</li>
</ul>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="QC-CONFIG-MIXED-LOCATION-GROUPS"
name="QC-CONFIG-MIXED-LOCATION-GROUPS">10.1.4.3. Quorum/Consensus - Mixed Location
Groups</a></h5>

<p>Groups of stores can be configured across locations. Such an arrangement would ensure
continued operation in the event of a site-wide failure at any location.</p>

<div class="FIGURE"><a id="QCCONFIGMIXEDLOC" name="QCCONFIGMIXEDLOC"></a>
<p><b>Figure 19. Quorum/Consensus - Mixed Location Groups</b></p>

<p><img src="QCConfigMixedLoc.png" align="CENTER" /></p>
</div>

<p>The figure above shows two groups arranged in a mixed location manner. Essentially,
one location can totally fail and a source can continue sending because the other
location has a group with a quorum. See below for an <b class="APPLICATION">UM</b>
configuration file for this example.</p>

<pre class="PROGRAMLISTING">
source ume_store 10.16.3.77:10313:101000:0
source ume_store 10.16.3.78:11313:110000:1
source ume_store 10.16.3.79:12313:120000:1
source ume_store 192.168.0.44:15313:150000:1
source ume_store 192.168.0.45:16313:160000:0
source ume_store 192.168.0.46:17313:170000:0

source ume_message_stability_notification 1
source ume_store_behavior qc

source ume_store_group 0:3
source ume_store_group 1:3

source ume_retention_intragroup_stability_behavior quorum
source ume_retention_intergroup_stability_behavior any
       
</pre>
</div>
</div>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="PROXYSOURCES" name="PROXYSOURCES">10.2. Proxy Sources</a></h3>

<p>The Proxy Source capability allows you to configure stores to automatically continue
sending the source's topic advertisements which contain store information used by new
receivers. Without the store RegID, address and TCP port contained in the source's Topic
Information Records (TIR), new receivers cannot register with the store or request
retransmissions. After the source returns, the store automatically stops acting as a
proxy source.</p>

<p>Some other features of Proxy Sources include:</p>

<ul>
<li>
<p>Requires a Quorum/Consensus store configuration.</p>
</li>

<li>
<p>Normal store failover operation also initiates a new proxy source.</p>
</li>

<li>
<p>A store can be running more than one proxy source if more than one source has
failed.</p>
</li>

<li>
<p>A store can be running multiple proxy sources for the same topic.</p>
</li>
</ul>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="OPERATING-PROXYSOURCE" name="OPERATING-PROXYSOURCE">10.2.1.
How Proxy Sources Operate</a></h4>

<p>The following sequence illustrates the life of a proxy source.</p>

<ol type="1">
<li>
<p>A source configured for Proxy Source sends to receivers and a group of
Quorum/Consensus stores.</p>
</li>

<li>
<p>The source fails.</p>
</li>

<li>
<p>The source's <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMEACTIVITYTIMEOUT"
target="doccontent"><tt class="LITERAL">ume_activity_timeout</tt></a> or the store's <tt
class="LITERAL">source-activity-timeout</tt> expires.</p>
</li>

<li>
<p>The Quorum/Consensus stores elect a single store to run the proxy source.</p>
</li>

<li>
<p>The elected store creates a proxy source and sends topic advertisements.</p>
</li>

<li>
<p>The failed source reappears.</p>
</li>

<li>
<p>The store deletes the proxy source and the original source resumes activity.</p>
</li>
</ol>

<p>If the store running the proxy source fails, the other stores in the Quorum/Consensus
group detect a source failure again and elect a new store to initiate a proxy source.</p>

<p>If a loss of quorum occurs, the proxy source can continue to send advertisements, but
cannot send messages until a quorum is re-established.</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="ACTIVITY-TIMEOUT-STATE-LIFETIME"
name="ACTIVITY-TIMEOUT-STATE-LIFETIME">10.2.2. Activity Timeout and State Lifetime
Options</a></h4>

<p><b class="APPLICATION">UMP</b> provides activity and state lifetime timers for sources
and receivers that operate in conjunction with the proxy source option or independently.
This section explains how these timers work together and how they work with proxy
sources.</p>

<p>The <a href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMEACTIVITYTIMEOUT"
target="doccontent"><tt class="LITERAL">ume_activity_timeout</tt></a> options determine how
long a source or receiver must be inactive before a store allows another source or
receiver to register using that RegID. This prevents a second source or receiver from
<span class="emphasis"><i class="EMPHASIS">stealing</i></span> a RegID from an existing
source or receiver. An activity timeout can be configured for the source/receiver with
the <b class="APPLICATION">UM</b> Configuration Option cited above or with a topic's <tt
class="LITERAL">ume-attribute</tt> configured in the <tt class="LITERAL">umestored</tt>
XML configuration file. The following diagram illustrates the default activity timeout
behavior, which uses <tt class="LITERAL">source-state-lifetime</tt> in the <tt
class="LITERAL">umestored</tt> XML configuration file. (See <a
href="#UMESTORED-TOPIC-OPTIONS"><i>Options for a Topic's ume-attributes
Element</i></a>.)</p>

<div class="FIGURE"><a id="ACTIVITY-TIMEOUT-DEFAULT" name="ACTIVITY-TIMEOUT-DEFAULT"></a>
<p><b>Figure 20. Source Activity Timeout Default</b></p>

<p><img src="Activity_Timeout_Default.png" align="CENTER" /></p>
</div>

<p>In addition to the activity timeout, you can also configure sources and receivers with
a state lifetime timer using the following options.</p>

<ul>
<li>
<p><a href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMESTATELIFETIME"
target="doccontent"><tt class="LITERAL">(source) ume_state_lifetime</tt></a></p>
</li>

<li>
<p><a href="../Config/ultramessagingpersistenceoptions.html#RECEIVERUMESTATELIFETIME"
target="doccontent"><tt class="LITERAL">(receiver) ume_state_lifetime</tt></a></p>
</li>

<li>
<p>The topic's ume-attributes options, <tt class="LITERAL">source-state-lifetime</tt> and
<tt class="LITERAL">receiver-state-lifetime</tt>. See <a
href="#UMESTORED-TOPIC-OPTIONS"><i>Options for a Topic's ume-attributes
Element</i></a>.</p>
</li>
</ul>

<p>The <a href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMESTATELIFETIME"
target="doccontent"><tt class="LITERAL">ume_state_lifetime</tt></a>, when used in conjunction
with the <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMEACTIVITYTIMEOUT"
target="doccontent"><tt class="LITERAL">ume_activity_timeout</tt></a> options, determines at
what point <b class="APPLICATION">UMP</b> removes the source or receiver state. <b
class="APPLICATION">UMP</b> does not check the <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMESTATELIFETIME"
target="doccontent"><tt class="LITERAL">ume_state_lifetime</tt></a> until <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMEACTIVITYTIMEOUT"
target="doccontent"><tt class="LITERAL">ume_activity_timeout</tt></a> expires. The following
diagram illustrates this behavior.</p>

<div class="FIGURE"><a id="SRC-RCV-STATE-LIFETIME" name="SRC-RCV-STATE-LIFETIME"></a>
<p><b>Figure 21. Source or Receiver State Lifetime</b></p>

<p><img src="Src_Rcv_State_Lifetime.png" align="CENTER" /></p>
</div>

<p>If you have enabled the Proxy Source option, the Activity Timeout triggers the
creation of the proxy source. The following diagram illustrates this behavior.</p>

<div class="FIGURE"><a id="SRC-ACTIVITY-STATE-PROXY-SOURCE"
name="SRC-ACTIVITY-STATE-PROXY-SOURCE"></a>
<p><b>Figure 22. Source Activity and State Timers with the Proxy Source Option</b></p>

<p><img src="Src_Activity_State_Proxy_Source.png" align="CENTER" /></p>
</div>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="ENABLING-PROXYSOURCE" name="ENABLING-PROXYSOURCE">10.2.3.
Enabling the Proxy Source Option</a></h4>

<p>You must configure both the source and the stores to enable the Proxy Source
option.</p>

<ul>
<li>
<p>Configure the source in a <b class="APPLICATION">UM</b> Configuration File with the
source configuration option, <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMEPROXYSOURCE"
target="doccontent"><tt class="LITERAL">ume_proxy_source</tt></a>.</p>
</li>

<li>
<p>Configure the stores in the <tt class="LITERAL">umestored</tt> XML configuration file
with the Store Element Option, <tt class="LITERAL">allow-proxy-source</tt>. See <a
href="#UMESTORED-STORE-OPTIONS"><i>Options for a Store's ume-attributes Element</i></a>
for more information.</p>
</li>
</ul>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> Proxy sources operate with Session IDs as well as Reg IDs. See <a
href="#SESSION-IDS"><i>Managing RegIDs with Session IDs</i></a></p>
</blockquote>
</div>
</div>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="QUEUE-REDUNDANCY" name="QUEUE-REDUNDANCY">10.3. Queue
Redundancy</a></h3>

<p>Queues can use the same Quorum/Consensus configuration as <b
class="APPLICATION">UMQ</b> stores.</p>

<ul>
<li>
<p>Sources submit queue messages to each queue instance.</p>
</li>

<li>
<p>You configure queue instances into groups using the <a
href="#QUEUE-GROUPS-ELEMENT"><i>Queue Groups Element</i></a> of the queue's <tt
class="LITERAL">umestored</tt> XML configuration file. You can configure all queue
instances for a queue in a single <tt class="LITERAL">umestored</tt> XML configuration
file or a separate file for each instance.</p>
</li>

<li>
<p>A message is considered stable once it has satisfied the stability requirements you
configure with <a
href="../Config/ultramessagingqueuingoptions.html#CONTEXTUMQRETENTIONINTERGROUPSTABILITYBEHAVIOR"
 target="doccontent"><tt class="LITERAL">umq_retention_*_stability_behavior</tt></a>.</p>
</li>

<li>
<p>Receivers send Consumption Reports to all queue instances so they all are aware of
message reception status.</p>
</li>
</ul>

<p><a href="#QUEUEFAILOVERCONFIG">Figure 23</a> shows how multiple instances of a Queue
can be configured and some of the communication between contexts, sources, receivers and
Queue instances.</p>

<div class="FIGURE"><a id="QUEUEFAILOVERCONFIG" name="QUEUEFAILOVERCONFIG"></a>
<p><b>Figure 23. Sample Configuration of Redundant Queues for Failover</b></p>

<p><img src="Queue_Failover_Config.png" align="CENTER" /></p>
</div>

<ul>
<li>
<p><b class="APPLICATION">RegID</b> - Application contexts register with the Queue using
a RegID in order to send messages to the Queue or receive messages from the Queue. See <a
href="#QUEUE-REG-IDS"><i>Queue Registration IDs</i></a> and <a
href="../Config/ultramessagingqueuingoptions.html#CONTEXTUMQQUEUEREGISTRATIONID"
target="doccontent"><tt class="LITERAL">umq_queue_registration_id</tt></a>.</p>
</li>

<li>
<p><b class="APPLICATION">Queue Master</b> - A Queue Instance that has been elected the
master Queue. Only the master Queue sends messages to receivers. The master sends
Instance List Notifications (ILN) periodically to QSIs and registered contexts.</p>
</li>

<li>
<p><b class="APPLICATION">Queue Slave Instance (QSI)</b> - Slave Queue Instances
initiated for Queue Failover. Should the master Queue fail, any QSI can assume master
Queue activities following election. Each QSI and the master Queue require a separate <b
class="APPLICATION">UM</b> Configuration File and <tt class="LITERAL">umestored</tt>
configuration.</p>
</li>

<li>
<p><b class="APPLICATION">QIR (Queue Information Record)</b> - Queue advertisement sent
by the master Queue to registered contexts which enable sources and receivers to resolve
queue names to lists of queue instances (ILN). QIRs contain each queue instances' IP
address, port, index, and group index as well as flags indicating if the instance is the
Queue Election Master, current master or Post Election Master. The QIR also contains
versioning information for instances partitioned due to previous failures.</p>
</li>

<li>
<p><b class="APPLICATION">ILN (Instance List Notification)</b> - List of active instances
in the Queue used by instances to manage themselves. For each instance the list contains
the instance's IP address, port, index, group index and flags indicating if the instance
is the Queue Election Master, current master or Post Election Master.</p>
</li>

<li>
<p><b class="APPLICATION">CR (Consumption Report)</b> - Indication sent to each Queue
Instance that a message has been consumed.</p>
</li>
</ul>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="Q-MASTER-ELECTION-PROCESS"
name="Q-MASTER-ELECTION-PROCESS">10.3.1. Queue Master Election Process</a></h4>

<p>Queue instances use an internal election process to determine a master queue
responsible for making assignments and handling any dissemination requirements. The
master is also responsible for tracking queue instance liveness and handling queue
resolution duties. Those queue instances that are not the master (slaves) simply act as
passive observers of queue activities. Slaves may fail and come online without seriously
impacting operations. When a master fails, though, an election occurs. Once the election
process establishes a new master, queue operation can proceed.</p>

<p>A queue instance is elected master based on the three values shown below and presented
in order of importance.</p>

<ol type="1">
<li>
<p>The QSI's <tt class="LITERAL">queue-management-election-bias</tt> configured in it's
<tt class="LITERAL">umestored</tt> XML configuration file.</p>
</li>

<li>
<p>The QSI's age computed from the number of messages received and submitted by the QSI.
<b class="APPLICATION">UMQ</b> uses the QSI age if all QSI bias values are equal.</p>
</li>

<li>
<p>An internal QSI index. <b class="APPLICATION">UMQ</b> uses the QSI index if all QSI
bias and age values are equal.</p>
</li>
</ol>

<p><b class="APPLICATION">UMQ</b>'s default behavior assigns the same election bias to
every QSI, which often results in the "oldest", active QSI being elected the master
queue. If you wish finer control of the election process, you can configure each Queue
Instance with an election bias. You could assign the higher election bias values to the
Queue Instances you know are running on the more powerful machines or those with the
lowest latency. See <a href="#QUEUE-MANAGEMENT-OPTIONS"><i>Queue Management Options for a
Queue's ume-attributes Element</i></a> for more information.</p>

<p>The following summarizes the Queue Master Election Process.</p>

<ol type="1">
<li>
<p>A Queue Slave Instance (QSI) detects the loss of the master if the <tt
class="LITERAL">queue_management_master_activity_timeout</tt> expires without any
Instance Lists having been sent during the timeout period.</p>
</li>

<li>
<p>The QSI that detected the loss of the master names itself Queue Election Master
(QEM).</p>
</li>

<li>
<p>The QEM sends an Election Call to all QSIs, which also identifies itself as the new
QEM.</p>
</li>

<li>
<p>All QSIs reply to the Election Call with their "instance vote" which contains their
own election bias and "age".</p>
</li>

<li>
<p>The QEM selects the QSI with the highest election bias as the master. If two or more
QSIs have the highest bias, the QEM selects the "oldest" of the QSIs with the highest
bias. The QSI with the most messages received and submitted is considered the oldest. A
third tie breaker is an internal QSI index.</p>
</li>

<li>
<p>The QEM sends out another ILN naming the elected QSI as the Post Election Master
(PEM).</p>
</li>

<li>
<p>QSIs confirm receipt of the ILN.</p>
</li>

<li>
<p>QEM sends a Resume Operation message to the PEM.</p>
</li>

<li>
<p>The PEM resumes operation of the Queue (assigning messages to receivers, managing
dissemination requirements, tracking QSI health, handling queue resolution traffic) and
sends a Instance List Notification flagging itself as the current master.</p>
</li>
</ol>
</div>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="QUEUE-FAILOVER" name="QUEUE-FAILOVER">10.4. Queue
Failover</a></h3>

<p>The following sections discuss various queue failover scenarios.</p>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="FAILOVERLOSSQUORUM" name="FAILOVERLOSSQUORUM">10.4.1. Failover
from Loss of Quorum</a></h4>

<p>If the loss of a QSI results in the loss of quorum, the master Queue stops advertising
(QIR). As a result, sources lose their registration and subsequent messages sent by the
sources return an LBM_EUMENOREG event. (If a source is connected to both a store and a
queue, subsequent message sends return an LBM_ENO_QUEUE_REG event.) When quorum is
regained by the recovery of the lost QSI or the addition of a new QSI, the master Queue
advertises again. Sending and receiving <b class="APPLICATION">UM</b> contexts can then
resolve the Queue again and re-register.</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="FAILOVERLOSSMASTER" name="FAILOVERLOSSMASTER">10.4.2. Failover
from Loss of Master</a></h4>

<p>If the master Queue fails, the following two events occur.</p>

<ul>
<li>
<p>Sources lose their registration and subsequent messages sent by the sources return an
LBM_EUMENOREG event. (If a source is connected to both a store and a queue, subsequent
message sends return an LBM_ENO_QUEUE_REG event.)</p>
</li>

<li>
<p>The first QSI to detect the loss of the master calls an election. See <a
href="#Q-MASTER-ELECTION-PROCESS"><i>Queue Master Election Process</i></a>. After wards,
the new master Queue starts advertising, allowing sending and receiving <b
class="APPLICATION">UM</b> contexts to resolve the Queue and re-register.</p>
</li>
</ul>

<p>If, due to a series of failures, a QSI notices that it has stored messages that the
master queue never saw, it attempts to resubmit them to the master queue. The master
queue either accepts these when it determines that it never saw them, or it rejects the
resubmission attempt. If the master queue accepts the resubmit, it marks the message as a
resubmission when it assigns the message to a receiver, informing the receiver that it
was resubmitted from a QSI.</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="OTHER-SCENARIOS" name="OTHER-SCENARIOS">10.4.3. Other
Scenarios</a></h4>

<p>If a receiver fails unexpectedly, the queue does not become aware of this until <tt
class="LITERAL">receiver-activity-timeout</tt> expires. In the mean time, the queue
continues to assign messages to the receiver until the receiver's portion size is met.
When the <tt class="LITERAL">message-reassignment-timeout</tt> expires, the queue
reassigns the message to a different receiver and sets the message's reassigned flag to
inform the receiving application that the message may have been seen by a different
receiver.</p>

<p>Receivers can call <code class="FUNCTION">lbm_rcv_umq_deregister()</code> or <code
class="FUNCTION">lbm_wildcard_rcv_umq_deregister()</code> to gracefully deregister from
the queue. The queue does not assign any new messages to it.</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="FAILOVERLOSSQSI" name="FAILOVERLOSSQSI">10.4.4. Failover from
Loss of Slave (QSI)</a></h4>

<p>Assuming the master queue is running and assuming quorum has been maintained, QSIs
coming and going have little to no impact on queue operation. QSIs are largely passive
bystanders. As QSIs come and go from the queue, the master queue notifies the <b
class="APPLICATION">UM</b> contexts registered with the queue via instance list
notifications (ILN). These notifications inform the contexts which QSI was added or
removed.</p>
</div>
</div>
</div>

<div class="SECTION">
<hr />
<h2 class="SECTION"><a id="UMESTORED-MANPAGE" name="UMESTORED-MANPAGE">11. Man
Pages</a></h2>

<div class="TOC">
<dl>
<dt><b>Table of Contents</b></dt>

<dt><a href="#UMESTORED">umestored</a>&nbsp;--&nbsp;Persistent Store and Queue
Daemon</dt>

<dt><a href="#UMESTOREDS">umestoreds</a>&nbsp;--&nbsp;Persistent Store and Queue Windows
Service</dt>

<dt><a href="#UMQSLTOOL">umqsltool</a>&nbsp;--&nbsp;UMQ SINC Log Tool</dt>
</dl>
</div>

<h1><a id="UMESTORED" name="UMESTORED"></a>umestored</h1>

<div class="REFNAMEDIV"><a id="AEN3506" name="AEN3506"></a>
<h2>Name</h2>

umestored&nbsp;--&nbsp;Persistent Store and Queue Daemon</div>

<div class="REFSYNOPSISDIV"><a id="AEN3509" name="AEN3509"></a>
<h2>Synopsis</h2>

<p><tt class="COMMAND">umestored</tt> [<code class="OPTION">-d</code>] [<code
class="OPTION">--dump-dtd</code>] [<code class="OPTION">-f</code>] [<code
class="OPTION">--detach</code>] [<code class="OPTION">-h</code>] [<code
class="OPTION">--help</code>] [<code class="OPTION">-v</code>] [<code
class="OPTION">--validate</code>] <tt class="REPLACEABLE"><i>configfile</i></tt></p>
</div>

<div class="REFSECT1"><a id="AEN3530" name="AEN3530"></a>
<h2>Description</h2>

<p>Persistent Store and Queue services are provided by <tt
class="COMMAND">umestored</tt>. A store configuration file is required.</p>

<p>The DTD used to validate a configuration file will be dumped to standard output with
the <code class="OPTION">-d</code> or <code class="OPTION">--dump-dtd</code>. After
dumping the DTD, <tt class="COMMAND">umestored</tt> exits instead of providing
persistence services as usual.</p>

<p>The configuration file will be validated against the DTD if either the <code
class="OPTION">-v</code> or <code class="OPTION">--validate</code> options are given.
After attempting validation, <tt class="COMMAND">umestored</tt> exits instead of
providing persistence services as usual. The exit status will be 0 for a configuration
file validated by the DTD and non-zero otherwise.</p>

<p><tt class="COMMAND">Umestored</tt> normally remains attached to the controlling
terminal and runs until interrupted. If the <code class="OPTION">-f</code> or <code
class="OPTION">--detach</code> options are given, <tt class="COMMAND">umestored</tt>
instead forks, detaches the child from the controlling terminal, and the parent exits
immediately.</p>

<p>Command line help is available with <code class="OPTION">-h</code>.</p>
</div>

<div class="REFSECT1"><a id="AEN3549" name="AEN3549"></a>
<h2>Usage Notes</h2>

<p>When shutting down the <b class="APPLICATION">UM</b> Persistent Store or Queue daemon,
use a SIGINT to trigger a clean shutdown, which attempts to cleanly finish outstanding IO
requests before shutting down. Two successive SIGINTs force an immediate shutdown.</p>
</div>

<div class="REFSECT1"><a id="AEN3553" name="AEN3553"></a>
<h2>Exit Status</h2>

<p>The exit status from <tt class="COMMAND">umestored</tt> is 0 for success and some
non-zero value for failure.</p>
</div>

<h1><a id="UMESTOREDS" name="UMESTOREDS"></a>umestoreds</h1>

<div class="REFNAMEDIV"><a id="AEN3560" name="AEN3560"></a>
<h2>Name</h2>

umestoreds&nbsp;--&nbsp;Persistent Store and Queue Windows Service</div>

<div class="REFSYNOPSISDIV"><a id="AEN3563" name="AEN3563"></a>
<h2>Synopsis</h2>

<p><tt class="COMMAND">umestoreds</tt> [<code class="OPTION">-d</code>] [<code
class="OPTION">--dump-dtd</code>] [<code class="OPTION">-h</code>] [<code
class="OPTION">--help</code>] [<code class="OPTION">-s action</code>] [<code
class="OPTION">--service=action</code>] [<code class="OPTION">-v</code>] [<code
class="OPTION">--validate</code>] [<code class="OPTION">configfile</code>]</p>
</div>

<div class="REFSECT1"><a id="AEN3584" name="AEN3584"></a>
<h2>Description</h2>

<p>Persistent Store and Queue services are provided by the <tt
class="COMMAND">umestoreds</tt> Windows Service. A store configuration file is optional.
If not present, the Registry will be consulted.</p>

<p>The DTD used to validate a configuration file will be dumped to standard output with
the <code class="OPTION">-d</code> or <code class="OPTION">--dump-dtd</code>. After
dumping the DTD, <tt class="COMMAND">umestoreds</tt> exits instead of providing
persistence services as usual.</p>

<p>The configuration file will be validated against the DTD if either the <code
class="OPTION">-v</code> or <code class="OPTION">--validate</code> options are given.
After attempting validation, <tt class="COMMAND">umestoreds</tt> exits instead of
providing persistence services as usual. The exit status will be 0 for a configuration
file validated by the DTD and non-zero otherwise.</p>

<p>The <code class="OPTION">-s install</code> or <code
class="OPTION">--service=install</code> options will install the service using the given
configuration file. Once installed, <tt class="COMMAND">umestoreds</tt> exits. Once
installed, the service may be stopped or started via the Windows Service Control
Panel.</p>

<p>The <code class="OPTION">-s remove</code> or <code
class="OPTION">--service=remove</code> options will remove the service. Once removed, <tt
class="COMMAND">umestoreds</tt> exits.</p>

<p>The <code class="OPTION">-s config</code> or <code
class="OPTION">--service=config</code> options will update the configuration file used
with the service to be the given configuration file. Once updated, <tt
class="COMMAND">umestoreds</tt> exits.</p>

<p>Command line help is available with <code class="OPTION">-h</code>.</p>
</div>

<div class="REFSECT1"><a id="AEN3610" name="AEN3610"></a>
<h2>Usage Notes</h2>

<p>When installing the <b class="APPLICATION">UM</b> Persistent Store or Queue as a <span
class="TRADEMARK">Microsoft</span>&reg; <span class="TRADEMARK">Windows</span>&reg;
service, use only local disk devices and fully qualified path names for all filenames.
This is because Windows services run by default under a Local System account, which has
reduced privileges and is not allowed access to network devices.</p>

<p>Stopping the <b class="APPLICATION">UM</b> Persistent Store or Queue service triggers
a clean shutdown, which attempts to cleanly finish outstanding IO requests before
shutting down.</p>
</div>

<div class="REFSECT1"><a id="AEN3618" name="AEN3618"></a>
<h2>Exit Status</h2>

<p>The exit status from <tt class="COMMAND">umestored</tt> is 0 for success and some
non-zero value for failure.</p>
</div>

<h1><a id="UMQSLTOOL" name="UMQSLTOOL"></a>umqsltool</h1>

<div class="REFNAMEDIV"><a id="AEN3625" name="AEN3625"></a>
<h2>Name</h2>

umqsltool&nbsp;--&nbsp;UMQ SINC Log Tool</div>

<div class="REFSYNOPSISDIV"><a id="AEN3628" name="AEN3628"></a>
<h2>Synopsis</h2>

<p><tt class="COMMAND">umqsltool</tt> [<code class="OPTION">options</code>] <tt
class="REPLACEABLE"><i>sinclogfile1</i></tt> [<code class="OPTION"><tt
class="REPLACEABLE"><i>sinclogfile2</i></tt></code>]</p>
</div>

<div class="REFSECT1"><a id="AEN3638" name="AEN3638"></a>
<h2>Description</h2>

<p>This command provides SINC log file tools that let you dump to text, compare two
files, or trim events to reduce file size (all without modifying the original log
files).</p>

<p>The <code class="OPTION">-t</code> <i class="FIRSTTERM">toolname</i> or <code
class="OPTION">--tool=</code><i class="FIRSTTERM">toolname</i> invokes the desired tool.
<i class="FIRSTTERM">Toolname</i> can be:</p>

<div class="VARIABLELIST">
<dl>
<dt><tt class="FILENAME">dump</tt></dt>

<dd>
<p>Dumps the events from a SINC log file in a human-readable text format. Operates on a
single SINC log file.</p>
</dd>

<dt><tt class="FILENAME">diff</tt></dt>

<dd>
<p>Compares events in two SINC log files, noting any differences. Requires two SINC log
files to be specified.</p>
</dd>

<dt><tt class="FILENAME">analyze</tt></dt>

<dd>
<p>Analyzes a SINC log file for events that look suspicious. Operates on a single SINC
log file.</p>
</dd>

<dt><tt class="FILENAME">prune</tt></dt>

<dd>
<p>Trims a SINC log file down to the minimum number of events needed to preserve correct
queue state. This can sometimes dramatically reduce SINC log file size without any loss
of state. SINC log files are not pruned during normal operation due to performance
considerations.</p>

<p>This tool operates on a single SINC log file, and outputs a new SINC log file in the
same location and with the same name as the original plus an added ".pruned.n" suffix
(where n is a counter starting at 1). The original SINC log file remains untouched. When
pruning, we recommend to also specify the --config option, otherwise some state
information may be lost in the pruned output.</p>
</dd>
</dl>
</div>

<p>The <code class="OPTION">-c</code> <i class="FIRSTTERM">configfile</i> or <code
class="OPTION">--config=</code><i class="FIRSTTERM">configfile</i> uses the given
umestored XML config file. Specifying the umestored XML configuration file is optional,
but can improve the accuracy of various tools, so its use is recommended.</p>

<p>The <code class="OPTION">-h</code> or <code class="OPTION">--help</code> displays this
help and exits.</p>
</div>
</div>

<div class="SECTION">
<hr />
<h2 class="SECTION"><a id="UMESTORED-CONFIG" name="UMESTORED-CONFIG">12. Configuration
Reference for Umestored</a></h2>

<p>The operating parameters for <tt class="COMMAND">umestored</tt> come from an XML
configuration file that must be supplied on the <a href="#UMESTORED-MANPAGE">command
line</a>. <tt class="COMMAND">umestored</tt> contains a <b class="APPLICATION">UM</b>
context and receivers that may be configured with default values through a <b
class="APPLICATION">UM</b> configuration file referenced in the XML configuration file.
Default <b class="APPLICATION">UM</b> options my be overridden for each configured store
using the XML configuration file.</p>

<p>You configure <tt class="LITERAL">umestored</tt> to instantiate stores or queues with
the <tt class="LITERAL">umestored</tt> XML configuration file which <b
class="APPLICATION">UM</b> reads at start up. This <tt class="LITERAL">umestored</tt> XML
configuration file has the following sections.</p>

<ul>
<li>
<p>Daemon section - holds administrative parameters for such things as the location of
log files, the <b class="APPLICATION">UM</b> Configuration File, etc.</p>
</li>

<li>
<p>Stores section - holds parameters for any persistent stores and also the topics to be
persisted.</p>
</li>

<li>
<p>Queues section - holds parameters for the queues to be instantiated along with the
topics it should accept and the application set definitions which contain sets of
receivers.</p>
</li>
</ul>

<p><b class="APPLICATION">High Level Stores Configuration File.</b></p>

<pre class="SCREEN">
&lt;ume-store version="1.2"&#62;
  &lt;daemon&#62;
    <tt class="REPLACEABLE"><i>Daemon configuration options</i></tt>
  &lt;/daemon&#62;
  &lt;stores&#62;
    &lt;store <tt class="REPLACEABLE"><i>attributes</i></tt>&#62;
      &lt;topics&#62;
        &lt;topic <tt class="REPLACEABLE"><i>attributes</i></tt>&#62;
          &lt;ume-attributes&#62;
            &lt;option <tt class="REPLACEABLE"><i>attributes</i></tt>/&#62;
          &lt;/ume-attributes&#62;
        &lt;/topic&#62;
      &lt;/topics&#62;
    &lt;/store&#62;
  &lt;/stores&#62;
&lt;/ume-store&#62;
     
</pre>

<p><b class="APPLICATION">High Level Stores and Queues Configuration File.</b> The stores
and queues sections are both optional, although, you must specify at least one or the
other.</p>

<pre class="SCREEN">
&lt;ume-store version="1.2"&#62;
  &lt;daemon&#62;
    <tt class="REPLACEABLE"><i>Daemon configuration options</i></tt>
  &lt;/daemon&#62;
  &lt;stores&#62;
    &lt;store <tt class="REPLACEABLE"><i>attributes</i></tt>&#62;
      &lt;topics&#62;
        &lt;topic <tt class="REPLACEABLE"><i>attributes</i></tt>&#62;
          &lt;ume-attributes&#62;
            &lt;option <tt class="REPLACEABLE"><i>attributes</i></tt>/&#62;
          &lt;/ume-attributes&#62;
        &lt;/topic&#62;
      &lt;/topics&#62;
    &lt;/store&#62;
  &lt;/stores&#62;
  &lt;queues&#62;
    &lt;queue <tt class="REPLACEABLE"><i>attributes</i></tt>&#62;
      &lt;queue-groups&#62;
        &lt;queue-group <tt class="REPLACEABLE"><i>attributes</i></tt>/&#62;
      &lt;/queue-groups&#62;
      &lt;ume-attributes&#62;
        &lt;option <tt class="REPLACEABLE"><i>attributes</i></tt>/&#62;
      &lt;/ume-attributes&#62;
      &lt;indices&#62;
        &lt;index <tt class="REPLACEABLE"><i>attributes</i></tt>&#62;
          &lt;ume-attributes&#62;
            &lt;option <tt class="REPLACEABLE"><i>attributes</i></tt>/&#62;
          &lt;/ume-attributes&#62;
        &lt;/index&#62;
      &lt;/indices&#62;
      &lt;application-sets&#62;
        &lt;application-set <tt class="REPLACEABLE"><i>attributes</i></tt>&#62;
          &lt;ume-attributes&#62;
            &lt;option <tt class="REPLACEABLE"><i>attributes</i></tt>/&#62;
          &lt;/ume-attributes&#62;
          &lt;receiver-types&#62;
            &lt;receiver-type <tt class="REPLACEABLE"><i>attributes</i></tt>&#62;
              &lt;ume-attributes&#62;
                &lt;option <tt class="REPLACEABLE"><i>attributes</i></tt>/&#62;
              &lt;/ume-attributes&#62;
              &lt;index-rules <tt class="REPLACEABLE"><i>attributes</i></tt>&#62;
                &lt;<tt class="REPLACEABLE"><i>rules</i></tt>&#62;
              &lt;/index-rules&#62;
            &lt;/receiver-type&#62;
          &lt;/receiver-types&#62;
        &lt;/application-set&#62;
      &lt;/application-sets&#62;
      &lt;topics&#62;
        &lt;topic <tt class="REPLACEABLE"><i>attributes</i></tt>&#62;
          &lt;ume-attributes&#62;
            &lt;option <tt class="REPLACEABLE"><i>attributes</i></tt>/&#62;
          &lt;/ume-attributes&#62;
          &lt;application-sets&#62;
            &lt;/application-set <tt class="REPLACEABLE"><i>attributes</i></tt>
          &lt;/application-sets&#62;
        &lt;/topic&#62;
      &lt;/topics&#62;
    &lt;/queue&#62;
  &lt;/queues&#62;
&lt;/ume-store&#62;
     
</pre>

<p>This section discusses the following topics.</p>

<ul>
<li>
<p><a href="#UMESTORED-DAEMON-TAGS"><i>Daemon Element</i></a></p>
</li>

<li>
<p><a href="#UMESTORED-STORES-ELEMENT"><i>Stores Element</i></a></p>

<ul>
<li>
<p><a href="#UMESTORED-TOPICS-ELEMENT"><i>Topics Element</i></a></p>
</li>
</ul>
</li>

<li>
<p><a href="#UMESTORED-QUEUES-ELEMENT"><i>Queues Element</i></a></p>

<ul>
<li>
<p><a href="#UMESTORED-QUEUE-ELEMENT"><i>Queue Element</i></a></p>
</li>

<li>
<p><a href="#UMESTORED-INDICES-ELEMENT"><i>Indices Element</i></a></p>
</li>

<li>
<p><a href="#UMESTORED-APPSETS-ELEMENT"><i>Application Sets Element</i></a></p>
</li>

<li>
<p><a href="#UMESTORED-QTOPICS-ELEMENT"><i>QueueTopics Element</i></a></p>
</li>
</ul>
</li>

<li>
<p><a href="#OPTION-TYPES"><i>Option Types for ume-attributes Elements</i></a></p>
</li>

<li>
<p><a href="#UMESTORED-CONFIG-DTD"><i>umestored Configuration DTD</i></a></p>
</li>

<li>
<p><a href="#UMESTORED-CONFIG-EXAMPLE"><i>Store Configuration Example</i></a></p>
</li>

<li>
<p><a href="#QUEUE-CONFIG-EXAMPLE"><i>Queue Configuration Example</i></a></p>
</li>
</ul>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="UMESTORED-DAEMON-TAGS" name="UMESTORED-DAEMON-TAGS">12.1.
Daemon Element</a></h3>

<p>The following table presents child elements allowed in the <code
class="PARAMETER">daemon</code> configuration section.</p>

<div class="INFORMALTABLE"><a id="AEN3771" name="AEN3771"></a>
<table border="1" class="CALSTABLE">
<col />
<col />
<col />
<thead>
<tr>
<th>Tag</th>
<th>Description</th>
<th>Default Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><tt class="LITERAL">log</tt></td>
<td>Required. Pathname for log file.</td>
<td>None--this is a required element.</td>
</tr>

<tr>
<td><tt class="LITERAL">pidfile</tt></td>
<td>Pathname for daemon process ID (pid) file</td>
<td>No pidfile</td>
</tr>

<tr>
<td><tt class="LITERAL">uid</tt></td>
<td>User ID (uid) for daemon process (if started as root)</td>
<td>Daemon retains starting uid</td>
</tr>

<tr>
<td><tt class="LITERAL">gid</tt></td>
<td>Group ID (gid) for daemon process (if started as root)</td>
<td>Daemon retains starting gid</td>
</tr>

<tr>
<td><tt class="LITERAL">lbm-config</tt></td>
<td>Pathname for <b class="APPLICATION">UM</b> configuration file</td>
<td>No config file; use <b class="APPLICATION">UM</b> defaults</td>
</tr>

<tr>
<td><tt class="LITERAL">lbm-license-file</tt></td>
<td>Pathname for <b class="APPLICATION">UM</b> license file</td>
<td>License read from environment</td>
</tr>

<tr>
<td><tt class="LITERAL">web-monitor</tt></td>
<td>Address:port where web monitor listens. Address of <tt class="LITERAL"><b
class="APPLICATION">*</b></tt> listens on all interfaces. Also has a single attribute,
<tt class="LITERAL"><b class="APPLICATION">permission</b></tt>, allowable values are <tt
class="REPLACEABLE"><i>read-only</i></tt> and <tt
class="REPLACEABLE"><i>read-write</i></tt>. Using <tt
class="REPLACEABLE"><i>read-only</i></tt> disables the text fields and buttons on a Web
Monitor "debug page" that can only be enabled by Informatica Support. Example: <tt
class="LITERAL">&lt;:web-monitor
permission="read-only"&#62;*:15304&lt;:/web-monitor&#62;</tt> </td>
<td>No web monitor</td>
</tr>

<tr>
<td><tt class="LITERAL">lbm-password-file</tt></td>
<td>Pathname for Queue Browser authentication file.</td>
<td><span class="emphasis"><i
class="EMPHASIS">rel-id/platform-id</i></span>/bin/password.xml</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="UMESTORED-STORES-ELEMENT"
name="UMESTORED-STORES-ELEMENT">12.2. Stores Element</a></h3>

<p>The Stores Element is a container for individual store elements which define specific
store instances. The below is an example of a Stores Element.</p>

<pre class="SCREEN">
  &lt;stores&#62;
    &lt;store name="test-store-1" port="14567"&#62;
      &lt;ume-attributes&#62; ... &lt;/ume-attributes&#62;
      &lt;topics&#62;
        &lt;topic pattern="quote*" type="PCRE"&#62;
          &lt;ume-attributes&#62; ... &lt;/ume-attributes&#62;
        &lt;/topic&#62;
        &lt;topic pattern="subject*" type="PCRE"&#62;
          &lt;ume-attributes&#62; ... &lt;/ume-attributes&#62;
        &lt;/topic&#62;
      &lt;/topics&#62;
    &lt;/store&#62;
    &lt;store name="test-store-2" port="14568"&#62;
      &lt;ume-attributes&#62; ... &lt;/ume-attributes&#62;
      &lt;topics&#62;
        &lt;topic pattern="issue*" type="PCRE"&#62;
          &lt;ume-attributes&#62; ... &lt;/ume-attributes&#62;
        &lt;/topic&#62;
        &lt;topic pattern="topic*" type="PCRE"&#62;
          &lt;ume-attributes&#62; ... &lt;/ume-attributes&#62;
        &lt;/topic&#62;
      &lt;/topics&#62;
    &lt;/store&#62;
  &lt;/stores&#62;
 
</pre>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UMESTORED-STORE-ELEMENT"
name="UMESTORED-STORE-ELEMENT">12.2.1. Store Element</a></h4>

<p>The Store Element contains information about an individual <b
class="APPLICATION">UMP</b> store and has attributes, options and topics. See the example
below.</p>

<pre class="SCREEN">
  &lt;store name="test-store-1" port="14567"&#62;
    &lt;ume-attributes&#62; ... &lt;/ume-attributes&#62;
    &lt;topics&#62;
      &lt;topic pattern="quote*" type="PCRE"&#62;
        &lt;ume-attributes&#62; ... &lt;/ume-attributes&#62;
      &lt;/topic&#62;
      &lt;topic pattern="subject*" type="PCRE"&#62;
        &lt;ume-attributes&#62; ... &lt;/ume-attributes&#62;
      &lt;/topic&#62;
    &lt;/topics&#62;
  &lt;/store&#62;
 
</pre>

<p>The following table gives attributes for <code class="PARAMETER">store</code>
elements.</p>

<div class="INFORMALTABLE"><a id="AEN3842" name="AEN3842"></a>
<table border="1" class="CALSTABLE">
<col />
<col />
<col />
<thead>
<tr>
<th>Attribute</th>
<th>Description</th>
<th>Default Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><tt class="LITERAL">name</tt></td>
<td>Specifies the name for the store.</td>
<td>None--this is a required attribute</td>
</tr>

<tr>
<td><tt class="LITERAL">port</tt></td>
<td>TCP port where <tt class="COMMAND">umestored</tt> should listen for this store.</td>
<td>None--this is a required attribute and a valid (non-zero) port must be
specified.</td>
</tr>

<tr>
<td><tt class="LITERAL">interface</tt></td>
<td>Specifies the network interface over which <tt class="COMMAND">umestored</tt> accepts
connection requests for this store.</td>
<td>0.0.0.0 (<code class="CONSTANT">INADDR_ANY</code>)</td>
</tr>
</tbody>
</table>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="UMESTORED-STORE-TAGS" name="UMESTORED-STORE-TAGS">12.2.1.1.
Child Elements of the Store Element</a></h5>

<p>The following table gives the child elements allowed in the <code
class="PARAMETER">store</code> configuration section.</p>

<div class="INFORMALTABLE"><a id="AEN3872" name="AEN3872"></a>
<table border="1" class="CALSTABLE">
<col />
<col />
<col />
<thead>
<tr>
<th>Child Element</th>
<th>Description</th>
<th>Default Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><tt class="LITERAL">topics</tt></td>
<td>A container for <tt class="LITERAL">topic</tt> elements. See <a
href="#UMESTORED-TOPICS-ELEMENT"><i>Topics Element</i></a> for more information.</td>
<td>None</td>
</tr>

<tr>
<td><tt class="LITERAL">ume-attributes</tt></td>
<td>A container for <tt class="LITERAL">option</tt> elements. See <a
href="#UMESTORED-STORE-OPTIONS"><i>Options for a Store's ume-attributes Element</i></a>
for more information.</td>
<td>None</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="UMESTORED-STORE-OPTIONS"
name="UMESTORED-STORE-OPTIONS">12.2.1.2. Options for a Store's ume-attributes
Element</a></h5>

<p>You can configure context (scope) options with a <code class="PARAMETER">type</code>
attribute of <code class="PARAMETER">lbm-context</code>. UM passes such options through
the normal receiver and context configuration option setting mechanisms. See the <a
href="../Config/index.html" target="doccontent">UM Configuration Guide</a> for details. Store
options without a <code class="PARAMETER">type</code> attribute or those explicitly given
a <code class="PARAMETER">type</code> attribute of <code class="PARAMETER">store</code>
simply configure the store itself.</p>

<p>The following table gives options allowed for a <code class="PARAMETER">store</code>
element. Use the <tt class="LITERAL">store</tt> Option Type for these options. A Store's
ume-attributes Element can also accept the <tt class="LITERAL">lbm-context</tt> Option
Type. See <a href="#OPTION-TYPES"><i>Option Types for ume-attributes Elements</i></a> for
more information.</p>

<div class="INFORMALTABLE"><a id="AEN3908" name="AEN3908"></a>
<table border="1" class="CALSTABLE">
<col />
<col />
<col />
<thead>
<tr>
<th>Option</th>
<th>Description</th>
<th>Default Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><tt class="LITERAL">disk-cache-directory</tt></td>
<td>Pathname for disk store message cache directory</td>
<td>umestored-cache</td>
</tr>

<tr>
<td><tt class="LITERAL">disk-state-directory</tt></td>
<td>Pathname for disk store state directory</td>
<td>umestored-state</td>
</tr>

<tr>
<td><tt class="LITERAL">allow-proxy-source</tt></td>
<td>Allows the store to act as a proxy source in case a registered source
terminates.</td>
<td>0 (Disable)</td>
</tr>

<tr>
<td><tt class="LITERAL">context-name</tt></td>
<td>Name of the store that can be used by sources to refer to the store instead of the
address:request port. A store runs in its own context, therefore a name can used to
represent the address:request port. This name facilitates <b class="APPLICATION">UMP</b>
operation across the UM Gateway. Restricted to 128 characters in length, and may contain
only alphanumeric characters, hyphens, and underscores.</td>
<td>None.</td>
</tr>

<tr>
<td><tt class="LITERAL">retransmission-request-processing-rate</tt></td>
<td>Specifies the number of retransmission requests processed by a store per second
across all topics. The store drops all retransmission requests that exceed this
value.</td>
<td>262144</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UMESTORED-TOPICS-ELEMENT"
name="UMESTORED-TOPICS-ELEMENT">12.2.2. Topics Element</a></h4>

<p>The Topics element is a container element for all the topics persisted by the <b
class="APPLICATION">UMP</b> store. It is one of the two child elements of the Store
Element. See the example below.</p>

<pre class="SCREEN">
  &lt;topics&#62;
    &lt;topic pattern="issue*" type="PCRE"&#62;
      &lt;ume-attributes&#62; ... &lt;/ume-attributes&#62;
    &lt;/topic&#62;
    &lt;topic pattern="topic*" type="PCRE"&#62;
      &lt;ume-attributes&#62; ... &lt;/ume-attributes&#62;
    &lt;/topic&#62;
  &lt;/topics&#62;
       
</pre>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="UMESTORED-TOPIC-ELEMENT"
name="UMESTORED-TOPIC-ELEMENT">12.2.2.1. Topic Element</a></h5>

<p>The Topic Element defines an individual topic persisted on the <b
class="APPLICATION">UMP</b> store. The following table gives attributes for the <code
class="PARAMETER">topic</code> element.</p>

<div class="INFORMALTABLE"><a id="AEN3952" name="AEN3952"></a>
<table border="1" class="CALSTABLE">
<col />
<col />
<col />
<thead>
<tr>
<th>Attribute</th>
<th>Description</th>
<th>Default Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><tt class="LITERAL">pattern</tt></td>
<td>Specifies a pattern used to select topics for which a store provides persistence
services.</td>
<td>None--this is a required attribute</td>
</tr>

<tr>
<td><tt class="LITERAL">type</tt></td>
<td>Specifies the type of matching to be performed on the <tt
class="LITERAL">pattern</tt> attribute. A value of <tt class="LITERAL">direct</tt>
selects an exact string match. A value of <tt class="LITERAL">PCRE</tt> selects a Perl
Compatible Regular Expression match. A value of <tt class="LITERAL">regexp</tt> selects a
POSIX extended regular expression. <tt class="LITERAL">PCRE</tt>, or <tt
class="LITERAL">regexp</tt>.</td>
<td><tt class="LITERAL">direct</tt></td>
</tr>
</tbody>
</table>
</div>

<p>The Topic Element has one child element, <code
class="PARAMETER">ume-attributes</code>, the options for which appear in <a
href="#UMESTORED-TOPIC-OPTIONS"><i>Options for a Topic's ume-attributes
Element</i></a>.</p>

<div class="SECTION">
<hr />
<h6 class="SECTION"><a id="UMESTORED-TOPIC-OPTIONS"
name="UMESTORED-TOPIC-OPTIONS">12.2.2.1.1. Options for a Topic's ume-attributes
Element</a></h6>

<p>The following table gives options allowed for a <code class="PARAMETER">topic</code>
element. Use the <tt class="LITERAL">store</tt> Option Type for these options. You can
also configure receiver (scope) options and source (scope) options in a Topic's
ume-attributes Element by using the Option Types <tt class="LITERAL">lbm-receiver</tt>
and <tt class="LITERAL">lbm-source</tt>, respectively. See <a
href="#OPTION-TYPES"><i>Option Types for ume-attributes Elements</i></a> for more
information.</p>

<div class="INFORMALTABLE"><a id="AEN3988" name="AEN3988"></a>
<table border="1" class="CALSTABLE">
<col />
<col />
<col />
<thead>
<tr>
<th>Option</th>
<th>Description</th>
<th>Default Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><tt class="LITERAL">retransmission-request-forwarding</tt></td>
<td>If enabled (value = 1), the store always forwards retransmission requests to sources
and does not service any requests itself. If disabled (value = 0), the store services
retransmission requests for data it has, and forwards requests to sources for data it
does not have.</td>
<td>0 (store services retransmission requests)</td>
</tr>

<tr>
<td><tt class="LITERAL">repository-type</tt></td>
<td>Specifies how messages should be retained by the store. A value of <code
class="PARAMETER">no-cache</code> does not retain messages, only state information. A
value of <code class="PARAMETER">memory</code> retains messages only in the (presumably
volatile) main memory of the store. A value of <code class="PARAMETER">disk</code>
retains messages to (presumably non-volatile) disk storage as quickly as possible. In
addition, messages are cached in main memory for a time as well. A value of <code
class="PARAMETER">reduced-fd</code> retains messages in disk storage using significantly
fewer File Descriptors. Use of this repository type may impact performance. (See <a
href="#STORE-ARCH"><i>Persistent Store Architecture</i></a>.) The <code
class="PARAMETER">reduced-fd</code> disk storage option is not available on <span
class="TRADEMARK">Microsoft</span> <span class="TRADEMARK">Windows</span>.</td>
<td>no-cache</td>
</tr>

<tr>
<td><tt class="LITERAL">repository-size-threshold</tt></td>
<td>For topics with a <code class="PARAMETER">repository-type</code> of <code
class="PARAMETER">memory</code>, <code class="PARAMETER">disk</code> or <code
class="PARAMETER">reduced-fd</code>, specifies the minimum number of message bytes
(includes payload, headers, and store structure overhead) retained for a topic. For RPP
repositories, this value only includes message payload. For the <code
class="PARAMETER">disk</code> or <code class="PARAMETER">reduced-fd</code> repository
type, this value configures the size threshold of the memory cache. (units: bytes)</td>
<td>25165824 (24 MB)</td>
</tr>

<tr>
<td><tt class="LITERAL">repository-size-limit</tt></td>
<td>For topics with a <code class="PARAMETER">repository-type</code> of <code
class="PARAMETER">memory</code>, <code class="PARAMETER">disk</code> or <code
class="PARAMETER">reduced-fd</code>, specifies the maximum number of message bytes
(includes payload, headers, and store structure overhead) retained for each source. For
RPP repositories, this value only includes message payload. For the <code
class="PARAMETER">disk</code> or <code class="PARAMETER">reduced-fd</code> repository
type, this value configures the size of the memory cache. (units: bytes)</td>
<td>50331648 (48 MB)</td>
</tr>

<tr>
<td><tt class="LITERAL">repository-age-threshold</tt></td>
<td>For topics with a <code class="PARAMETER">repository-type</code> of <code
class="PARAMETER">memory</code>, <code class="PARAMETER">disk</code> or <code
class="PARAMETER">reduced-fd</code>, specifies a message age threshold. Younger messages
will be retained. Space used to store older messages may be reclaimed. A value of 0 means
message age is not considered in retention decisions. (units: seconds)</td>
<td>0</td>
</tr>

<tr>
<td><tt class="LITERAL">repository-disk-max-async-cbs</tt></td>
<td>For topics with a <code class="PARAMETER">repository-type</code> of <code
class="PARAMETER">disk</code> or <code class="PARAMETER">reduced-fd</code>, specifies the
maximum number of outstanding async I/O callbacks for reading and writing messages to
disk. (units: async callbacks)</td>
<td>16 callbacks</td>
</tr>

<tr>
<td><tt class="LITERAL">repository-disk-max-write-async-cbs</tt></td>
<td>For topics with a <code class="PARAMETER">repository-type</code> of <code
class="PARAMETER">disk</code> or <code class="PARAMETER">reduced-fd</code>, specifies the
maximum number of outstanding async I/O callbacks for writing messages to disk. Reducing
this option can improve throughput by batching more fragments into a single write.
(units: async callbacks)</td>
<td>16 callbacks</td>
</tr>

<tr>
<td><tt class="LITERAL">repository-disk-max-read-async-cbs</tt></td>
<td>For topics with a <code class="PARAMETER">repository-type</code> of <code
class="PARAMETER">disk</code> or <code class="PARAMETER">reduced-fd</code>, specifies the
maximum number of outstanding async I/O callbacks for reading messages from disk. Raising
this value can improve recovery rates. For topics with a repository-type of <code
class="PARAMETER">reduced-fd</code>, Informatica recommendeds a value of 200 times the
number of expected receivers per topic. (units: async callbacks)</td>
<td>16 callbacks</td>
</tr>

<tr>
<td><tt class="LITERAL">repository-disk-file-size-limit</tt></td>
<td>For topics with a <code class="PARAMETER">repository-type</code> of <code
class="PARAMETER">disk</code> or <code class="PARAMETER">reduced-fd</code>, specifies the
maximum amount of disk space that will be used to store retained messages. A minimum
value of 196992 is enforced. (units: bytes)</td>
<td>104857600 (100 MB)</td>
</tr>

<tr>
<td><tt class="LITERAL">repository-disk-file-preallocate</tt></td>
<td>For topics with a <code class="PARAMETER">repository-type</code> of <code
class="PARAMETER">disk</code>, If set to 1, <b class="APPLICATION">UMP</b> pre-allocates
a store's cache files to match their maximum size on disk (as configured by <tt
class="LITERAL">repository-disk-file-size-limit</tt>) upon creation, as opposed to
growing to that size as the store receives new messages. For ext3/4 and NTFS file
systems, this options creates a sparse file, which does not allocate all of the
underlying data blocks. Advantages of pre-allocation include better performance on
rotating disks due to less file fragmentation, and knowing that enough disk space exists
for any new source that registers. Disadvantage is the time to create the cache files,
especially if many sources register at once.</td>
<td>0 (zero) - do not pre-allocate</td>
</tr>

<tr>
<td><tt class="LITERAL">repository-disk-async-buffer-length</tt></td>
<td>For topics with a <code class="PARAMETER">repository-type</code> of <code
class="PARAMETER">disk</code> or <code class="PARAMETER">reduced-fd</code>, specifies the
size of the buffers that will be used in async I/O operations for reading and writing
messages to disk. A minimum value of 65664 is enforced. (units: bytes)</td>
<td>65664 (64 KB + 128)</td>
</tr>

<tr>
<td><tt class="LITERAL">repository-disk-message-checksum</tt></td>
<td>For topics with a <code class="PARAMETER">repository-type</code> of <code
class="PARAMETER">disk</code> or <code class="PARAMETER">reduced-fd</code>, specifies
whether the messages saved to disk should include a checksum field or not for validation
if the store is restarted. (units: flag)</td>
<td>0 (disabled)</td>
</tr>

<tr>
<td><tt class="LITERAL">source-activity-timeout</tt></td>
<td>Establishes the period of time from a source's last activity to the release of the
source's RegID. Stores return an error to any new source requesting the source's RegID
during this period. If proxy sources are enabled ( <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMEACTIVITYTIMEOUT"
target="doccontent"><tt class="LITERAL">ume_proxy_source</tt></a>) the store does not release
the source's RegID and <b class="APPLICATION">UMP</b> elects a proxy source. If neither
proxy sources nor <a
href="../Config/ultramessagingpersistenceoptions.html#RECEIVERUMESTATELIFETIME"
target="doccontent"><tt class="LITERAL">ume_state_lifetime</tt></a> are configured, the store
also deletes the source's state and cache. Can be overridden by <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMEACTIVITYTIMEOUT"
target="doccontent"><tt class="LITERAL">ume_activity_timeout</tt></a>. See also <a
href="#PROXYSOURCES"><i>Proxy Sources</i></a>. (units: milliseconds)</td>
<td>30000 (30 seconds)</td>
</tr>

<tr>
<td><tt class="LITERAL">source-state-lifetime</tt></td>
<td>Establishes the period of time from a source's last activity to the deletion of the
source's state and cache by the store, regardless of whether a proxy source has been
created or not. You can also configure <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMESTATELIFETIME"
target="doccontent"><tt class="LITERAL">ume_state_lifetime</tt></a> for the source. The store
uses whichever is shorter. See also <a href="#PROXYSOURCES"><i>Proxy Sources</i></a>.
(units: milliseconds)</td>
<td>0 (zero)</td>
</tr>

<tr>
<td><tt class="LITERAL">receiver-activity-timeout</tt></td>
<td>Establishes the period of time from a receiver's last activity to the release of the
receiver's RegID. Stores return an error to any new request for the receiver's RegID
during this period. Can be overridden by <a
href="../Config/ultramessagingpersistenceoptions.html#RECEIVERUMEACTIVITYTIMEOUT"
target="doccontent"><tt class="LITERAL">ume_activity_timeout</tt></a>. See also <a
href="#PROXYSOURCES"><i>Proxy Sources</i></a>. (units: milliseconds)</td>
<td>30000 (30 seconds)</td>
</tr>

<tr>
<td><tt class="LITERAL">receiver-state-lifetime</tt></td>
<td>Establishes the period of time from a receiver's last activity to the deletion of the
receiver's state and cache by the store. You can also configure <a
href="../Config/ultramessagingpersistenceoptions.html#RECEIVERUMESTATELIFETIME"
target="doccontent"><tt class="LITERAL">ume_state_lifetime</tt></a> for the receiver. The store
uses whichever is shorter. See also <a href="#PROXYSOURCES"><i>Proxy Sources</i></a>.
(units: milliseconds)</td>
<td>0 (zero)</td>
</tr>

<tr>
<td><tt class="LITERAL">source-check-interval</tt></td>
<td>Specifies how often a store will check for activity of sources and receivers. (units:
milliseconds)</td>
<td>100 (100 milliseconds)</td>
</tr>

<tr>
<td><tt class="LITERAL">keepalive-interval</tt></td>
<td>Specifies how often a store will generate keepalive traffic to sources and receivers
if there has been no traffic required in the normal course of operation. (units:
milliseconds)</td>
<td>500 (500 milliseconds)</td>
</tr>

<tr>
<td><tt class="LITERAL">receiver-new-registration-rollback</tt></td>
<td>Specifies the number of stabilized messages that a newly registered receiver should
consume. For example, setting this to 10, "rolls back" the new receiver's starting
message to the 10th most recent message. This value must be positive and less than
2147483648. The recommended value of 2147483647 indicates that the rollback should begin
at the start of the stream. A value of 0 indicates the store should instruct the
receivers to start with the next new message from the source known by the store. (units:
messages)</td>
<td>0 (no recovery requested)</td>
</tr>

<tr>
<td><tt class="LITERAL">proxy-election-interval</tt></td>
<td>Specifies the interval, in milliseconds, used when electing a proxy source. When a
source, which requested that a proxy source be provided for it, has been detected as no
longer active, each store eligible to provide a proxy source for it waits for an amount
of time which is randomized in the range [0.5*<tt
class="LITERAL">proxy-election_interval</tt> .. 1.5*<tt
class="LITERAL">proxy-election_interval</tt>]. If no other store has been elected to
serve as the proxy source, the store declares itself as the proxy source. (units:
milliseconds)</td>
<td>5000 (5 seconds)</td>
</tr>

<tr>
<td><tt class="LITERAL">stability-ack-interval</tt></td>
<td>Specifies the maximum amount of time that stability acknowledgments will be batched
before being sent to a source. Batching stability ACKs can increase throughput of <b
class="APPLICATION">UMP</b> stores (especially memory stores) significantly, but
introduces a delay between when a message is actually stable in the <b
class="APPLICATION">UMP</b> store and when the source is notified of message stability.
(units: milliseconds)</td>
<td>200 (200 milliseconds)</td>
</tr>

<tr>
<td><tt class="LITERAL">stability-ack-minimum-number</tt></td>
<td>Specifies the minimum number of message stability acknowledgments that must
accumulate before a stability ACK is sent to a source. With the default value of 1,
stability ACKs are sent immediately as soon as messages are stable. Increasing this value
causes stability ACKs to be batched, which can increase throughput of <b
class="APPLICATION">UMP</b> stores (especially memory stores) significantly, but
introduces a delay between when a message is actually stable in the <b
class="APPLICATION">UMP</b> store and when the source is notified of message stability.
If using a stability ACK-based flight size on a <b class="APPLICATION">UMP</b> source in
combination with this option, it is advisable to make sure <tt
class="LITERAL">stability-ack-minimum-number</tt> is set less than or equal to the
source's flight size. Otherwise, stability ACKs will only be sent upon expiration of the
<tt class="LITERAL">stability-ack-interval</tt> timer, resulting in bursty stop-and-go
sending. (units: number of message fragments)</td>
<td>1 (1 fragment)</td>
</tr>

<tr>
<td><tt class="LITERAL">repository-allow-receiver-paced-persistence</tt></td>
<td>Specifies if the repository allows receiver-paced persistence (1) or a source-paced
persistence (0). The source must enable or disable this option with <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMERECEIVERPACEDPERSISTENCE"
target="doccontent">ume_receiver_paced_persistence</a>, but cannot enable it if this value is
set to 0.</td>
<td>0 (source-paced persistence)</td>
</tr>

<tr>
<td><tt class="LITERAL">repository-allow-ack-on-reception</tt></td>
<td>Specifies if the repository should acknowledge to the source that it has persisted a
message as soon as the repository receives it instead of when it writes the message to
disk. Set this option to 1 to allow this behavior. The source must also set this option
with <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMEREPOSITORYACKONRECEPTION"
target="doccontent"><tt class="LITERAL">ume_repository_ack_on_reception</tt></a> to enable this
behavior, but cannot enable it if this value is set to 0. For memory stores, this option
has no effect. This option only applies to RPP repositories (<tt
class="LITERAL">repository-allow-receiver-paced-persistence</tt> = 1).</td>
<td>0 (store acknowledges persistence when the store writes the message to disk)</td>
</tr>

<tr>
<td><tt class="LITERAL">repository-disk-write-delay</tt></td>
<td>For topics with a <code class="PARAMETER">repository-type</code> of <code
class="PARAMETER">disk</code> or <code class="PARAMETER">reduced-fd</code>, specifies the
maximum delay in milliseconds before the repository persists a message to disk. If the
repository sets this option a value other than the default, the source can reconfigure
this option with <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMEWRITEDELAY"
target="doccontent"><tt class="LITERAL">ume_write_delay</tt></a> to a lower or equal value, but
cannot increase it. (units: milliseconds)</td>
<td>0 milliseconds</td>
</tr>

<tr>
<td><tt class="LITERAL">source-flight-size-bytes-maximum</tt></td>
<td>Specifies the maximum message payload in bytes allowed to be inflight (un-stabilized
at a store and without delivery confirmation) before a new message send either blocks or
triggers a notification source event. <b class="APPLICATION">UMP</b> monitors both this
option and <a href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMEFLIGHTSIZE"
target="doccontent"><tt class="LITERAL">ume_flight_size</tt></a>. If either threshold is met,
the configured blocking or notification behavior executes. See <a
href="../Config/ultramessagingpersistenceoptions.html#SOURCEUMEFLIGHTSIZEBEHAVIOR"
target="doccontent"><tt class="LITERAL">ume_flight_size_behavior</tt></a>. A source can
reconfigure this option to a value of less than or equal to this value. This option only
applies to RPP repositories (<tt
class="LITERAL">repository-allow-receiver-paced-persistence</tt> = 1). (units:
bytes)</td>
<td>4194304 bytes (4MB)</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="UMESTORED-QUEUES-ELEMENT"
name="UMESTORED-QUEUES-ELEMENT">12.3. Queues Element</a></h3>

<p>The Queues Element is a container element for all queues. An abbreviated queues
section appears below.</p>

<pre class="SCREEN">
&lt;queues&#62;
  &lt;queue name="Queue 1" interface=10.29.3.24" port="20555" group-index="0"&#62;
    &lt;queue-groups&#62;
      &lt;queue-group index="0" size="5"/&#62;
      &lt;queue-group index="1" size="1"/&#62;
    &lt;/queue-groups&#62;
    &lt;ume-attributes&#62; ... &lt;/ume-attributes&#62;
    &lt;application-sets&#62; ... &lt;/application-sets&#62;
    &lt;topics&#62; ... &lt;/topics&#62;
  &lt;/queue&#62;
  &lt;queue name="Queue 2" interface=10.29.3.25" port="20555" group-index="0"&#62;
    &lt;queue-groups&#62;
      &lt;queue-group index="0" size="5"/&#62;
      &lt;queue-group index="1" size="1"/&#62;
    &lt;/queue-groups&#62;
    &lt;ume-attributes&#62; ... &lt;/ume-attributes&#62;
    &lt;application-sets&#62; ... &lt;/application-sets&#62;
    &lt;topics&#62; ... &lt;/topics&#62;
  &lt;/queue&#62;
&lt;/queues&#62;
   
</pre>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UMESTORED-QUEUE-ELEMENT"
name="UMESTORED-QUEUE-ELEMENT">12.3.1. Queue Element</a></h4>

<p>The Queue Element defines a single queue. Each queue must have a unique <tt
class="LITERAL">name</tt> and a <tt class="LITERAL">port</tt>. An <tt
class="LITERAL">interface</tt>, <tt class="LITERAL">group-index</tt> and <tt
class="LITERAL">group-size</tt> are optional. The following table gives attributes for a
<code class="PARAMETER">queue</code> element.</p>

<div class="INFORMALTABLE"><a id="AEN4227" name="AEN4227"></a>
<table border="1" class="CALSTABLE">
<col />
<col />
<col />
<thead>
<tr>
<th>Attribute</th>
<th>Description</th>
<th>Default Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><tt class="LITERAL">name</tt></td>
<td>Specifies the name for the queue. The queue name is the prime method for identifying
the queue and must be unique. <b class="APPLICATION">UMQ</b> uses it during queue
resolution, etc.</td>
<td>None--this is a required attribute</td>
</tr>

<tr>
<td><tt class="LITERAL">port</tt></td>
<td>TCP port where <tt class="COMMAND">umestored</tt> should listen for this queue. As
with <b class="APPLICATION">UMP</b> stores, <b class="APPLICATION">UMQ</b> access the
queue during registration and other operations with the port.</td>
<td>None--this is a required attribute</td>
</tr>

<tr>
<td><tt class="LITERAL">interface</tt></td>
<td>Specifies the network interface over which <tt class="COMMAND">umestored</tt> accepts
connection requests for this queue.</td>
<td>0.0.0.0 (<code class="CONSTANT">INADDR_ANY</code>)</td>
</tr>

<tr>
<td><tt class="LITERAL">group-index</tt></td>
<td>A number that identifies this queue instance's queue group. See <a
href="#QUEUE-REDUNDANCY"><i>Queue Redundancy</i></a> for more information.</td>
<td>0 - Valid values range from 0 to 65535.</td>
</tr>

<tr>
<td><tt class="LITERAL">group-size</tt></td>
<td>The number of queue instances in this queue's group. You can use this attribute to
specify the number of queue instances instead of the <a
href="#QUEUE-GROUPS-ELEMENT"><i>Queue Groups Element</i></a> if the queue consists of
only one group.</td>
<td>1 - Valid values range from 1 to 65535.</td>
</tr>
</tbody>
</table>
</div>

<p>The Queue Element can be configured with the <a href="#QUEUE-GROUPS-ELEMENT"><i>Queue
Groups Element</i></a>, <a href="#UMESTORED-APPSETS-ELEMENT"><i>Application Sets
Element</i></a> and <a href="#UMESTORED-QTOPICS-ELEMENT"><i>QueueTopics Element</i></a>.
The options for a Queue's <code class="PARAMETER">ume-attributes</code> appear in the
following sections.</p>

<ul>
<li>
<p><a href="#GEN-QUEUE-OPTIONS"><i>General Options for a Queue's ume-attributes
Element</i></a></p>
</li>

<li>
<p><a href="#MESSAGE-STORAGE-OPTIONS"><i>Message Storage Options for a Queue's
ume-attributes Element</i></a></p>
</li>

<li>
<p><a href="#QUEUE-MANAGEMENT-OPTIONS"><i>Queue Management Options for a Queue's
ume-attributes Element</i></a></p>
</li>

<li>
<p><a href="#QSI-OPTIONS"><i>Queue Slave Instance (QSI) Options for a Queue's
ume-attributes Element</i></a></p>
</li>
</ul>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="QUEUE-GROUPS-ELEMENT" name="QUEUE-GROUPS-ELEMENT">12.3.1.1.
Queue Groups Element</a></h5>

<p>The <code class="PARAMETER">queue-groups</code> element contains <code
class="PARAMETER">queue-group</code> elements that define all the queue groups that make
up the queue. In the abbreviated Queues section shown in <a
href="#UMESTORED-QUEUES-ELEMENT"><i>Queues Element</i></a>, the <code
class="PARAMETER">queue</code> element,</p>

<pre class="SCREEN">
  &lt;queue name="Queue 1" interface=10.29.3.24" port="20555" group-index="0"&#62;
       
</pre>

<p>specifies <tt class="LITERAL">Queue 1</tt> as a Queue Instance in Group 0. The <code
class="PARAMETER">queue-groups</code> element in the same sample specifies that <tt
class="LITERAL">Queue 1</tt> comprises two groups, Group 0, which has 5 queue instances
and Group 1, which has 1 queue instance.</p>

<pre class="SCREEN">
    &lt;queue-groups&#62;
      &lt;queue-group index="0" size="5"/&#62;
      &lt;queue-group index="1" size="1"/&#62;
    &lt;/queue-groups&#62;
   
</pre>

<p>To completely configure <tt class="LITERAL">Queue 1</tt>, you must specify 6 queue
instances in either one <tt class="LITERAL">umestored.xml</tt> file as individual queue
elements within the queues element or in separate <tt class="LITERAL">umestored.xml</tt>
files, one for each instance. The Queue Element for all 6 queue instances would be the
same except for the <code class="PARAMETER">interface</code>, <code
class="PARAMETER">port</code> and <code class="PARAMETER">group-index</code> because
every instance of <tt class="LITERAL">Queue 1</tt> must have the same <code
class="PARAMETER">name</code>. And all 6 queue instances would also have the same <code
class="PARAMETER">queue-groups</code> configured.</p>

<div class="INFORMALTABLE"><a id="AEN4309" name="AEN4309"></a>
<table border="1" class="CALSTABLE">
<col />
<col />
<col />
<thead>
<tr>
<th>Attribute</th>
<th>Description</th>
<th>Default Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><tt class="LITERAL">index</tt></td>
<td>The queue's redundancy group. See <a href="#QUEUE-REDUNDANCY"><i>Queue
Redundancy</i></a> for more information.</td>
<td>0 - Valid values range from 0 to 65535.</td>
</tr>

<tr>
<td><tt class="LITERAL">size</tt></td>
<td>The number of queue instances in this queue's redundancy group.</td>
<td>1 - Valid values range from 1 to 65535.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="GEN-QUEUE-OPTIONS" name="GEN-QUEUE-OPTIONS">12.3.1.2. General
Options for a Queue's ume-attributes Element</a></h5>

<p>The table below displays the general options available for a Queue Element. Use the
<tt class="LITERAL">queue</tt> Option Type for these options. A Queue's ume-attributes
Element can also accept Option Types <tt class="LITERAL">lbm-receiver</tt>, <tt
class="LITERAL">lbm-context</tt> and <tt class="LITERAL">lbm-source</tt>. See <a
href="#OPTION-TYPES"><i>Option Types for ume-attributes Elements</i></a> for more
information.</p>

<div class="INFORMALTABLE"><a id="AEN4336" name="AEN4336"></a>
<table border="1" class="CALSTABLE">
<col />
<col />
<col />
<thead>
<tr>
<th>Option</th>
<th>Description</th>
<th>Default Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><tt class="LITERAL">control-topic-name</tt></td>
<td>The name of the queue's control topic. The queue sends all control information for <a
href="#PQD"><i>Parallel Queue Dissemination (PQD)</i></a> and <a href="#SD"><i>Source
Dissemination (SD)</i></a> to this topic.</td>
<td><tt class="LITERAL">UMQ-cntl:qname</tt> where <tt class="LITERAL">qname</tt> is the
name of the queue.</td>
</tr>

<tr>
<td><tt class="LITERAL">queue-advertisement-interval</tt></td>
<td>The interval in milliseconds between advertisements of the queue for queue
resolution.</td>
<td>1000 (1.0 seconds). Value must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">forwarding-behavior</tt></td>
<td>How <b class="APPLICATION">UMQ</b> forwards messages in the <a href="#SQD"><i>Serial
Queue Dissemination (SQD)</i></a> and <a href="#PQD"><i>Parallel Queue Dissemination
(PQD)</i></a> dissemination models. Valid values are <tt
class="LITERAL">store-while-forward</tt> and <tt
class="LITERAL">store-then-forward</tt>.</td>
<td><tt class="LITERAL">store-while-forward</tt></td>
</tr>

<tr>
<td><tt class="LITERAL">dissemination-model</tt></td>
<td>The dissemination model used by the queue. Valid values are: <tt
class="LITERAL">serial-queue-dissemination</tt>, <tt class="LITERAL">SQD</tt>, <tt
class="LITERAL">parallel-queue-dissemination</tt>, <tt class="LITERAL">PQD</tt>, <tt
class="LITERAL">source-dissemination</tt>, and <tt class="LITERAL">SD</tt>. See also <a
href="#MESSAGE-PATHS"><i>Message Paths</i></a></td>
<td><tt class="LITERAL">SQD</tt></td>
</tr>

<tr>
<td><tt class="LITERAL">sending-threads</tt></td>
<td>The number of threads used to send control and data messages from the queue.</td>
<td>1 (This must be greater than 0.)</td>
</tr>

<tr>
<td><tt class="LITERAL">context-check-interval</tt></td>
<td>The interval in milliseconds between activity checks by the queue of a source or
receiver context. Each check looks at the context as well as any associated source and
receiver activity.</td>
<td>1000 (1.0) seconds This must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">context-activity-timeout</tt></td>
<td>The length of time a source or receiver context may be inactive before the queue
disengages from the context.</td>
<td>30000 (30.0 seconds) This must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">context-keepalive-interval</tt></td>
<td>The interval in milliseconds between keepalives messages sent by the queue to
determine whether a source or receiver context is alive or not.</td>
<td>1000 (1.0 seconds) This must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">source-activity-timeout</tt></td>
<td>The length of time a source may be inactive before the queue disengages from the
source.</td>
<td>30000 (30.0 seconds) This must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">source-keepalive-interval</tt></td>
<td>The interval in milliseconds between keepalives messages sent by the queue to
determine whether a source is alive or not.</td>
<td>1000 (1.0 seconds) This must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">rcr-save-timeout</tt></td>
<td>The maximum time in milliseconds that the queue holds RCR information for
retransmission to receivers or other queue instances.</td>
<td>30000 (30.0 seconds) This must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">dead-letter-topic-prefix</tt></td>
<td>Prefix to be used for Dead Letter topic name. <b class="APPLICATION">UMQ</b> creates
a Dead Letter topic name composed of this prefix, the unconsumed message's topic name or
string and the Application Set name. See also <a href="#DEAD-LETTER-QUEUE"><i>Dead Letter
Queue</i></a>.</td>
<td>None.</td>
</tr>

<tr>
<td><tt class="LITERAL">dead-letter-topic-separator</tt></td>
<td>The separator <b class="APPLICATION">UMQ</b> uses between the <tt
class="LITERAL">dead-letter-topic-prefix</tt>, topic name or string and the Application
Set name when it constructs the Dead Letter topic name. See also <a
href="#DEAD-LETTER-QUEUE"><i>Dead Letter Queue</i></a>.</td>
<td>/ (forward slash)</td>
</tr>

<tr>
<td><tt class="LITERAL">allow-browsing</tt></td>
<td>Allow observer receivers to retrieve lists of messages in the queue and to retrieve
specific messages. Allowing browsing introduces some CPU and memory overhead within the
queue, so if browsing support is not needed, setting this to 0 may increase
performance.</td>
<td>1 (browsing enabled). This must be 0 or 1.</td>
</tr>

<tr>
<td><tt class="LITERAL">require-client-authentication</tt></td>
<td>Certain actions (currently topic list, message list, and message retrieve actions by
default) require greater access permissions than a default queue user is given. Normally,
the queue requires the client that is requesting the queue to perform any of those
actions to pass a once-per-session authentication challenge by providing the username and
password credentials of a user authorized to perform the requested action. If the client
fails the authentication challenge, an error is returned to the client by the queue and
the action is not performed. Turning this option off causes the queue to respond to such
requests <span class="emphasis"><i class="EMPHASIS">even if</i></span> the user fails the
authentication challenge. It is therefore NOT recommended to turn this option off in
production environments, as it will make the queue less secure, but it is provided for
convenience in functional test or development environments where security is not
needed.</td>
<td>1 (authentication required). This must be 0 or 1.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="MESSAGE-STORAGE-OPTIONS"
name="MESSAGE-STORAGE-OPTIONS">12.3.1.3. Message Storage Options for a Queue's
ume-attributes Element</a></h5>

<p><b class="APPLICATION">UMQ</b> provides 3 basic modes or operation for message
storage.</p>

<ul>
<li>
<p><b class="APPLICATION">Memory Storage</b>: <b class="APPLICATION">UMQ</b> stores
messages and message state only in memory. A restarted <tt class="LITERAL">umestored</tt>
does not resume any previous operation. In this configuration, <tt
class="LITERAL">sinc-data-filename</tt>, <tt
class="LITERAL">sinc-queue-swap-filename</tt>, and <tt
class="LITERAL">sinc-log-filename</tt> are not set.</p>
</li>

<li>
<p><b class="APPLICATION">Disk Storage, no Persistence</b>: <b
class="APPLICATION">UMQ</b> swaps messages and message state from memory to disk as
needed to maintain low memory overhead. A restarted <tt class="LITERAL">umestored</tt>
does not resume any previous operation. In this configuration, <tt
class="LITERAL">sinc-data-filename</tt> and <tt
class="LITERAL">sinc-queue-swap-filename</tt> are set. The <tt
class="LITERAL">sinc-log-filename</tt> is not set.</p>
</li>

<li>
<p><b class="APPLICATION">Disk Storage, Persistence</b>: <b class="APPLICATION">UMQ</b>
swaps messages and message state from memory to disk as needed to maintain low memory
overhead. In addition, <b class="APPLICATION">UMQ</b> maintains a separate log file that
contains all operations needed to reconstruct state when <b class="APPLICATION">UMQ</b>
restores <tt class="LITERAL">umestored</tt>. In this configuration, <tt
class="LITERAL">sinc-data-filename</tt>, <tt
class="LITERAL">sinc-queue-swap-filename</tt>, and <tt
class="LITERAL">sinc-log-filename</tt> are set.</p>
</li>
</ul>

<p>Use the <tt class="LITERAL">queue</tt> Option Type for these options. A Queue's
ume-attributes Element can also accept Option Types <tt
class="LITERAL">lbm-receiver</tt>, <tt class="LITERAL">lbm-context</tt> and <tt
class="LITERAL">lbm-source</tt>. See <a href="#OPTION-TYPES"><i>Option Types for
ume-attributes Elements</i></a> for more information.</p>

<div class="INFORMALTABLE"><a id="AEN4480" name="AEN4480"></a>
<table border="1" class="CALSTABLE">
<col />
<col />
<col />
<thead>
<tr>
<th>Option</th>
<th>Description</th>
<th>Default Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><tt class="LITERAL">sinc-data-filename</tt></td>
<td>The filename used to store message data on disk.</td>
<td>None.</td>
</tr>

<tr>
<td><tt class="LITERAL">sinc-queue-swap-filename</tt></td>
<td>The filename used to store message state for the queue.</td>
<td>None.</td>
</tr>

<tr>
<td><tt class="LITERAL">sinc-log-filename</tt></td>
<td>The filename used to contain the queue log used to reconstruct state upon restarts.
You can use the <a href="#UMQSLTOOL">umqsltool</a> utility to manage this file.</td>
<td>None.</td>
</tr>

<tr>
<td><tt class="LITERAL">sinc-max-size</tt></td>
<td>The storage area's maximum size in bytes. When exceeded, the queue drops new messages
until more space room is available. For file-based storage areas, the value of this
option is bytes on disk. For memory-based storage, the value of this option is bytes of
memory.</td>
<td>104857600 bytes</td>
</tr>

<tr>
<td><tt class="LITERAL">sinc-data-swap-threshold</tt></td>
<td>The threshold, in bytes, where enough message data causes the oldest and least
referred to messages to be swapped to disk and removed from memory.</td>
<td>104857600 bytes. This option must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">sinc-block-swap-threshold</tt></td>
<td>The threshold, in blocks, where enough message state information causes the oldest
and least referred to information to be swapped to disk and removed from memory. A block
is state for roughly 120 messages for the same topic and Application Set and is roughly
4KB in size.</td>
<td>128 blocks This option must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">sinc-data-readahead</tt></td>
<td>The number of messages that are read in ahead of the current point in an Application
Set's queue position. This helps to initiate asynchronous reads ahead of the time when
they are needed for message assignment.</td>
<td>16</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="QUEUE-MANAGEMENT-OPTIONS"
name="QUEUE-MANAGEMENT-OPTIONS">12.3.1.4. Queue Management Options for a Queue's
ume-attributes Element</a></h5>

<p>The Queue Management options control how queue instances communicate regarding
elections and how they monitor each other.</p>

<p>Use the <tt class="LITERAL">queue</tt> Option Type for these options. A Queue's
ume-attributes Element can also accept Option Types <tt
class="LITERAL">lbm-receiver</tt>, <tt class="LITERAL">lbm-context</tt> and <tt
class="LITERAL">lbm-source</tt>. See <a href="#OPTION-TYPES"><i>Option Types for
ume-attributes Elements</i></a> for more information.</p>

<div class="INFORMALTABLE"><a id="AEN4533" name="AEN4533"></a>
<table border="1" class="CALSTABLE">
<col />
<col />
<col />
<thead>
<tr>
<th>Option</th>
<th>Description</th>
<th>Default Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><tt class="LITERAL">queue-management-election-backoff-timeout</tt></td>
<td>The period of time, in milliseconds, before the Queue Election Master (QEM) recalls
an election. This backoff is initiated only if an error occurs during the election
operation or multiple election calls appear. To avoid livelock, the actual timeout value
used is in the range [0.5 * timeout, 1.5 * timeout].</td>
<td>5000 (5.0 seconds) This option must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">queue-management-election-bias</tt></td>
<td>The bias used during elections to determine the Post Election Master (PEM). A higher
value biases the election to that queue instance.</td>
<td>0 - This option must be less than or equal to 1000.</td>
</tr>

<tr>
<td><tt class="LITERAL">queue-management-election-call-interval</tt></td>
<td>The interval, in milliseconds, between Election Calls by the Queue Election Master
(QEM) once an election is called due to an unresponsive master.</td>
<td>500 (0.5 seconds) This option must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">queue-management-election-call-timeout</tt></td>
<td>The period of time, in milliseconds, that an election call can take. If the Queue
Election Master (QEM) can not end the election early, then this timeout signals the end
of the election and causes the QEM to generate a New Instance List (NIL).</td>
<td>5000 (5.0 seconds) This option must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">queue-management-join-request-interval</tt></td>
<td>The interval, in milliseconds, between Join Requests sent by queues that start
up.</td>
<td>500 (0.5 seconds) This option must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">queue-management-join-request-timeout</tt></td>
<td>The period of time, in milliseconds, after which a starting queue instance gives up
on joining an existing queue and starts its own and elects itself master.</td>
<td>5000 (5.0 seconds) This option must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">queue-management-master-activity-timeout</tt></td>
<td>The period of time, in milliseconds, that a master must be active (by sending Queue
Management Instance Lists) or be declared dead. A new Queue Election Master (QEM) calls
an election after the expiration of this period.</td>
<td>5000 (5.0 seconds) This option must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">queue-management-master-check-interval</tt></td>
<td>The interval, in milliseconds, between checks on the master by the slaves.</td>
<td>1000 (1.0 second) This option must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">queue-management-new-instance-list-interval</tt></td>
<td>The interval, in milliseconds, at which the Queue Election Master (QEM) retransmits
the New Instance List (NIL) after an election call has been completed.</td>
<td>200 (0.2 seconds) This option must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">queue-management-new-instance-list-timeout</tt></td>
<td>The period, in milliseconds, by which a Queue Election Master (QEM) must receive
confirmations of the New Instance List (NIL) that it has sent out. If insufficient
confirmations come back with this period expires, the QEM calls a new election and resets
the timeout.</td>
<td>2000 (2.0 seconds) This option must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">queue-management-resume-operation-interval</tt></td>
<td>The interval, in milliseconds, at which a Queue Election Master (QEM) sends a resume
operation message to the new master after the New Instance List (NIL) has been
confirmed.</td>
<td>200 (0.2 seconds)This option must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">queue-management-resume-operation-timeout</tt></td>
<td>The timeout, in milliseconds, by which a Queue Election Master (QEM) must detect the
resumption of operation after the New Instance List (NIL) has been confirmed. If
resumption has not occurred when this timeout expires, the QEM calls a new election and
resets the timeout.</td>
<td>2000 (2.0 seconds) This option must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">queue-management-slave-activity-timeout</tt></td>
<td>The period of time, in milliseconds, that a slave must be unresponsive before the
master removes the slave from the Queue Management Instance List.</td>
<td>5000 (5.0 seconds) This option must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">queue-management-slave-check-interval</tt></td>
<td>The interval, in milliseconds, between checks of the slaves by the master. This also
controls how often the master sends Queue Management Instance List messages out to all
the slaves.</td>
<td>1000 (1.0 second) This option must be greater than 0.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="QSI-OPTIONS" name="QSI-OPTIONS">12.3.1.5. Queue Slave Instance
(QSI) Options for a Queue's ume-attributes Element</a></h5>

<p>Queue Slave Instances (QSIs) receive assignment information from the master queue
using the control topic. These messages are called Receiver Control Records (RCR). If a
queue instance misses an RCR, it can request it. The options below control the operation
of requesting RCRs.</p>

<p>The acronym, <tt class="LITERAL">qrcrr</tt>, refers to Queue Receiver Control Records
Request.</p>

<p>Use the <tt class="LITERAL">queue</tt> Option Type for these options. A Queue's
ume-attributes Element can also accept Option Types <tt
class="LITERAL">lbm-receiver</tt>, <tt class="LITERAL">lbm-context</tt> and <tt
class="LITERAL">lbm-source</tt>. See <a href="#OPTION-TYPES"><i>Option Types for
ume-attributes Elements</i></a> for more information.</p>

<div class="INFORMALTABLE"><a id="AEN4622" name="AEN4622"></a>
<table border="1" class="CALSTABLE">
<col />
<col />
<col />
<thead>
<tr>
<th>Option</th>
<th>Description</th>
<th>Default Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><tt class="LITERAL">slave-qrcrr-generation-interval</tt></td>
<td>The timeout, in milliseconds, before an RCR must be retransmitted before <b
class="APPLICATION">UMQ</b> abandons the request.</td>
<td>10000 (10.0 seconds) This option must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">slave-qrcrr-interval</tt></td>
<td>The interval, in milliseconds, between sending RCR retransmit requests.</td>
<td>200 (0.2 seconds) This option must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">slave-qrcrr-outstanding-maximum</tt></td>
<td>The maximum number of outstanding Receiver Control Records (RCR) to request at a
single time.</td>
<td>100 This option must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">source-missing-message-timeout</tt></td>
<td>Controls the period of time that <b class="APPLICATION">UMQ</b> instance tracks
source messages that are missed before abandoning them.</td>
<td>5000 (5.0 seconds) This option must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">source-save-timeout</tt></td>
<td>The timeout, in milliseconds, that the queue instance maintains historical state for
a source that has had all its messages consumed.</td>
<td>600000 (10.0 minutes) This option must be greater than 0.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UMESTORED-INDICES-ELEMENT"
name="UMESTORED-INDICES-ELEMENT">12.3.2. Indices Element</a></h4>

<p>The Indices element is a container element for a queue's indices. (See <a
href="#INDEXED-QUEUING"><i>Indexed Queuing</i></a>.) Configuration of indices is
optional, however, specifically configured indices can have rules (allow or deny) applied
to them on a per receiver type basis. See <a href="#INDEX-RULES-ELEMENT"><i>Index Rules
Element</i></a>. Messages sent to the queue with a specifically configured index can be
treated with different attributes than a normal message or a message sent on a non
specifically-configured index. In the abbreviated sample below, <span class="emphasis"><i
class="EMPHASIS">Red Messages</i></span> is an example of a named index, and <span
class="emphasis"><i class="EMPHASIS">Brown Messages</i></span> is an example of a ranged
numeric index.</p>

<pre class="SCREEN">
&lt;indices&#62;
  &lt;index name="Red Messages" type="named" value="red"&#62;
    &lt;ume-attributes&#62; ... &lt;/ume-attributes&#62;
  &lt;/index&#62;
  &lt;index name="Brown Messages" type="ranged" value="13, 44, 80-90"&#62;
    &lt;ume-attributes&#62; ... &lt;/ume-attributes&#62;
  &lt;/index&#62;
&lt;/indices&#62;
     
</pre>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UMESTORED-INDEX-ELEMENT"
name="UMESTORED-INDEX-ELEMENT">12.3.3. Index Element</a></h4>

<p>The Index element defines a single index and has three attributes, a <tt
class="LITERAL">name</tt>, <tt class="LITERAL">type</tt> and <tt
class="LITERAL">value</tt>. See the following examples:</p>

<pre class="SCREEN">
&lt;index name="Red Messages" type="named" value="red"&#62; ... &lt;/index&#62;
&lt;index name="Brown Messages" type="ranged" value="4"&#62; ... &lt;/index&#62;
&lt;index name="Yellow Messages" type="ranged" value="-10, 30-40, 90, 400-"&#62; ... &lt;/index&#62;
   
</pre>

<div class="INFORMALTABLE"><a id="AEN4672" name="AEN4672"></a>
<table border="1" class="CALSTABLE">
<col />
<col />
<col />
<thead>
<tr>
<th>Attribute</th>
<th>Description</th>
<th>Default Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><tt class="LITERAL">name</tt></td>
<td>Name of the index that also accompanies the message ( <a
href="../API/structlbm__umq__index__info__t__stct.html" target="doccontent"><tt
class="LITERAL">lbm_umq_index_info_t</tt></a>). Can be a string or an unsigned 64-bit
integer.</td>
<td>None.</td>
</tr>

<tr>
<td><tt class="LITERAL">type</tt></td>
<td>An index type can be either the name of a single index or a range of indices. A <tt
class="LITERAL">named</tt> index is simply a string literal no longer than 216
characters. A <tt class="LITERAL">ranged</tt> index can specify several ranges of
unsigned 64-bit integers at once, or individual integers, separated by commas. A dash
(<tt class="LITERAL">-</tt>) can be used to indicate "and lower" or "and up".</td>
<td>None.</td>
</tr>

<tr>
<td><tt class="LITERAL">value</tt></td>
<td>Either the index's string value (if a named index) or the index's range(s) of 64-bit
unsigned numbers (if a ranged index).</td>
<td>None.</td>
</tr>
</tbody>
</table>
</div>

<p>Note that negative ranged indices are not allowed; the "<tt class="LITERAL">-10</tt>"
value in the example <tt class="LITERAL">Yellow Messages</tt> index is shorthand for "<tt
class="LITERAL">0-10</tt>". The notation "<tt class="LITERAL">400-</tt>" indicates "<tt
class="LITERAL">400</tt> and up", "up" meaning up to the maximum 64-bit unsigned integer,
so it is shorthand for "<tt class="LITERAL">400-18446744073709551615</tt>".</p>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="INDEX-OPTIONS" name="INDEX-OPTIONS">12.3.4. Options for an
Index's ume-attributes Element</a></h4>

<p>Options for an index appear in the following table. Use the <tt
class="LITERAL">queue</tt> Option Type for these options. See <a
href="#OPTION-TYPES"><i>Option Types for ume-attributes Elements</i></a> for more
information.</p>

<div class="INFORMALTABLE"><a id="AEN4712" name="AEN4712"></a>
<table border="1" class="CALSTABLE">
<col />
<col />
<col />
<thead>
<tr>
<th>Option</th>
<th>Description</th>
<th>Default Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><tt class="LITERAL">log-audit-trail</tt></td>
<td>Flag indicates whether or not the Queue logs receiver activity (assignments,
consumption reports, reassignments, etc.) to the <tt class="LITERAL">umestored</tt> log.
Valid values are 0 (no logging) or 1.</td>
<td>0 (zero)</td>
</tr>

<tr>
<td><tt class="LITERAL">message-lifetime</tt></td>
<td>The maximum lifetime of a queue message in milliseconds. A value of 0 (zero)
configures no lifetime.</td>
<td>0 (zero)</td>
</tr>

<tr>
<td><tt class="LITERAL">message-reassignment-timeout</tt></td>
<td>The maximum amount of time, starting from assignment, that a message may remain
unconsumed by its assigned receiver before the Queue reassigns it to another receiver. A
value of 0 (zero) configures the queue to never reassign.</td>
<td>10000 (10.0 seconds)</td>
</tr>

<tr>
<td><tt class="LITERAL">message-max-reassignments</tt></td>
<td>The maximum number of re-assignments allowed per message. <b
class="APPLICATION">UMQ</b> applies the initial assignment to this maximum. The queue
discards messages that exceed this maximum. Setting this option to 1 means that the
message will never be reassigned. A value of 0 (zero) configures no maximum.</td>
<td>0 (zero)</td>
</tr>

<tr>
<td><tt class="LITERAL">receiver-activity-timeout</tt></td>
<td>The length of time a receiver may be inactive before the Queue disengages from the
receiver.</td>
<td>30000 (30.0 seconds) This must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">receiver-keepalive-interval</tt></td>
<td>The interval in milliseconds between keepalive messages sent by the Queue to
determine whether a receiver is alive or not.</td>
<td>1000 (1.0 seconds) This must be greater than 0.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UMESTORED-APPSETS-ELEMENT"
name="UMESTORED-APPSETS-ELEMENT">12.3.5. Application Sets Element</a></h4>

<p>The Application Sets element is a container element for every application set serviced
by the queue. In the abbreviated sample below, <span class="emphasis"><i
class="EMPHASIS">Set 1</i></span> is one application set and <span class="emphasis"><i
class="EMPHASIS">Set 2</i></span> is another application set. Receiver Type ID of 100
identifies receivers in <span class="emphasis"><i class="EMPHASIS">Set 1</i></span> and
Receiver Type ID of 200 identifies receivers in <span class="emphasis"><i
class="EMPHASIS">Set 2</i></span>.</p>

<pre class="SCREEN">
&lt;application-sets&#62;
  &lt;application-set name="Set 1"&#62;
    &lt;ume-attributes&#62; ... &lt;/ume-attributes&#62;
    &lt;receiver-types&#62;
      &lt;receiver-type id="100"&#62;
          &lt;ume-attributes&#62; ... &lt;/ume-attributes&#62;
      &lt;/receiver-type&#62;
    &lt;/receiver-types&#62;
  &lt;/application-set&#62;
  &lt;application-set name="Set 2"&#62;
    &lt;receiver-types&#62;
        &lt;receiver-type id="200"/&#62;
    &lt;/receiver-types&#62;
  &lt;/application-set&#62;
&lt;/application-sets&#62;
     
</pre>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="APP-SET-ELEMENT" name="APP-SET-ELEMENT">12.3.5.1. Application
Set Element</a></h5>

<p>The Application Set element defines an individual application set and has only one
attribute, <tt class="LITERAL">name</tt>, which identifies the application set. Each
application set also requires a Receiver Type. See <a href="#APP-SET-OPTIONS"><i>Options
for an Application Set's ume-attributes Element</i></a> for application set options.</p>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="APP-SET-OPTIONS" name="APP-SET-OPTIONS">12.3.5.2. Options for
an Application Set's ume-attributes Element</a></h5>

<p>Options for an application set appear in the following table. Use the <tt
class="LITERAL">queue</tt> Option Type for these options. See <a
href="#OPTION-TYPES"><i>Option Types for ume-attributes Elements</i></a> for more
information.</p>

<div class="INFORMALTABLE"><a id="AEN4770" name="AEN4770"></a>
<table border="1" class="CALSTABLE">
<col />
<col />
<col />
<thead>
<tr>
<th>Option</th>
<th>Description</th>
<th>Default Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><tt class="LITERAL">log-audit-trail</tt></td>
<td>Flag indicates whether or not receiver activity (assignments, consumption reports,
reassignments, etc.) are logged to the <tt class="LITERAL">umestored</tt> log. Valid
values are 0 (no logging) or 1.</td>
<td>0 (zero)</td>
</tr>

<tr>
<td><tt class="LITERAL">message-lifetime</tt></td>
<td>The maximum lifetime of a queue message in milliseconds. A value of 0 (zero)
configures no lifetime.</td>
<td>0 (zero)</td>
</tr>

<tr>
<td><tt class="LITERAL">message-reassignment-timeout</tt></td>
<td>The maximum amount of time, starting from assignment, that a message may remain
unconsumed by its assigned receiver before the queue reassigns it to another
receiver.</td>
<td>10000 (10.0 seconds)</td>
</tr>

<tr>
<td><tt class="LITERAL">message-max-reassignments</tt></td>
<td>The maximum number of re-assignments allowed per message. <b
class="APPLICATION">UMQ</b> applies the initial assignment to this maximum. The queue
discards messages that exceed this maximum. Setting this option to 1 means that the
message will never be reassigned. A value of 0 (zero) configures no maximum.</td>
<td>0 (zero)</td>
</tr>

<tr>
<td><tt class="LITERAL">receiver-activity-timeout</tt></td>
<td>The length of time a receiver may be inactive before the queue disengages from the
receiver.</td>
<td>30000 (30.0 seconds) This must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">receiver-keepalive-interval</tt></td>
<td>The interval in milliseconds between keepalive messages sent by the queue to
determine whether a receiver is alive or not.</td>
<td>1000 (1.0 seconds) This must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">discard-behavior</tt></td>
<td>Queue behavior for unconsumed messages of the Application Set that have exceeded
their <tt class="LITERAL">message-lifetime</tt>. If set to <tt
class="LITERAL">dead-letter</tt>, <b class="APPLICATION">UMQ</b> places messages that
exceed their <tt class="LITERAL">message-lifetime</tt> on the Dead Letter Queue. If set
to <tt class="LITERAL">drop</tt>, <b class="APPLICATION">UMQ</b> discards such unconsumed
messages. See also <a href="#DEAD-LETTER-QUEUE"><i>Dead Letter Queue</i></a>.</td>
<td><tt class="LITERAL">drop</tt></td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="RECEIVER-TYPES-ELEMENT"
name="RECEIVER-TYPES-ELEMENT">12.3.5.3. Receiver Types Element</a></h5>

<p>The Receiver Types element is a container element for all the receiver types within
the Application Set.</p>

<div class="SECTION">
<hr />
<h6 class="SECTION"><a id="RECEIVER-TYPE-ELEMENT"
name="RECEIVER-TYPE-ELEMENT">12.3.5.3.1. Receiver Type Element</a></h6>

<p>The Receiver Type element defines an individual receiver type and has only one
attribute, <tt class="LITERAL">id</tt>, which identifies the receiver type. A receiver
type <tt class="LITERAL">id</tt> is a 32-bit integer. See <a
href="#RECEIVER-TYPE-OPTIONS"><i>Options for a Receiver Type's ume-attributes
Element</i></a> for receiver type options.</p>
</div>

<div class="SECTION">
<hr />
<h6 class="SECTION"><a id="RECEIVER-TYPE-OPTIONS"
name="RECEIVER-TYPE-OPTIONS">12.3.5.3.2. Options for a Receiver Type's ume-attributes
Element</a></h6>

<p>Options for a Receiver Type appear in the following table. Use the <tt
class="LITERAL">queue</tt> Option Type for these options. See <a
href="#OPTION-TYPES"><i>Option Types for ume-attributes Elements</i></a> for more
information.</p>

<div class="INFORMALTABLE"><a id="AEN4837" name="AEN4837"></a>
<table border="1" class="CALSTABLE">
<col />
<col />
<col />
<thead>
<tr>
<th>Option</th>
<th>Description</th>
<th>Default Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><tt class="LITERAL">priority</tt></td>
<td>The priority assigned to the receiver type when assigning messages. Lower values have
higher priority. This value may be negative.</td>
<td>0 (zero)</td>
</tr>

<tr>
<td><tt class="LITERAL">portion</tt></td>
<td>The maximum number of messages in flight for the receiver type.</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="SECTION">
<hr />
<h6 class="SECTION"><a id="INDEX-RULES-ELEMENT" name="INDEX-RULES-ELEMENT">12.3.5.3.3.
Index Rules Element</a></h6>

<p>The Index Rules Element is a container element for index rule elements that can allow
or deny receivers of the Receiver Type ID to process messages sent on specific configured
indices. It contains one attribute, order, which specifies the order in which the Queue
applies the index rules. Additionally, the <tt class="LITERAL">order</tt> attribute
specifies the <span class="emphasis"><i class="EMPHASIS">default</i></span> rule (allow
or deny) to apply to an index for a particular receiver type if it is not specifically
configured. Valid orders are either <tt class="LITERAL">"allow, deny"</tt> or <tt
class="LITERAL">"deny, allow"</tt>.</p>

<ul>
<li>
<p>The Queue first applies rules of the first type specified in the <tt
class="LITERAL">order</tt> attribute.</p>
</li>

<li>
<p>The Queue then applies rules of the second type specified and overrides any
overlapping rules of the first type for the indices in which they overlap.</p>
</li>

<li>
<p>The Queue then applies the default rule to any indices not specifically
configured.</p>
</li>
</ul>

<p>The example below establishes the following rules for receivers with Receiver Type ID
100.</p>

<ol type="1">
<li>
<p>Allowed to process messages with any of the Red Messages indices.</p>
</li>

<li>
<p>Explicitly prohibited from being assigned messages with any of the Brown Messages
indices.</p>
</li>

<li>
<p>Prohibited (via the default rule) from being assigned messages sent with any other
indices that fall outside those defined in either Red Messages or Brown Messages.</p>
</li>
</ol>

<pre class="SCREEN">
&lt;receiver-type id="100"&#62;
  &lt;ume-attributes&#62; ... &lt;/ume-attributes&#62;
  &lt;index-rules order="allow, deny"&#62;
    &lt;index-allow name="Red Messages" /&#62;
    &lt;index-deny name="Brown Messages" /&#62;
  &lt;/index-rules&#62;
&lt;/receiver-type&#62;
       
</pre>

<div class="NOTE">
<blockquote class="NOTE">
<p><b>Note:</b> The Index Rules Element is not available to ULB receivers.</p>
</blockquote>
</div>
</div>
</div>
</div>

<div class="SECTION">
<hr />
<h4 class="SECTION"><a id="UMESTORED-QTOPICS-ELEMENT"
name="UMESTORED-QTOPICS-ELEMENT">12.3.6. QueueTopics Element</a></h4>

<p>The Topics Element is a container element for all topics handled by the queue. In the
abbreviated example below, application set <span class="emphasis"><i class="EMPHASIS">Set
1</i></span> is associated with the configured topic. Since the topic is a PCRE regular
expression, any topic message submitted to the queue that matches the pattern is sent to
<span class="emphasis"><i class="EMPHASIS">Set 1</i></span>.</p>

<pre class="SCREEN">
&lt;topics&#62;
  &lt;topic pattern="." type="PCRE"&#62;
    &lt;ume-attributes&#62; ... &lt;/ume-attributes&#62;
      &lt;application-sets&#62;
        &lt;application-set name="Set 1"/&#62;
    &lt;/application-sets&#62;
  &lt;/topic&#62;
&lt;/topics&#62;
     
</pre>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="QTOPIC-ELEMENT" name="QTOPIC-ELEMENT">12.3.6.1. Queue Topic
Element</a></h5>

<p>The Topic Element for a queue uses the same attributes for store topics listed in <a
href="#UMESTORED-TOPIC-ELEMENT"><i>Topic Element</i></a> and must also specify an
Application Set that is configured in the Application Sets section. The options listed in
<a href="#QTOPIC-OPTIONS"><i>Options for a Queue Topic's ume-attributes Element</i></a>
are also available.</p>
</div>

<div class="SECTION">
<hr />
<h5 class="SECTION"><a id="QTOPIC-OPTIONS" name="QTOPIC-OPTIONS">12.3.6.2. Options for a
Queue Topic's ume-attributes Element</a></h5>

<p>Options for a queue topic appear in the following table. Use the <tt
class="LITERAL">queue</tt> Option Type for these options. A Queue's ume-attributes
Element can also accept Option Types <tt class="LITERAL">lbm-receiver</tt>, <tt
class="LITERAL">lbm-context</tt> and <tt class="LITERAL">lbm-source</tt>. See <a
href="#OPTION-TYPES"><i>Option Types for ume-attributes Elements</i></a> for more
information.</p>

<div class="INFORMALTABLE"><a id="AEN4900" name="AEN4900"></a>
<table border="1" class="CALSTABLE">
<col />
<col />
<col />
<thead>
<tr>
<th>Option</th>
<th>Description</th>
<th>Default Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><tt class="LITERAL">message-management-check-interval</tt></td>
<td>The interval in milliseconds between status checks of the outstanding assignments for
all assigned messages on the topic. These checks are done for lifetime and
re-assignment.</td>
<td>1000 (1.0 seconds) This value must not be 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">topic-check-interval</tt></td>
<td>The interval in milliseconds between checks for any sources and receivers of the
topic. If none exist, the queue disengages from the topic.</td>
<td>5000 (5.0 seconds) This value must not be 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">rcr-save-timeout</tt></td>
<td>The maximum time in milliseconds that the queue holds RCR information for
retransmission to receivers or other queue instances.</td>
<td>30000 (30.0 seconds) This must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">message-dissemination-hold-interval</tt></td>
<td>The interval in milliseconds between dissemination of the same message to multiple
receivers.</td>
<td>10000 (10.0 seconds) This must be greater than 0.</td>
</tr>

<tr>
<td><tt class="LITERAL">dead-letter-topic</tt></td>
<td>Setting this option to <b class="APPLICATION">1</b> specifies this topic as a Dead
Letter Topic to be used by <b class="APPLICATION">UMQ</b> to receive unconsumed messages
of the Queue. (The <tt class="LITERAL">pattern</tt> for this topic should match the <tt
class="LITERAL">dead-letter-topic-prefix</tt>.) This topic can only be configured with
one Application Set that has its <tt class="LITERAL">discard-behavior</tt> set to <tt
class="LITERAL">drop</tt> to prevent the chaining of Dead Letter Topics. See also <a
href="#DEAD-LETTER-QUEUE"><i>Dead Letter Queue</i></a>.</td>
<td>0 (zero)</td>
</tr>

<tr>
<td><tt class="LITERAL">message-total-lifetime</tt></td>
<td>Establishes the period of time from when a queue enqueues a message until the time
the message cannot be assigned or reassigned to a receiver. The queue deletes the message
upon expiration of the lifetime. See also <a href="#MESSAGE-LIFETIMES"><i>Message
Lifetimes</i></a>.</td>
<td>0 (zero)</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="OPTION-TYPES" name="OPTION-TYPES">12.4. Option Types for
ume-attributes Elements</a></h3>

<p>All options configured for <code class="PARAMETER">ume-attributes</code> require an
Option Type. The following table describes the five Option Types.</p>

<div class="INFORMALTABLE"><a id="AEN4950" name="AEN4950"></a>
<table border="1" class="CALSTABLE">
<col />
<col />
<col />
<thead>
<tr>
<th>Option Type</th>
<th>Description</th>
<th>Default Value</th>
</tr>
</thead>

<tbody>
<tr>
<td><tt class="LITERAL">lbm-receiver</tt></td>
<td>Allows you to configure receiver (scope) options that you usually specify in a <b
class="APPLICATION">UM</b> Configuration File or set using <tt
class="LITERAL">lbm_*_attr_setopt()</tt>. This Option Type is appropriate for a Topic
Element's <code class="PARAMETER">ume-attributes</code> child element. For example, you
could turn off delivery of NAKs for a particular Topic by including the following within
the Topic's <code class="PARAMETER">ume-attributes</code> element: <tt
class="LITERAL">&lt;option type="lbm-receiver" name="transport_lbtrm_send_naks"
value="0"&#62;</tt> .</td>
<td>None - this is a required attribute.</td>
</tr>

<tr>
<td><tt class="LITERAL">lbm-context</tt></td>
<td>Allows you to configure context (scope) options that you usually specify in a <b
class="APPLICATION">UM</b> Configuration File or set using <tt
class="LITERAL">lbm_*_attr_setopt()</tt>. This Option Type is appropriate for a Store
Element's <code class="PARAMETER">ume-attributes</code> child element. For example, you
could increase the receiver socket buffer by including the following within the <code
class="PARAMETER">ume-attributes</code> element: <tt class="LITERAL">&lt;option
type="lbm-context" name="transport_lbtrm_receiver_socket_buffer"
value="1048576"&#62;</tt> .</td>
<td>None - this is a required attribute.</td>
</tr>

<tr>
<td><tt class="LITERAL">lbm-source</tt></td>
<td>Allows you to configure source (scope) options that you usually specify in a <b
class="APPLICATION">UM</b> Configuration File or set using <tt
class="LITERAL">lbm_*_attr_setopt()</tt>. This Option Type is appropriate for a Topic
Element's <code class="PARAMETER">ume-attributes</code> child element. For example, you
could change the transport by including the following within the <code
class="PARAMETER">ume-attributes</code> element: <tt class="LITERAL">&lt;option
type="lbm-source" name="transport" value="lbtru"&#62;</tt> .</td>
<td>None - this is a required attribute.</td>
</tr>

<tr>
<td><tt class="LITERAL">store</tt></td>
<td>Use this option type for all options that directly configure a store or repository
and appear in either a <code class="PARAMETER">store</code> or <code
class="PARAMETER">topic</code> <code class="PARAMETER">ume-attributes</code> element. For
example, <tt class="LITERAL">&lt;option type="store" name="context-name"
value="remote-store"/&#62;</tt> or <tt class="LITERAL">&lt;option type="store"
name="repository-type" value="disk"/&#62;</tt>.</td>
<td>None - this is a required attribute.</td>
</tr>

<tr>
<td><tt class="LITERAL">queue</tt></td>
<td>Option type used for all <code class="PARAMETER">ume-attributes</code> configured for
the <code class="PARAMETER">queue</code> element and its <code
class="PARAMETER">application-set</code>, <code class="PARAMETER">receiver-type</code>
and <code class="PARAMETER">topic</code> elements.</td>
<td>None - this is a required attribute.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="UMESTORED-CONFIG-DTD" name="UMESTORED-CONFIG-DTD">12.5.
umestored Configuration DTD</a></h3>

<p>The DTD for version 1.2 of <tt class="LITERAL">umestored</tt> appears below. See also
the DTD revision table below.</p>

<div class="INFORMALTABLE"><a id="AEN5012" name="AEN5012"></a>
<table border="1" class="CALSTABLE">
<col width="48" />
<col width="96" />
<col width="144" />
<col width="384" />
<thead>
<tr>
<th>DTD Version</th>
<th>Release Date</th>
<th>Product Version</th>
<th>Supported Features</th>
</tr>
</thead>

<tbody>
<tr>
<td>1.0</td>
<td>Feb. 2007</td>
<td><b class="APPLICATION">UME</b> 1.0</td>
<td>Persistent Stores</td>
</tr>

<tr>
<td>1.1</td>
<td>April 2010</td>
<td><b class="APPLICATION">UME</b> 3.0.1 / <b class="APPLICATION">UMQ</b> 1.0</td>
<td>Persistent Stores, Queues and Ultra Load Balancing (ULB)</td>
</tr>

<tr>
<td>1.2</td>
<td>March 2011</td>
<td><b class="APPLICATION">UME</b> 3.2 / <b class="APPLICATION">UMQ</b> 2.1</td>
<td>Persistent Stores, Queues, Ultra Load Balancing (ULB), Dead Letter Queue, Indexed
Queuing and Indexed ULB</td>
</tr>
</tbody>
</table>
</div>

<pre class="SCREEN">
&lt;!ELEMENT ume-store (daemon, stores?, queues?)&#62;
&lt;!ATTLIST ume-store version CDATA #REQUIRED&#62;
&lt;!ELEMENT daemon (log | uid | pidfile | gid | lbm-config | lbm-license-file | web-monitor)*&#62;
&lt;!ELEMENT log ( #PCDATA )&#62;
&lt;!ATTLIST log type CDATA #IMPLIED&#62;
&lt;!ATTLIST log xml:space (default | preserve) \"default\"&#62;
&lt;!ELEMENT pidfile ( #PCDATA )&#62;
&lt;!ATTLIST pidfile xml:space (default | preserve) \"default\"&#62;
&lt;!ELEMENT uid ( #PCDATA )&#62;
&lt;!ATTLIST uid xml:space (default | preserve) \"default\"&#62;
&lt;!ELEMENT gid ( #PCDATA )&#62;
&lt;!ATTLIST gid xml:space (default | preserve) \"default\"&#62;
&lt;!ELEMENT lbm-config ( #PCDATA )&#62;
&lt;!ATTLIST lbm-config xml:space (default | preserve) \"default\"&#62;
&lt;!ELEMENT lbm-license-file ( #PCDATA )&#62;
&lt;!ATTLIST lbm-license-file xml:space (default | preserve) \"default\"&#62;
&lt;!ELEMENT web-monitor ( #PCDATA )&#62;
&lt;!ATTLIST web-monitor xml:space (default | preserve) \"default\"&#62;
&lt;!ATTLIST web-monitor permission CDATA #IMPLIED&#62;
&lt;!ELEMENT stores (store*)&#62;
&lt;!ELEMENT store (ume-attributes | topics)+&#62;
&lt;!ATTLIST store name CDATA #REQUIRED&#62;
&lt;!ATTLIST store interface CDATA #IMPLIED&#62;
&lt;!ATTLIST store port CDATA #REQUIRED&#62;
&lt;!ELEMENT topics (topic+)&#62;
&lt;!ELEMENT topic (ume-attributes | application-sets)*&#62;
&lt;!ATTLIST topic pattern CDATA #REQUIRED&#62;
&lt;!ATTLIST topic type (direct | PCRE | regexp) #IMPLIED&#62;
&lt;!ELEMENT ume-attributes (option+)&#62;
&lt;!ELEMENT option EMPTY&#62;
&lt;!ATTLIST option type (lbm-receiver | lbm-context | lbm-source | store | queue) #IMPLIED&#62;
&lt;!ATTLIST option name CDATA #REQUIRED&#62;
&lt;!ATTLIST option value CDATA #REQUIRED&#62;
&lt;!ELEMENT queues (queue*)&#62;
&lt;!ELEMENT queue (indices | application-sets | ume-attributes | topics | queue-groups)+&#62;
&lt;!ATTLIST queue name CDATA #REQUIRED&#62;
&lt;!ATTLIST queue interface CDATA #IMPLIED&#62;
&lt;!ATTLIST queue port CDATA #REQUIRED&#62;
&lt;!ATTLIST queue group-index CDATA #IMPLIED&#62;
&lt;!ATTLIST queue group-size CDATA #IMPLIED&#62;
&lt;!ELEMENT receiver-types (receiver-type+)&#62;
&lt;!ELEMENT indices (index+)&#62;
&lt;!ELEMENT index (ume-attributes)*&#62;
&lt;!ATTLIST index name CDATA #REQUIRED&#62;
&lt;!ATTLIST index type CDATA #IMPLIED&#62;
&lt;!ATTLIST index value CDATA #REQUIRED&#62;
&lt;!ELEMENT application-sets (application-set+)&#62;
&lt;!ELEMENT application-set (ume-attributes | receiver-types)*&#62;
&lt;!ATTLIST application-set name CDATA #REQUIRED&#62;
&lt;!ELEMENT receiver-type (ume-attributes*, index-rules?)&#62;
&lt;!ATTLIST receiver-type id CDATA #REQUIRED&#62;
&lt;!ELEMENT index-rules (index-allow | index-deny)*&#62;
&lt;!ATTLIST index-rules order CDATA #IMPLIED&#62;
&lt;!ELEMENT index-allow EMPTY&#62;
&lt;!ATTLIST index-allow name CDATA #REQUIRED&#62;
&lt;!ELEMENT index-deny EMPTY&#62;
&lt;!ATTLIST index-deny name CDATA #REQUIRED&#62;
&lt;!ELEMENT queue-groups (queue-group+)&#62;
&lt;!ELEMENT queue-group EMPTY&#62;
&lt;!ATTLIST queue-group index CDATA #REQUIRED&#62;
&lt;!ATTLIST queue-group size CDATA #REQUIRED&#62;
</pre>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="UMESTORED-CONFIG-EXAMPLE"
name="UMESTORED-CONFIG-EXAMPLE">12.6. Store Configuration Example</a></h3>

<pre class="SCREEN">
&lt;?xml version="1.0"?&#62;
&lt;ume-store version="1.2"&#62;
  &lt;daemon&#62;
    &lt;log&#62;stored.log&lt;/log&#62;
    &lt;pidfile&#62;stored.pid&lt;/pidfile&#62;
    &lt;web-monitor&#62;*:15304&lt;/web-monitor&#62;
  &lt;/daemon&#62;

  &lt;stores&#62;
    &lt;store name="test-store" port="14567"&#62;
      &lt;ume-attributes&#62;
        &lt;option type="store" name="disk-cache-directory" value="cache"/&#62;
        &lt;option type="store" name="disk-state-directory" value="state"/&#62;
        &lt;option type="store" name="context-name" value="remote-store"/&#62;
      &lt;/ume-attributes&#62;
      &lt;topics&#62;
        &lt;topic pattern="test*" type="PCRE"&#62;
          &lt;ume-attributes&#62;
            &lt;option type="store" name="repository-type" value="disk"/&#62;
            &lt;option type="store" name="repository-size-threshold" value="104857600"/&#62;
            &lt;option type="store" name="repository-size-limit" value="209715200"/&#62;
            &lt;option type="store" name="repository-disk-file-size-limit" value="1073741824"/&#62;
            &lt;option type="store" name="source-activity-timeout" value="120000"/&#62;
            &lt;option type="store" name="receiver-activity-timeout" value="120000"/&#62;
            &lt;option type="store" name="retransmission-request-forwarding" value="0"/&#62;
          &lt;/ume-attributes&#62;
        &lt;/topic&#62;
      &lt;/topics&#62;
    &lt;/store&#62;
  &lt;/stores&#62;
&lt;/ume-store&#62;
</pre>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="QUEUE-CONFIG-EXAMPLE" name="QUEUE-CONFIG-EXAMPLE">12.7. Queue
Configuration Example</a></h3>

<pre class="SCREEN">
&lt;?xml version="1.0" encoding="UTF-8"?&#62;
&lt;ume-store version="1.2"&#62;
  &lt;daemon&#62;
    &lt;log&#62;/tmp/qlog.txt&lt;/log&#62;
    &lt;lbm-license-file&#62;/home/.ume_license&lt;/lbm-license-file&#62;
    &lt;lbm-config&#62;/home/queues/lbm-config.cfg&lt;/lbm-config&#62;
    &lt;web-monitor&#62;*:20395&lt;/web-monitor&#62;
  &lt;/daemon&#62;
  &lt;queues&#62;
    &lt;queue name="sample_queue" port="20555" group-index="0"&#62;
      &lt;queue-groups&#62;
        &lt;queue-group index="0" size="5"/&#62;
        &lt;queue-group index="1" size="1"/&#62;
      &lt;/queue-groups&#62;
      &lt;ume-attributes&#62;
        &lt;option type="queue" name="dissemination-model" value="SQD"/&#62;
        &lt;option type="queue" name="sinc-data-filename" value="/tmp/sample_queue_1-sd"/&#62;
        &lt;option type="queue" name="sinc-queue-swap-filename" value="/tmp/sample_queue_1-sqs"/&#62;
        &lt;option type="queue" name="sinc-log-filename" value="/tmp/sample_queue_1-sl"/&#62;
        &lt;option type="queue" name="sinc-max-size" value="25000000"/&#62;
        &lt;option type="queue" name="sending-threads" value="1"/&#62;
        &lt;option type="queue" name="sinc-block-swap-threshold" value="100000"/&#62;
        &lt;option type="queue" name="source-missing-message-timeout" value="5000"/&#62;
        &lt;option type="lbm-source" name="transport" value="lbtrm"/&#62;
      &lt;/ume-attributes&#62;
      &lt;application-sets&#62;
        &lt;application-set name="Set 1"&#62;
          &lt;ume-attributes&#62;
            &lt;option type="queue" name="log-audit-trail" value="0"/&#62;
            &lt;option type="queue" name="message-lifetime" value="6000"/&#62;
            &lt;option type="queue" name="message-reassignment-timeout" value="2000"/&#62;
            &lt;option type="queue" name="message-max-reassignments" value="10"/&#62;
          &lt;/ume-attributes&#62;
          &lt;receiver-types&#62;
            &lt;receiver-type id="100"&#62;
              &lt;ume-attributes&#62;
                &lt;option type="queue" name="priority" value="1"/&#62;
                &lt;option type="queue" name="portion" value="10"/&#62;
              &lt;/ume-attributes&#62;
            &lt;/receiver-type&#62;
            &lt;receiver-type id="101"&#62;
              &lt;ume-attributes&#62;
                &lt;option type="queue" name="priority" value="100"/&#62;
                &lt;option type="queue" name="portion" value="10"/&#62;
              &lt;/ume-attributes&#62;
            &lt;/receiver-type&#62;
          &lt;/receiver-types&#62;
        &lt;/application-set&#62;
        &lt;application-set name="Set 2"&#62;
          &lt;ume-attributes&#62;
            &lt;option type="queue" name="log-audit-trail" value="0"/&#62;
            &lt;option type="queue" name="message-lifetime" value="6000"/&#62;
            &lt;option type="queue" name="message-reassignment-timeout" value="2000"/&#62;
            &lt;option type="queue" name="message-max-reassignments" value="10"/&#62;
          &lt;/ume-attributes&#62;
          &lt;receiver-types&#62;
            &lt;receiver-type id="200"&#62;
              &lt;ume-attributes&#62;
                &lt;option type="queue" name="priority" value="1"/&#62;
                &lt;option type="queue" name="portion" value="10"/&#62;
              &lt;/ume-attributes&#62;
            &lt;/receiver-type&#62;
            &lt;receiver-type id="201"&#62;
              &lt;ume-attributes&#62;
                &lt;option type="queue" name="priority" value="100"/&#62;
                &lt;option type="queue" name="portion" value="10"/&#62;
              &lt;/ume-attributes&#62;
            &lt;/receiver-type&#62;
          &lt;/receiver-types&#62;
        &lt;/application-set&#62;
      &lt;/application-sets&#62;
      &lt;topics&#62;
        &lt;topic pattern="testA" type="PCRE"&#62;
          &lt;application-sets&#62;
            &lt;application-set name="Set 1"/&#62;
          &lt;/application-sets&#62;
        &lt;/topic&#62;
        &lt;topic pattern="testB" type="PCRE"&#62;
          &lt;application-sets&#62;
            &lt;application-set name="Set 2"/&#62;
          &lt;/application-sets&#62;
        &lt;/topic&#62;
        &lt;topic pattern="testC" type="PCRE"&#62;
          &lt;application-sets&#62;
            &lt;application-set name="Set 1"/&#62;
            &lt;application-set name="Set 2"/&#62;
          &lt;/application-sets&#62;
        &lt;/topic&#62;
      &lt;/topics&#62;
    &lt;/queue&#62;
  &lt;/queues&#62;
&lt;/ume-store&#62;
     
</pre>
</div>
</div>

<div class="SECTION">
<hr />
<h2 class="SECTION"><a id="UME-STORE-WEB-MONITOR" name="UME-STORE-WEB-MONITOR">13. <b
class="APPLICATION"><span class="TRADEMARK">Ultra Messaging</span></b> Web
Monitor</a></h2>

<p>The built-in web monitor (configured in the umestored XML configuration file) is a
rich source of information about the health of a <b class="APPLICATION">UM</b> stores and
queues. This section contains a page-by-page guide to reading and interpreting the output
of a <b class="APPLICATION">UM</b> web monitor, with just a couple example sources and
one receiver using a single store. This section discusses the following topics.</p>

<ul>
<li>
<p><a href="#UME-WEB-MONITOR-INDEX-PAGE"><i>Ultra Messaging Web Monitor Index
Page</i></a></p>
</li>

<li>
<p><a href="#PERSISTENT-STORES-PAGE"><i>Persistent Stores Page</i></a></p>
</li>

<li>
<p><a href="#STORE-PAGE"><i>Store Page</i></a></p>
</li>

<li>
<p><a href="#SOURCE-PAGE"><i>Source Page</i></a></p>
</li>

<li>
<p><a href="#RECEIVER-PAGE"><i>Receiver Page</i></a></p>
</li>

<li>
<p><a href="#QUEUE-PAGE"><i>Queue Page</i></a></p>
</li>

<li>
<p><a href="#QUEUE-TOPIC-PAGE"><i>Queue Topic Page</i></a></p>
</li>
</ul>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="UME-WEB-MONITOR-INDEX-PAGE"
name="UME-WEB-MONITOR-INDEX-PAGE">13.1. <b class="APPLICATION"><span
class="TRADEMARK">Ultra Messaging</span></b> Web Monitor Index Page</a></h3>

<p>The web monitor's index page tells what build of <b class="APPLICATION">UM</b> is
running.</p>

<div class="FIGURE"><a id="UMEWEBMONITORINDEX" name="UMEWEBMONITORINDEX"></a>
<p><b>Figure 24. UM Web Monitor Index Page</b></p>

<p><img src="UME.WebMonitor.Index.png" align="CENTER" /></p>
</div>

<p>Click on the link, Stores, to see the <a href="#PERSISTENT-STORES-PAGE"><i>Persistent
Stores Page</i></a>.</p>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="PERSISTENT-STORES-PAGE" name="PERSISTENT-STORES-PAGE">13.2.
Persistent Stores Page</a></h3>

<div class="FIGURE"><a id="UMEWEBMONITORSTORES" name="UMEWEBMONITORSTORES"></a>
<p><b>Figure 25. Persistent Stores Page</b></p>

<p><img src="UME.WebMonitor.Stores.png" align="CENTER" /></p>
</div>

<p>This page shows all the stores configured under the <tt class="LITERAL">umestored</tt>
process. If you had 5 stores configured, they would be numbered Store 0 through Store 4.
Our example has only one store configured, <tt class="LITERAL">ume-test-store</tt>. Click
on the link, ume-test-store, to see the <a href="#STORE-PAGE"><i>Store Page</i></a>.</p>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="STORE-PAGE" name="STORE-PAGE">13.3. Store Page</a></h3>

<div class="FIGURE"><a id="UMEWEBMONITORSTOREPAGE" name="UMEWEBMONITORSTOREPAGE"></a>
<p><b>Figure 26. Persistent Stores Page</b></p>

<p><img src="UME.WebMonitor.Store.Page.png" align="CENTER" /></p>
</div>

<p>This page shows the following information about the store.</p>

<div class="INFORMALTABLE"><a id="AEN5114" name="AEN5114"></a>
<table border="1" class="CALSTABLE">
<col width="144" />
<col width="480" />
<thead>
<tr>
<th>Item</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>Interface</td>
<td>This store is listening on all interfaces (0.0.0.0) on port 41394</td>
</tr>

<tr>
<td>Cache Dir</td>
<td>Pathname for disk store message cache directory. This would be configured as a store
attribute in the store's XML configuration file. <tt class="LITERAL">&lt;option
type="store" name="disk-cache-directory" value="cache/" /&#62;</tt> </td>
</tr>

<tr>
<td>State Dir</td>
<td>Pathname for disk store state directory. This would be configured as a store
attribute in the store's XML configuration file. <tt class="LITERAL">&lt;option
type="store" name="disk-state-directory" value="state/" /&#62;</tt></td>
</tr>

<tr>
<td>Configured Retransmission Request Processing Rate</td>
<td>Current value for the store's <tt
class="LITERAL">retransmission-request-processing-rate</tt> setting.</td>
</tr>

<tr>
<td>Retransmission Request Received Rate</td>
<td>Number of retransmission requests received per second.</td>
</tr>

<tr>
<td>Retransmission Request Service Rate</td>
<td>Number of retransmission requests serviced per second.</td>
</tr>

<tr>
<td>Retransmission Request Drop Rate</td>
<td>Number of retransmission requests dropped per second. Requests are dropped if the
rate of retransmission requests exceeds the configured retransmission request rate.</td>
</tr>

<tr>
<td>Retransmission Request Total Dropped</td>
<td>The number of retransmission requests since the time the store was started.</td>
</tr>

<tr>
<td>Patterns</td>
<td>Specifies the wildcard pattern used to select topics for which a store will provide
persistence services. This would be configured as a topic attribute in the store's XML
configuration file. <tt class="LITERAL">&lt;topic pattern="test*"
type="PCRE"&#62;</tt></td>
</tr>

<tr>
<td>Topics</td>
<td>Displays the topic name and Registration IDs of the two sources publishing on the
topic, 2369562861 and 3131255877.</td>
</tr>
</tbody>
</table>
</div>

<p>You can review information about the sources publishing on the topic by clicking on
Registration ID displayed. The <a href="#SOURCE-PAGE"><i>Source Page</i></a> appears.</p>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="SOURCE-PAGE" name="SOURCE-PAGE">13.4. Source Page</a></h3>

<div class="FIGURE"><a id="UMEWEBMONITORSOURCEPAGE" name="UMEWEBMONITORSOURCEPAGE"></a>
<p><b>Figure 27. UM Web Monitor Source Page</b></p>

<p><img src="UME.WebMonitor.Source.Page.png" align="CENTER" /></p>
</div>

<p>The following table explains the information found in the title of the Source
Page.</p>

<div class="INFORMALTABLE"><a id="AEN5168" name="AEN5168"></a>
<table border="1" class="CALSTABLE">
<col />
<col />
<thead>
<tr>
<th>Source Page Title</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>2504558780</td>
<td>The source's registration ID.</td>
</tr>

<tr>
<td>10.29.3.42.14392</td>
<td>The IP address and port of the source's <b class="APPLICATION">UM</b> configuration
option, <tt class="LITERAL">request_tcp_port</tt>.</td>
</tr>

<tr>
<td>3958260924</td>
<td>The source's transport session index.</td>
</tr>

<tr>
<td>1161732811</td>
<td>The source's topic index within the transport session, 3958260924.</td>
</tr>
</tbody>
</table>
</div>

<p>The transport session and topic indices are useful for debugging purposes when
combined with a Wireshark capture, but are otherwise not relevant here. The following
table provides descriptions of the items in the source page.</p>

<div class="INFORMALTABLE"><a id="AEN5190" name="AEN5190"></a>
<table border="1" class="CALSTABLE">
<col width="144" />
<col width="480" />
<thead>
<tr>
<th>Source Page Item</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>Topic</td>
<td><b class="APPLICATION">test</b> is the source's topic string.</td>
</tr>

<tr>
<td>Last Activity</td>
<td><b class="APPLICATION">09:19:39.501350</b> is the timestamp when the store last heard
from the source, including keepalives sent by <b class="APPLICATION">UM</b> </td>
</tr>

<tr>
<td>Repository</td>
<td><b class="APPLICATION">disk</b> is the type of repository.</td>
</tr>

<tr>
<td>Receiver Paced Persistence</td>
<td>Setting for Receiver-paced Persistence (RPP), which is a repository option both the
repositrory and source must enable. A value of 0 means RPP is not enabled and the
repository is using the default Source-paced Resistence. A value of 1 means RPP is
enabled.</td>
</tr>

<tr>
<td>Message Map: 104</td>
<td><b class="APPLICATION">104</b> is the total number of message fragments the store has
for this source, both on disk and in memory. These are <b
class="APPLICATION">UM</b>-level fragments, not IP-level fragments. <b
class="APPLICATION">UM</b> messages are fragmented into roughly 8 kilobyte chunks for
UDP-based protocols (LBT-RM and LBT-RU) and into roughly 64 kilobyte chunks for LBT-TCP.
The majority of application messages tend to be well under the fragment boundaries, so
the value after "Message Map" could be used as a rough estimate of the number of messages
in the store from this particular source. It's at least a strict upper bound.</td>
</tr>

<tr>
<td rowspan="4">Window: [0, 0, 67]</td>
<td>The first <b class="APPLICATION">0</b> is the <b class="APPLICATION">trailing
sequence number</b>, which is the oldest sequence number in the store for this source. In
most cases, this starts at 0 and stays there for a while, but especially with <b
class="APPLICATION">UME</b> 2.0 where stores can come and go, that may not be the case.
It would also move if you, for example, hit a disk file size limit and had to throw out
some old messages.</td>
</tr>

<tr>
<td>The second <b class="APPLICATION">0</b> is the <b class="APPLICATION">trailing
sequence number</b> for messages <b class="APPLICATION">in memory</b>, so it is the
oldest sequence number still in memory. Typically, you might have more sequence numbers
on disk than you do in memory, or possibly the same number.</td>
</tr>

<tr>
<td>The third number, <b class="APPLICATION">67</b>, is the <b
class="APPLICATION">leading sequence number</b>, which is the highest sequence number in
the store.</td>
</tr>

<tr>
<td><b class="APPLICATION"><span class="emphasis"><i
class="EMPHASIS">NOTE:</i></span></b> For a memory store, the first and second values
would always be the same (the oldest sequence number in memory is the oldest in the
store), so only two values are displayed; the trailing sequence number and the leading
sequence number. These are sequence numbers of message fragments; there's usually just
one fragment per message, but there could be more than one.</td>
</tr>

<tr>
<td rowspan="4">Memory: 7176 / 52428800 / 104857600</td>
<td>First number, <b class="APPLICATION">7176</b>, is the number of bytes of messages
(which includes headers and a bit of store overhead) in memory.</td>
</tr>

<tr>
<td>The second number, <b class="APPLICATION">52428800</b>, is the <tt
class="LITERAL">repository-size-threshold</tt> topic option found in the store's XML
configuration file.</td>
</tr>

<tr>
<td>The third number, <b class="APPLICATION">104857600</b>, is the <tt
class="LITERAL">repository-size-limit</tt> setting.</td>
</tr>

<tr>
<td>You would expect the number of bytes in memory to be under the threshold most of the
time, but it could spike above it before going back down if the store is really busy
momentarily. It should never go above the limit.</td>
</tr>

<tr>
<td>Age Threshold: 0</td>
<td><b class="APPLICATION">0</b> is the <tt class="LITERAL">repository-age-threshold</tt>
setting.</td>
</tr>

<tr>
<td rowspan="4">Sync: [c2f, c2f, c2f]</td>
<td>Pertains to <b class="APPLICATION">disk</b> or <b class="APPLICATION">reduced-fd</b>
repositories only. Sync format is: <tt class="LITERAL">sync_complete_sqn</tt>, <tt
class="LITERAL">sync_sqn</tt>, <tt class="LITERAL">contig_sqn</tt> </td>
</tr>

<tr>
<td><b class="APPLICATION">sync_complete_sqn, c2f</b> Most recent sequence number that
the Operating System has confirmed persisting to disk.</td>
</tr>

<tr>
<td><b class="APPLICATION">sync_sqn, c2f</b> Most recent sequence number for which the
store has initiated persisting to disk, but the Operating System has not confirmed
completion of persistence.</td>
</tr>

<tr>
<td><b class="APPLICATION">contig_sqn, c2f</b> Most recent sequence number that along
with the trail_sqn, creates a range of sequence numbers with no sequence number gaps. For
example, if <tt class="LITERAL">trail_sqn = 0</tt> and the store has persisted all eleven
messages with sequence numbers 0 through 10, <tt class="LITERAL">contig_sqn</tt> would
equal 10. <tt class="LITERAL">contig_sqn</tt> would also be 10 if a receiver declared
message sequence number 7 unrecoverably lost. contig_sqn would be 6 if message sequence
number 7 was not persisted, but not declared lost.</td>
</tr>

<tr>
<td rowspan="3">In progress: 0 / 0</td>
<td>Pertains to <b class="APPLICATION">disk</b> or <b class="APPLICATION">reduced-fd</b>
repositories only. In progress format is: <tt class="LITERAL">num_ios_pending</tt> / <tt
class="LITERAL">num_read_ios_pending</tt></td>
</tr>

<tr>
<td><b class="APPLICATION">num_ios_pending, 0</b> Number of disk writes the store has
submitted to the Operation System. A disk write refers to the store persisting a message
to disk.</td>
</tr>

<tr>
<td>The <b class="APPLICATION">num_read_ios_pending, 0</b> Number of disk reads that the
store has submitted to the Operating System. A disk read, for example, results from an
application retransmission request.</td>
</tr>

<tr>
<td rowspan="4">Offsets: 0 / 190320 / 4294967296</td>
<td>Pertains to <b class="APPLICATION">disk</b> or <b class="APPLICATION">reduced-fd</b>
repositories only. Offsets format is: <tt class="LITERAL">start_offset</tt>, <tt
class="LITERAL">offset</tt>, <tt class="LITERAL">max_offset</tt> </td>
</tr>

<tr>
<td><b class="APPLICATION">start_offset, 0</b> The relative location of the first
message, <tt class="LITERAL">trail_sqn</tt>, in the disk. <tt
class="LITERAL">start_offset</tt> is 0 for a <b class="APPLICATION">reduced-fd</b>
repository.</td>
</tr>

<tr>
<td>The <b class="APPLICATION">offset, 190320</b> The relative location of where the
message, <tt class="LITERAL">contig_sqn</tt> plus one will be written. <tt
class="LITERAL">offset</tt> represents the size of the repository on disk for a <b
class="APPLICATION">reduced-fd</b> repository.</td>
</tr>

<tr>
<td><b class="APPLICATION">max_offset, 4294967296</b> The maximum size of the cache file.
<tt class="LITERAL">max_offset</tt> is the maximum repository size on disk for a <b
class="APPLICATION">reduced-fd</b> repository.</td>
</tr>

<tr>
<td rowspan="4">Active ULBs: 0 high 0</td>
<td><b class="APPLICATION">ULB</b> stands for <b class="APPLICATION">Unrecoverable Loss
Burst</b>. A little extra work is required to keep cache files consistent when the store
gets an unrecoverable loss burst, because unrecoverable loss bursts are delivered all at
once for lots of messages, rather than one at a time like normal unrecoverable loss
messages.</td>
</tr>

<tr>
<td><b class="APPLICATION">Active ULB</b> is the number of unrecoverable loss burst
events the store is dealing with at the moment. It'll go to zero after the ULB has been
resolved.</td>
</tr>

<tr>
<td>The <b class="APPLICATION">high</b> number (<b class="APPLICATION">0</b>) is the
highest sequence number reported among any unrecoverable loss burst event, and is not
reset after the ULB is handled; it increments throughout the process life of the
store.</td>
</tr>

<tr>
<td><b class="APPLICATION"><span class="emphasis"><i
class="EMPHASIS">WARNING:</i></span></b> If you see any number other than 0 here, the
store is losing large numbers of messages, and they are likely not being persisted.</td>
</tr>

<tr>
<td rowspan="2">Loss: 0 ULBs 0</td>
<td>These values are counters for number of unrecoverable loss messages (<b
class="APPLICATION">Loss</b>) and for number of unrecoverable burst loss messages (<b
class="APPLICATION">ULB</b>). These start at 0 when the store starts up and aren't reset
until the store exits. They don't include any loss events that were persisted to disk
from a previous run, only new loss events since the store started. There are cases with
<b class="APPLICATION">UME</b> 2.0 where one individual store could legitimately report
some unrecoverable loss, or maybe even unrecoverable loss bursts.</td>
</tr>

<tr>
<td><b class="APPLICATION"><span class="emphasis"><i
class="EMPHASIS">WARNING:</i></span></b> If you see <b class="APPLICATION">any</b> number
other than <b class="APPLICATION">0</b> for either of these counters, you should
investigate.</td>
</tr>

<tr>
<td rowspan="3">Drops: 0 / 0</td>
<td>If the store is nearing the <tt class="LITERAL">repository-size-limit</tt> and gets
another message, the store will intentionally <b class="APPLICATION">drop</b> a message.
A drop requires a bit of work on the store's part.</td>
</tr>

<tr>
<td>The first <b class="APPLICATION">0</b> is the number of <b class="APPLICATION">active
drops</b>, which are drops that are currently being worked on.</td>
</tr>

<tr>
<td>The second <b class="APPLICATION">0</b> is the total number of drops that have
happened for this store since it was started. Some people want a low <tt
class="LITERAL">repository-size-limit</tt> and therefore lots of intentional drops can
occur. Some don't want to drop any message the whole day - so the interpretation of the
values is up to you.</td>
</tr>

<tr>
<td rowspan="3">LBM Stats</td>
<td>These represent transport-level statistics for the underlying receivers in the store
for the source. The example shown is for a TCP source, so not too many stats are
available (stats for a TCP source are less important from a monitoring perspective).</td>
</tr>

<tr>
<td>Statistics for an LBT-RM or LBT-RU source, however, show number of NAKs sent, which
is important. Ideally, the number of NAKs sent should be 0. A few NAKs from a store
throughout the day is not an emergency. It can be, however, an early warning sign of more
severe problems, and should be taken seriously.</td>
</tr>

<tr>
<td>If you see a non-zero number of NAKs here, take a look at the overall network load
the store's machine is attempting to handle, particularly in very busy periods and
spikes; it may be too much.</td>
</tr>

<tr>
<td>Receivers</td>
<td>Registration IDs for the receivers listening on the source's topic. You can review
information about the receivers listening on the topic by clicking on Registration ID.
The <a href="#RECEIVER-PAGE"><i>Receiver Page</i></a> appears.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="RECEIVER-PAGE" name="RECEIVER-PAGE">13.5. Receiver
Page</a></h3>

<div class="FIGURE"><a id="UMEWEBMONITORRECEIVERPAGE"
name="UMEWEBMONITORRECEIVERPAGE"></a>
<p><b>Figure 28. UM Web Monitor Receiver Page</b></p>

<p><img src="UME.WebMonitor.Receiver.Page.png" align="CENTER" /></p>
</div>

<p>The following table explains the information found in the title of the Receiver
Page.</p>

<div class="INFORMALTABLE"><a id="AEN5378" name="AEN5378"></a>
<table border="1" class="CALSTABLE">
<col />
<col />
<thead>
<tr>
<th>Receiver Page Title</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>2504558781</td>
<td>The receiver's registration ID.</td>
</tr>

<tr>
<td>10.29.3.42.14393</td>
<td>The IP address and port of the source's <b class="APPLICATION">UM</b> configuration
option, <tt class="LITERAL">request_tcp_port</tt>.</td>
</tr>

<tr>
<td>1510613393</td>
<td>The receiver's transport session index.</td>
</tr>

<tr>
<td>1161732811</td>
<td>The source's topic index within the transport session, 1510613393.</td>
</tr>
</tbody>
</table>
</div>

<p>The receiver page shows the following information.</p>

<div class="INFORMALTABLE"><a id="AEN5400" name="AEN5400"></a>
<table border="1" class="CALSTABLE">
<col width="144" />
<col width="480" />
<thead>
<tr>
<th>Receiver Page Item</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>Topic</td>
<td>The topic that the receiver is listening on.</td>
</tr>

<tr>
<td>Last Activity</td>
<td><b class="APPLICATION">09:09:35.981110</b> is the timestamp of when the store last
heard from the receiver, including keepalives sent by <b class="APPLICATION">UM</b>.</td>
</tr>

<tr>
<td>Source RegID</td>
<td>Registration ID of the source publishing on the topic. Click on the Registration ID
link to display the Source Page.</td>
</tr>

<tr>
<td>Source Session ID</td>
<td>The Session ID of the Source sending messages on the topic.</td>
</tr>

<tr>
<td>ACK</td>
<td><b class="APPLICATION">c93</b> is the last message sequence number the receiver
acknowledged.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="QUEUE-PAGE" name="QUEUE-PAGE">13.6. Queue Page</a></h3>

<div class="FIGURE"><a id="UMEWEBMONITORQUEUEPAGE" name="UMEWEBMONITORQUEUEPAGE"></a>
<p><b>Figure 29. Queue Page</b></p>

<p><img src="UME.WebMonitor.Queue.Page.png" align="CENTER" /></p>
</div>

<p>This page shows the following information about <tt class="LITERAL">Queue 0</tt>,
which is named <b class="APPLICATION">Queue 1</b>. The queue name is an attribute of the
Queue Element in the Queue's XML configuration file. <tt class="LITERAL">&lt;queue
name="Queue 1" port="4567" group-index="0"&#62;</tt></p>

<div class="INFORMALTABLE"><a id="AEN5438" name="AEN5438"></a>
<table border="1" class="CALSTABLE">
<col width="144" />
<col width="480" />
<thead>
<tr>
<th>Item</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>Interface</td>
<td>This queue is listening on all interfaces (0.0.0.0) on port 4567</td>
</tr>

<tr>
<td>Queue ID</td>
<td>Identification given to this queue by <b class="APPLICATION">UMQ</b> .</td>
</tr>

<tr>
<td>Sending Threads</td>
<td>Number of threads configured for this queue to send control and data messages. This
would be configured as a Queue Element option in the queue's XML configuration file. <tt
class="LITERAL">&lt;option type="queue" name="sending-threads" value="1/" /&#62;</tt>
</td>
</tr>

<tr>
<td>Sending Threads(s) Queue Size</td>
<td>The number of messages waiting to be sent to receivers in the pool of sending
threads. This could be data and control messages for Parallel Queue Dissemination (PQD),
data messages only for Serial Queue Dissemination (SQD) or control messages only for
Source Dissemination (SD).</td>
</tr>

<tr>
<td>Registered Contexts</td>
<td>Number of application contexts registered with this queue.</td>
</tr>

<tr>
<td rowspan="3">Retransmit Requests</td>
<td><b class="APPLICATION">Message Requests:</b> Number of requests for data message
retransmission.</td>
</tr>

<tr>
<td><b class="APPLICATION">Queue RCR Requests:</b> Number of requests for the
retransmission of control information.</td>
</tr>

<tr>
<td><b class="APPLICATION">Dropped Requests:</b> Number of retransmission requests
dropped by <b class="APPLICATION">Queue 1</b>.</td>
</tr>

<tr>
<td>Patterns</td>
<td>Specifies the wildcard patterns used to select topics for which a queue will accept
data messages. This would be configured as a topic attribute in the queue's XML
configuration file. <tt class="LITERAL">&lt;topic pattern="." type="PCRE"&#62;</tt></td>
</tr>

<tr>
<td>Topics</td>
<td>Displays the RCR Index (<b class="APPLICATION">697157a5</b>) and topic name (<b
class="APPLICATION">a.b</b>) of the topic(s) configured for this queue.</td>
</tr>
</tbody>
</table>
</div>

<p>You can review information about the Queue's topics and application sets by clicking
on the topic's RCR Index, <b class="APPLICATION">697157a5</b>). The <a
href="#QUEUE-TOPIC-PAGE"><i>Queue Topic Page</i></a> appears.</p>
</div>

<div class="SECTION">
<hr />
<h3 class="SECTION"><a id="QUEUE-TOPIC-PAGE" name="QUEUE-TOPIC-PAGE">13.7. Queue Topic
Page</a></h3>

<div class="FIGURE"><a id="UMEWEBMONITORQTOPICPAGE" name="UMEWEBMONITORQTOPICPAGE"></a>
<p><b>Figure 30. Queue Topic Page</b></p>

<p><img src="UME.WebMonitor.QTopic.Page.png" align="CENTER" /></p>
</div>

<p>This page shows the following information about the queue topic, <b
class="APPLICATION">a.b</b>. This topic's RCR Index is <b
class="APPLICATION">697157a5</b>.</p>

<div class="INFORMALTABLE"><a id="AEN5497" name="AEN5497"></a>
<table border="1" class="CALSTABLE">
<col width="144" />
<col width="480" />
<thead>
<tr>
<th>Item</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>Queue</td>
<td>The Queue Name for which this topic is configured. It is also a link back to the
Queue Page for this queue.</td>
</tr>

<tr>
<td>Application Sets</td>
<td><b class="APPLICATION">Queue 1</b> has <b class="APPLICATION">2</b> Application Sets
configured.</td>
</tr>

<tr>
<td>Consumed Messages</td>
<td>Total number of messages consumed by all Application Sets.</td>
</tr>

<tr>
<td>Reassignments</td>
<td>Number of messages that have been reassigned.</td>
</tr>

<tr>
<td>Topic RCR Requests</td>
<td>Number of requests for the retransmission of control information regarding this
topic.</td>
</tr>

<tr>
<td>Saved RCRs</td>
<td>Number of Receiver Control Records save due to retransmissions. You configure how
long the queue saves RCRs a Queue Element attribute in the queue's XML configuration
file. <tt class="LITERAL">&lt;option type="queue" name="rcr-save-timeout"
value="30000"/&#62;</tt>.</td>
</tr>

<tr>
<td rowspan="7">Application Set</td>
<td><b class="APPLICATION">Set 2</b> is the name of this Application Set.</td>
</tr>

<tr>
<td><b class="APPLICATION">Enqueued Messages:</b> Number of messages currently held in <b
class="APPLICATION">Queue 1</b> for <b class="APPLICATION">Set 2</b>.</td>
</tr>

<tr>
<td><b class="APPLICATION">Currently Assigned:</b> Number of messages currently assigned
to a receiver in this Application Set.</td>
</tr>

<tr>
<td><b class="APPLICATION">Currently Reassigning:</b> Number of messages waiting to be
reassigned to receivers.</td>
</tr>

<tr>
<td><b class="APPLICATION">Consumed Messages:</b> Number of messages consumed by
receivers in this Application Set.</td>
</tr>

<tr>
<td><b class="APPLICATION">Reassignments:</b> Number of messages that have been
reassigned to another receiver in this Application Set.</td>
</tr>

<tr>
<td><b class="APPLICATION">Discarded Messages:</b> Number of messages assigned to
receivers in this Application Set that have been discarded.</td>
</tr>

<tr>
<td rowspan="8">Receivers</td>
<td>Number of receivers (<b class="APPLICATION">1</b>) configured for this Application
Set. Specific information for each receiver appears in the table below this item.</td>
</tr>

<tr>
<td><b class="APPLICATION">ID:</b> The Assignment ID given to this receiver by the
queue.</td>
</tr>

<tr>
<td><b class="APPLICATION">Address:</b> The address and port of the receiver.</td>
</tr>

<tr>
<td><b class="APPLICATION">Portion:</b> This receiver's portion size that you configure
as a Receiver Type attribute in the queue's XML configuration file. <tt
class="LITERAL">&lt;option type="queue" name="portion" value="1"/&#62;</tt>.</td>
</tr>

<tr>
<td><b class="APPLICATION">Priority:</b> This receiver's priority that you configure as a
Receiver Type attribute in the queue's XML configuration file. <tt
class="LITERAL">&lt;option type="queue" name="priority" value="1"/&#62;</tt>.</td>
</tr>

<tr>
<td><b class="APPLICATION">Outstanding:</b> Number of assigned messages for which the
queue has not yet received Consumption Reports.</td>
</tr>

<tr>
<td><b class="APPLICATION">Last Active:</b> A timestamp indicating the last activity for
the receiver.</td>
</tr>

<tr>
<td><b class="APPLICATION">Consumed:</b> Total messages consumed by this receiver. The
total for this column should match the Consumed Messages value for the Application
Set.</td>
</tr>

<tr>
<td>Assigned</td>
<td>The number of messages currently assigned to all receivers for the Application Set.
For each assigned message, the Message ID and Assignment ID for the receiver assigned the
message appears. In addition, the <b class="APPLICATION">Reassign</b> and <b
class="APPLICATION">Discard</b> links allow you to reassign or discard the individual
message.</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>

<hr />
<p align="center">Copyright 2007 - 2014 Informatica Corporation.</p>
</body>
<script type="text/javascript">highlight();</script>
</html>

